{
  "hash": "050552d0da0305f7e58c970f5c5f3026",
  "result": {
    "engine": "knitr",
    "markdown": "# A Kaldorian Endogenous Business Cycle Model {#sec-kaldor}\n\n## Overview\n\nThis model captures some key features of Nicholas @Kaldor1940's nonlinear model of endogenous business cycle fluctuations. Unlike @Samuelson1939's linear multiplier-accelerator model (see @sec-how-to-simulate and @sec-stab_analysis), which usually requires repeated external shocks to produce sustained cycles, @Kaldor1940 outlined a model that would produces endogenous, i.e. shock-independent, fluctuations.^[More precisely, @Samuelson1939's model generates shock-independent cycles only for a very specific parameter combination, whereas @Kaldor1940's model generates endogenous cycles for a much broader set of parameters.] @Kaldor1940 assumed that investment and saving were very sensitive to income for normal levels of income, but relatively insensitive for extreme values of income. Graphically, these assumptions give rise to sigmoid-shaped investment and saving functions. As a result, the goods market equilibrium becomes locally unstable due to strong positive feedback effects, but then becomes stable once the economy has sufficiently moved away from equilibrium during booms or busts. Similar to  @Hicks1950 (see @sec-hicks), @Kaldor1940 also assumed a locally unstable goods market, but unlike Hicks who postulated discrete bounds that would prevent fluctuations from exploding, @Kaldor1940 considered smooth bounds that stemmed from the investment and saving behaviour of firms and households. For instance, at high levels of output, investment may become insensitive to output due to rising costs of construction or surging financing cost. Similarly, for low levels of output profit opportunities may be missing, thereby rending investment insensitive to changes in output. It is then the interaction between output and the capital stock that turns these bounded output dynamics into a cycle: @Kaldor1940 assumed that the capital stock exerts a negative effect on investment as an increasing capital stock lowers the marginal efficiency of capital, whereas output pushes up the dynamics of the capital stock due to the accelerator effect.\n\n@Kaldor1940's initial paper mostly relied on graphical analysis. A continuous-time version formalisation of his graphical was subsequently presented in @Chang1971. Textbook treatments can be found in @Gabisch1989, chapter 4. We present a discrete time version of the Kaldor model due to @Bischi2001.\n\n## The Model\n\n$$\n  Y_{t}=Y_{t-1} + \\alpha(I_{t} - S_{t}),  \\quad \\alpha > 0\n$$ {#eq-kaldor_Y}\n\n$$\nK_{t} = (1-\\delta)K_{t-1} + I_{t-1},  \\quad \\delta \\in (0,1)\n$$ {#eq-kaldor_K}\n\n\n$$\nS_{t} = \\sigma Y_t,  \\quad \\sigma \\in (0,1)\n$$ {#eq-kaldor_S}\n\n\n$$\nI_{t} = \\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_t \\right) + \\arctan(Y_{t}- Y^E),  \\quad \\gamma, Y^E > 0 \n$$ {#eq-kaldor_I}\n\nwhere $Y_t$, $K_t$, $S_t$, and $I_t$ represent aggregate output, the capital stock, saving, and investment, respectively.\n\n@eq-kaldor_Y specifies that output reacts slugglishly to excess demand $(I_t > S_t)$ and excess supply $(I_t < S_t)$, with the speed of adjustment given by $\\alpha$. A high value of $\\alpha$ means that firms respond strongly to disequilibria in the goods market. @eq-kaldor_K is the law of motion of the capital stock, with $\\delta$ representing the rate of depreciation. @eq-kaldor_S is th saving function. While @Kaldor1940 assumed a non-linear (sigmoid-shaped) Keynesian saving function, @Bischi2001 (for simplicity) use a linear saving function with a constant marginal propensity to save out of income $(\\sigma)$. The key nonlinearity in this version of the Kaldor model lies in the investment function @eq-kaldor_I. The first term in the investment function, $\\sigma Y^E$, is a normal level of saving that prevails for a normal or expected level of output, $Y^E$. The second term, $\\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_t \\right)$, incorporates a negative feedback effect of the level of the capital stock on investment, where $\\frac{\\sigma Y^E}{\\delta}$ is the normal level of the capital stock. The third term, $\\arctan(Y_{t}- Y^E)$, introduces the sigmoid relationship between investment and output, modelled by means of the arctangent function. Investment is increasing in aggregate output; and this effect is stronger for smaller deviations of actual investment from normal output. @fig-inv plots an example of this sigmoid-shaped investment function for a normal level of output of $Y^E=10$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Plot investment function \n# Set  parameter values\nalpha=1.2 # adjustment speed of output\ndelta=0.2 # depreciation rate\nsigma=0.4 # propensity to save\nY_E=10    # normal level of output\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\nK=sigma*Y_E/delta # set capital stock to normal level\n\n# Create investment function using Y as argument\ninv= function(Y){\n  sigma*Y_E + gamma*(sigma*Y_E/delta - K) + atan(Y - Y_E)\n}\n\n# Plot the function in (I,Y) space\ncurve(inv, from = 5, to = 15, col = 1, xlab=\"Y\", ylab=\"I\" , main=\"\",\n      lwd=1.5, n=10000, ylim=range(2,6))\nabline(v=Y_E, col=2)\nlegend(\"bottomright\", legend = c(\"I\", expression(Y^E)), \n       col = c(1, 2), lwd = 2, bty = \"n\")\n```\n\n::: {.cell-output-display}\n![Kaldor's sigmoid investment function](a_Kaldor_model_files/figure-html/fig-inv-1.png){#fig-inv width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n#### Plot investment function \n\n# Import necessary libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set parameter values\nalpha = 1.2  # adjustment speed of output\ndelta = 0.2  # depreciation rate\nsigma = 0.4  # propensity to save\nY_E = 10     # normal level of output\ngamma = 0.6  # sensitivity of investment to deviations of actual from normal cap stock\nK = sigma * Y_E / delta  # set capital stock to normal level\n\n# Define the investment function using Y as argument\ndef inv(Y):\n    return sigma * Y_E + gamma * (sigma * Y_E / delta - K) + np.arctan(Y - Y_E)\n\n# Plot the function in (I,Y) space\nY_values = np.linspace(5, 15, 10000)\nI_values = inv(Y_values)\n\nplt.figure(figsize=(8,6))\nplt.plot(Y_values, I_values, color='black', linewidth=1.5, label='I')\nplt.axvline(x=Y_E, color='red', linestyle='--', label='$Y^E$')\n\n# Customize the plot\nplt.xlabel(\"Y\")\nplt.ylabel(\"I\")\nplt.title(\"Investment Function\")\nplt.ylim(2, 6)\nplt.legend(loc=\"lower right\", frameon=False)\nplt.grid(True, linestyle='--', alpha=0.6)\n\nplt.show()\n```\n:::\n\n\n:::\n\n## Simulation\n\n### Parameterisation\n\nTable 1 reports the parameterisation used in the simulation. We will analyse below how the model's dynamic properties change as $\\alpha$ and $\\sigma$ vary.\n\n**Table 1: Parameterisation**\n\n| $\\alpha$ | $\\delta$ | $\\sigma$ | $Y^E$ | $\\gamma$ |\n|----------|-----------|----------|-------|----------|\n| 1.2      | 0.2       |   0.4    | 10    |  0.6     |\n\n\n### Simulation code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=200\n\n# Set number of scenarios \nScen=1\n\n# Create (Scen x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=Scen,ncol=Q) # Income/output\nK=matrix(data=1,nrow=Scen,ncol=Q) # capital stock\nS=matrix(data=1,nrow=Scen,ncol=Q) # saving\nI=matrix(data=1,nrow=Scen,ncol=Q) # Investment\n\n# Set fixed parameter values\nalpha=1.2 # adjustment speed of output\ndelta=0.2 # depreciation rate\nsigma=0.4 # propensity to save\nY_E=10    # normal level of output\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\n\n# Simulate the model by looping over Q time periods for Scen different scenarios\nfor (i in 1:Scen){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:500){ # run the model 500-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = Y[i,t-1] + alpha*(I[i,t-1] - S[i,t-1])\n    \n    #(2) Capital stock\n    K[i,t] = (1-delta)*K[i,t-1] + I[i,t-1]\n    \n    #(3) Saving\n    S[i,t] = sigma*Y[i,t] \n    \n    #(4) Investment\n    I[i,t] = sigma*Y_E + gamma*(sigma*Y_E/delta - K[i,t]) + atan(Y[i,t] - Y_E)\n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n```\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Import necessary libraries\nimport numpy as np\n\n# Set number of periods\nQ = 200\n\n# Set number of scenarios\nScen = 1\n\n# Create (Scen x Q)-matrices to contain the simulated data\nY = np.ones((Scen, Q))  # Income/output\nK = np.ones((Scen, Q))  # Capital stock\nS = np.ones((Scen, Q))  # Saving\nI = np.ones((Scen, Q))  # Investment\n\n# Set fixed parameter values\nalpha = 1.2  # Adjustment speed of output\ndelta = 0.2  # Depreciation rate\nsigma = 0.4  # Propensity to save\nY_E = 10     # Normal level of output\ngamma = 0.6  # Sensitivity of investment to deviations of actual from normal capital stock\n\n# Simulate the model by looping over Q time periods for Scen different scenarios\nfor i in range(Scen):\n    for t in range(1, Q):\n        for iterations in range(500):  # Run the model 500 times in each period\n            \n            # Model equations\n            \n            # (1) Output\n            Y[i, t] = Y[i, t-1] + alpha * (I[i, t-1] - S[i, t-1])\n            \n            # (2) Capital stock\n            K[i, t] = (1 - delta) * K[i, t-1] + I[i, t-1]\n            \n            # (3) Saving\n            S[i, t] = sigma * Y[i, t]\n            \n            # (4) Investment\n            I[i, t] = sigma * Y_E + gamma * (sigma * Y_E / delta - K[i, t]) + np.arctan(Y[i, t] - Y_E)\n```\n:::\n\n::: \n\n### Plots\n\n@fig-output displays the dynamics of aggregate output. The model generates endogenous cycles in output that are permanent, i.e. they don't require any external shocks, and they are (roughly) periodic with a cycle length from peak (trough) to peak (trough) of around 17 periods. What generates the turning points? Suppose income is close to its normal level of $Y^E = 10$, but on an increasing trajectory. The accelerator effect on investment will amplify this process as firms will increase their investment, which raises aggregate demand and increases income further. As aggregate output increases, this positive feedback effect gradually becomes weaker, possibly because firms face tighter supply constraints. The rise in the capital stock exerts a negative feedback effect on investment and will eventually dominate the accelerator effect. Firms then start reducing investment and the boom turns into a bust. The accelerator effect again amplifies this downward trajectory until the capital stock has sufficiently fallen to make investment attractive again. This allows the cycle to repeat itself.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set start and end periods for plots\nTmax=100\nTmin =10\n\n# Plot aggregate output and capital stock\nplot(Y[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Aggregate output and capital stock\", cex=0.8)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=2, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(K[1, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(K[1, Tmin:Tmax]))  \nmtext(\"K\", side = 4, line = 3)\nlegend(\"topright\", legend=c(\"Y\", \"K\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Output and capital stock](a_Kaldor_model_files/figure-html/fig-output-1.png){#fig-output width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Set start and end periods for plots\nTmax = 100\nTmin = 10\n\n# Plot aggregate output and capital stock\nfig, ax1 = plt.subplots(figsize=(8, 6))\n\n# Plot Y (aggregate output)\nax1.plot(range(Tmin, Tmax), Y[0, Tmin:Tmax], color='black', linewidth=2, linestyle='-', label='Y')\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(\"Y\", color='black')\nax1.tick_params(axis='y', labelcolor='black')\nax1.set_title(\"Aggregate Output and Capital Stock\", fontsize=10)\n\n# Create a twin axis for the capital stock\nax2 = ax1.twinx()\n\n# Plot K (capital stock)\nax2.plot(range(Tmin, Tmax), K[0, Tmin:Tmax], color='black', linewidth=2, linestyle='--', label='K')\nax2.set_ylabel(\"K\", color='black')\nax2.tick_params(axis='y', labelcolor='black')\n```\n:::\n\n::: \n\n@fig-saving displays the endogenous fluctuations in saving and investment. The horizontal lines represent the average level of saving and investment computed from the simulated data.^[The first 10 periods were excluded from the computation as these are driven by the adjustment from the arbitrary initialisation.] It can be seen that these are virtually identical, reflecting the fact that that the model generates cycles around the goods market equilibrium but never reaches it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Calculate average saving and investment ignoring the first 10 periods\nS_avr=rowMeans(S[,10:Q, drop=FALSE])\nI_avr=rowMeans(I[,10:Q, drop=FALSE])\n\n#Plot saving and investment along with their long-run average values\nplot(S[1, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"S, I\", \n     ylim=range(I[1, Tmin:Tmax],S[1, Tmin:(Tmax)]))\ntitle(main=\"Saving and investment\", xlab = 'Time',cex=0.8,line=2)\nlines(I[1, Tmin:Tmax],lty=2)\nabline(h=S_avr, col=2)\nabline(h=I_avr, col=3)\nlegend(\"topleft\", legend=c(\"S\", \"I\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Saving and investment](a_Kaldor_model_files/figure-html/fig-saving-2.png){#fig-saving width=672}\n:::\n:::\n\n\n### Creating a bifurcation diagram\nNext, we explore numerically under which conditions the model generates endogenous cycles. To do so, we need to introduce some terminology. First, a *limit cycle* is defined as a closed orbit of the state variables of a dynamic system around a locally unstable equilibrium (see @Gandolfo2009, chap. 23). In the neighbourhood of the equilibrium, the system is unstable and gets pushed away from it. However, rather than exhibiting explosive behaviour, the system eventually reaches a periodic cycle as it is bounded by nonlinearities. The fluctuations in @fig-output indeed constitute a limit cycle. Second, a *bifurcation* is defined as a qualitative change of the behaviour of a dynamic system that occurs as a parameter of the system crosses a critical value (see @Gandolfo2009, chap. 24). Third, a *Hopf bifurcation* is a bifurcation that gives rise to a limit cycle.^[In discrete-time dynamic systems, the Hopf bifurcation is also called *Neimark-Sacker bifurcation*.]\n\nWe can analyse the emergence of Hopf bifurcations in this model by means of so-called bifurcation diagrams that plot the dynamics of a representative endogenous variable variable from the model against different values of a parameter of interest. This is accomplished by fixing a parameterisation, simulating the model for a specific value of the parameter of interest, saving the last $T_0$ values of the chosen endogenous variable, and repeating the process for a marginally different value of the parameter of interest. The $T_0$ data points from each run are then placed on the bifurcation diagram.\n\nThe following code first creates a function called *kaldor* that simulates the Kaldor model,^[To increase computational efficiency, we simulate a reduced-form version of the model in $Y_t$ and $K_t$ only that is derived in the analytical discussion below.] taking values of $\\alpha$ and $\\sigma$ as arguments, and returns the last $T_0=50$ values of output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Define a function called \"kaldor\" that simulates a reduced-form version of the model\n# and returns the last 50 values of Y; use alpha and sigma as arguments that \n# need to be supplied when the function is called\nkaldor <- function(alpha, sigma) {\n  \n  # Set how many last values of output you want to save\n  T_0 = 50\n  \n  # Set number of periods\n  Q = 200\n  \n  # Create matrices for simulated data\n  Y = matrix(data = 1, nrow = 1, ncol = Q)  # Income/output\n  K = matrix(data = 1, nrow = 1, ncol = Q)  # Capital stock\n  \n  # Set fixed parameter values\n  gamma = 0.6  # Sensitivity of investment to deviations of actual from normal cap stock\n  delta = 0.2  # Depreciation rate\n  Y_E = 10     # Normal level of output\n\n  # Simulate the model by looping over time periods\n    for (t in 2:Q) {\n\n        ## Model equations\n        # Output\n        Y[1, t] = Y[1, t-1] + \n          alpha * (sigma * Y_E + gamma * (sigma * Y_E / delta - K[1, t-1]) + \n                   atan(Y[1, t-1] - Y_E) - sigma * Y[1, t-1])\n        \n        #  Capital stock\n        K[1, t] = (1 - delta) * K[1, t-1] + \n          sigma * Y_E + gamma * (sigma * Y_E / delta - K[1, t-1]) + \n          atan(Y[1, t-1] - Y_E)\n        \n    } # Close time loop\n\n  return(Y[1, (Q-T_0):Q])  # Return last 50 periods of output\n}\n```\n:::\n\n\nNext, we prepare an initially empty bifurcation diagram and then loop over the *kaldor* function, increasing the parameter $\\alpha$ from 0.5 to 2 in successive steps of 0.01 (while keeping  $\\sigma$ fixed at 0.4), and place the resulting data points on the bifurcation diagram. From @fig-bif-alpha, it can be seen that there indeed appears to be a critical value $\\alpha_0 \\approx 1.15$ below which the model does not generate a limit cycle because the equilibrium is stable. By contrast, for values of $\\alpha$ above that critical value, the model generates a limit cycle whose amplitude appears to be increasing in $\\alpha$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare the bifurcation diagram in alpha\nplot(NULL, xlim = c(0.5, 2.0), ylim = c(7.5, 12.5), \n     xlab = expression(alpha), ylab = expression(Y[t]), \n     pch = \".\", cex = 0.6, col = \"blue\", main = \n       expression(\"Bifurcation diagram in \" * alpha))\n\n# Run kaldor function for different values of alpha (keeping sigma at 0.4) \n# and place data points on bifurcation diagram \nalpha = 0.5  # initialise alpha\nwhile (alpha <= 2) { # run kaldor model until alpha assumes value of 2\n  output = kaldor(alpha=alpha, sigma=0.4) # obtain values of Y for given value of alpha\n  points(rep(alpha, length(output)), output, pch = \".\", col = \"blue\", cex = 2)  # add data points to diagram\n  alpha = alpha + 0.01  # increase alpha stepwise\n}\n```\n\n::: {.cell-output-display}\n![Bifurcation diagram for different sensitivities of output to saving-investment gap](a_Kaldor_model_files/figure-html/fig-bif-alpha-1.png){#fig-bif-alpha width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n### Generate kaldor function\n\n# Define a function called \"kaldor\" that simulates a reduced-form version of the model\n# and returns the last 50 values of Y\n\ndef kaldor(alpha, sigma):\n    # Set how many last values of output you want to save\n    T_0 = 50\n    \n    # Set number of periods\n    Q = 200\n    \n    # Create matrices for simulated data\n    Y = np.ones((1, Q))  # Income/output\n    K = np.ones((1, Q))  # Capital stock\n    \n    # Set fixed parameter values\n    gamma = 0.6  # Sensitivity of investment to deviations of actual from normal capital stock\n    delta = 0.2  # Depreciation rate\n    Y_E = 10     # Normal level of output\n    \n    # Simulate the model by looping over time periods\n    for t in range(1, Q):\n        \n        # Model equations\n        \n        # (1) Output\n        Y[0, t] = Y[0, t-1] + alpha * (\n            sigma * Y_E + gamma * (sigma * Y_E / delta - K[0, t-1]) + \n            np.arctan(Y[0, t-1] - Y_E) - sigma * Y[0, t-1])\n        \n        # (2) Capital stock\n        K[0, t] = (1 - delta) * K[0, t-1] + (\n            sigma * Y_E + gamma * (sigma * Y_E / delta - K[0, t-1]) + \n            np.arctan(Y[0, t-1] - Y_E))\n    \n    # Return last 50 periods of output\n    return Y[0, (Q-T_0):Q]\n\n\n#### Generate bifurcation diagram\n\n# Prepare the bifurcation diagram in alpha\nplt.figure(figsize=(10, 6))\nplt.title(r'Bifurcation Diagram in $\\alpha$', fontsize=14)\nplt.xlabel(r'$\\alpha$', fontsize=12)\nplt.ylabel(r'$Y_t$', fontsize=12)\nplt.xlim(0.5, 2.0)\nplt.ylim(7.5, 12.5)\n\n# Run kaldor function for different values of alpha (keeping sigma at 0.4)\n# and place data points on bifurcation diagram\n\nalpha = 0.5  # Initialize alpha\nwhile alpha <= 2.0:\n    # Obtain values of Y for the given value of alpha\n    output = kaldor(alpha=alpha, sigma=0.4)\n    \n    # Add data points to the diagram\n    plt.scatter([alpha] * len(output), output, color='blue', s=4, marker='.')\n    \n    # Increase alpha stepwise\n    alpha += 0.01\n\n# Show the bifurcation diagram\nplt.show()\n```\n:::\n\n:::\n\n@fig-bif-sigma does the same for the parameter $\\sigma$, starting from $\\sigma=0.1$ and raising it to 0.5 in steps of 0.001 (while keeping a fixed $\\alpha$ of 1.2). The parameter $\\sigma$ appears to exhibit a critical value $\\sigma_0 \\approx 0.25$ above which a limit cycle occurs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare the bifurcation diagram in sigma\nplot(NULL, xlim = c(0.1, 0.5), ylim = c(7, 11.5), \n     xlab = expression(sigma), ylab = expression(Y[t]), \n     pch = \".\", cex = 0.6, col = \"blue\",\n     main = expression(\"Bifurcation diagram in \" * sigma))\n\n# Run kaldor function for different values of sigma (keeping alpha at 1.2)\n# and place data points on bifurcation diagram \nsigma = 0.1 # initialise alpha\nwhile (sigma <= 0.5) { # run kaldor model until sigma assumes value of 0.5\n  output = kaldor(alpha=1.2, sigma=sigma) # obtain the values of Y for given value of sigma\n  points(rep(sigma, length(output)), output, pch = \".\", col = \"blue\", cex = 1)  # add data points to diagram\n  sigma = sigma + 0.001  # increase sigma stepwise\n}\n```\n\n::: {.cell-output-display}\n![Bifurcation diagram for different saving propensities](a_Kaldor_model_files/figure-html/fig-bif-sigma-2.png){#fig-bif-sigma width=672}\n:::\n:::\n\n\n## Directed graph\n\nAnother perspective on the model's properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node $x_1$ to node $x_2$ indicates a causal impact of $x_1$ on $x_2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 5 variables: \n  # endogenous: (1) Y, (2) K, (3) S, (4) I\n  # exogenous: (5) YE\n\n              #Y K S I YE\nM_mat=matrix(c(0,0,1, 1, 1, # Y\n               0,0,0, 1, 0, # K\n               1,0,0, 0, 0, # S\n               1,1,0, 0, 1, # I\n               0,0,0, 0, 0),# YE\n               5, 5, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"K\", \"S\", \"I\", expression(Y^E))\n\n# Plot directed graph\nplot(dg, main=\"Directed graph of Kaldor model\", vertex.size=40, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n```\n\n::: {.cell-output-display}\n![Directed graph of Kaldor model](a_Kaldor_model_files/figure-html/fig-dag-1.png){#fig-dag width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n##### Generate directed graph\n# Import necessary libraries\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 5 variables:\n# Endogenous: (1) Y, (2) K, (3) S, (4) I\n# Exogenous: (5) YE\n\nM_mat = np.array([[0, 0, 1, 1, 1],  # Y\n                  [0, 0, 0, 1, 0],  # K\n                  [1, 0, 0, 0, 0],  # S\n                  [1, 1, 0, 0, 1],  # I\n                  [0, 0, 0, 0, 0]]) # YE\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat = M_mat.T\n\n# Create directed graph from adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"Y\", 1: \"K\", 2: \"S\", 3: \"I\", 4: r\"$Y^E$\"}\n\n# Plot the graph using the specified approach\npos = nx.spring_layout(G, k=0.5)\nplt.figure(figsize=(8, 4))\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='->', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\n\nplt.title(\"Directed Graph of Kaldor Model\", fontsize=14)\nplt.show()\n```\n:::\n\n:::\n\n@fig-dag illustrates the endogenous cycle generated by the interaction between  income $Y$, investment $I$, saving $S$, and the capital stock. An important exogenous variable depicted here is the normal income level $Y^E$, which sets the equilibrium around which output fluctuates.\n\n## Analytical discussion\nTo analyse the dynamic properties of this discrete-time version of the @Kaldor1940 model, we first reduce it to a two-dimensional system in $Y_t$ and $K_t$. Substitution of @eq-kaldor_S and @eq-kaldor_S into @eq-kaldor_Y and @eq-kaldor_K yields: \n\n\n$$\nY_{t}=Y_{t-1} + \\alpha \\left[\\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_{t-1} \\right) + \\arctan(Y_{t-1}- Y^E)  -  \\sigma Y_{t-1} \\right]\n$$ {#eq-kaldor_Y_reduc}\n\n$$\nK_{t} = (1-\\delta)K_{t-1} + \\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_t \\right) + \\arctan(Y_{t-1}- Y^E). \n$$ {#eq-kaldor_K_reduc}\n\n\nUsing the fact that $\\frac{\\partial \\arctan(a+bx)}{\\partial x}=\\frac{1}{1+(a+bx)^2}$, we can write the system's Jacobian matrix as:\n\n$$\nJ=\\begin{bmatrix} 1 + \\frac{\\alpha}{1+(Y-Y^E)^2} - \\alpha\\sigma & -\\alpha \\gamma \\\\ \\frac{1}{1+(Y-Y^E)^2} & 1-\\delta - \\gamma\\  \\end{bmatrix}.\n$$\n\n\nNext, we determine the steady states of the model by setting $Y_t = Y_{t-1}$ and $K_t = K_{t-1}$, which yields:\n\n$$\n0=\\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K \\right) + \\arctan(Y- Y^E)  -  \\sigma Y \n$$ {#eq-kaldor_Y_eq}\n\n$$\n0 = -\\delta K + \\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K \\right) + \\arctan(Y- Y^E). \n$$ {#eq-kaldor_K_eq}\n\nFrom this, we can readily obtain:\n\n$$\nK=\\frac{\\sigma}{\\delta}Y,\n$$\nand using this equation to eliminate $K$ in @eq-kaldor_K_eq, we get:\n\n$$\n\\sigma \\left(1+\\frac{\\gamma}{\\delta}\\right)(Y- Y^E)=\\arctan(Y-Y^E).\n$$ {#eq-kaldor_eq}\n\nLet $\\sigma \\left(1+\\frac{\\gamma}{\\delta}\\right)=\\theta$. @fig-eq plots the left-hand side and right-hand side of @eq-kaldor_eq, for two different parameterisations of $\\theta$. It can be seen that for $\\theta_1 >1$, there is a unique equilibrium at $Y^*=Y^E$, which implies $K^*=\\frac{\\sigma}{\\delta}Y^E$. However, for $\\theta_2 < 1$, two further equilibria emerge, which are located symmetrically around the $Y^*=Y^E$ equilibrium.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Plot equilibria \n# Set  parameter values\nparm_1=1.2\nparm_2=0.8\nY_E=10\n\n# Create functions using Y as argument\nf1a= function(Y){\n  parm_1*(Y - Y_E)\n}\n\nf1b= function(Y){\n  parm_2*(Y - Y_E)\n}\n\nf2= function(Y){\n atan(Y - Y_E)\n}\n\n# Plot the functions\ncurve(f1a, from = 5, to = 15, col = 1, xlab=\"Y\", ylab=\"\" , main=\"\",\n      lwd=1.5, n=10000, ylim=range(-2,2))\ncurve(f1b, from = 5, to = 15, col = 2, add=TRUE,\n      lwd=1.5,)\ncurve(f2, from = 5, to = 15, col = 3, add=TRUE,\n      lwd=1.5)\nlegend(\"bottomright\", legend = c(expression(theta[1](Y-Y^E)), \n      expression(theta[2](Y-Y^E)), expression(arctan(Y-Y^E))), \n       col = 1:3, lwd = 2, bty = \"n\")\n```\n\n::: {.cell-output-display}\n![Equilibria](a_Kaldor_model_files/figure-html/fig-eq-2.png){#fig-eq width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n#### Plot equilibria\n\n# Set parameter values\nparm_1 = 1.2\nparm_2 = 0.8\nY_E = 10\n\n# Define functions\ndef f1a(Y):\n    return parm_1 * (Y - Y_E)\n\ndef f1b(Y):\n    return parm_2 * (Y - Y_E)\n\ndef f2(Y):\n    return np.arctan(Y - Y_E)\n\n# Create Y values for plotting\nY_vals1 = np.linspace(5, 15, 1000)\nY_vals2 = np.linspace(5, 15, 1000)\n\n# Plot the functions\nplt.figure(figsize=(8, 6))\nplt.plot(Y_vals1, f1a(Y_vals1), color='black', linewidth=1.5, label=r'$\\theta_1(Y - Y^E)$')\nplt.plot(Y_vals1, f1b(Y_vals1), color='red', linewidth=1.5, label=r'$\\theta_2(Y - Y^E)$')\nplt.plot(Y_vals2, f2(Y_vals2), color='green', linewidth=1.5, label=r'$\\arctan(Y - Y^E)$')\n\n# Customize the plot\nplt.xlabel(\"Y\", fontsize=12)\nplt.ylabel(\"\", fontsize=12)\nplt.ylim(-2, 2)\nplt.legend(loc=\"lower right\", frameon=False)\n\n# Show the plot\nplt.show()\n```\n:::\n\n:::\n\nLet us focus on the  $\\theta >1$ case yielding the unique $Y^*= Y^E$ equilibrium, which is the one corresponding to the parameterisation used in the simulations above.^[See @Bischi2001 for a comprehensive mathematical analysis of all possible equilibria of the model.] The Jacobian matrix evaluated at this equilibrium is given by:\n\n$$\nJ^*=\\begin{bmatrix} 1 + \\alpha(1-\\sigma) & -\\alpha \\gamma \\\\ 1 & 1-\\delta - \\gamma\\  \\end{bmatrix}.\n$$\nThe characteristic polynomial yielding the eigenvalues of the Jacobian is:\n\n$$\\lambda^2-\\lambda[2+\\alpha(1-\\sigma)-\\delta-\\gamma]+(1-\\delta -\\gamma)(1-\\alpha\\sigma) +\\alpha(1-\\delta)=0,$$\n\nwhere $2+\\alpha(1-\\sigma)-\\delta-\\gamma =tr(J)$ and $(1-\\delta -\\gamma)(1-\\alpha\\sigma) +\\alpha(1-\\delta) = det(J)$.\n\nFirst, let us derive the condition under which the model produces cycles thanks to the eigenvalues being a pair of complex conjugates. The roots of the polynomial are:\n\n$$\n\\lambda_{1,2} = \\frac{tr(J) \\pm \\sqrt{tr(J)^2-4det(J)}}{2},\n$$\n\nso that the eigenvalues will be complex if $tr(J)^2-4 det(J)<0$, which can also be written as $(J_{11}-J_{22})^2 + J_{12}J_{21}<0$, where $J_{ii}$ are the elements of the Jacobian matrix.^[See also @Stockhammer2019 on this condition for cycles.] Thus, the condition for cycles becomes:\n\n$$\n[\\alpha(1-\\sigma) + \\delta + \\gamma]^2 - 4\\alpha \\gamma < 0.  \n$$\nNext, the stability conditions for two-dimensional systems in discrete time\nare:\n\n$$\n1+tr(J)+det(J)>0,\n$$ $$\n1-tr(J)+det(J)>0,\n$$ \n$$\n1-det(J)>0,\n$$ \n\nwhere $tr(J)$ is the trace and $det(J)$ is the determinant of the Jacobian.\n\nLet us focus on the last condition, which gives:\n\n$$\n(1-\\delta -\\gamma)(1-\\alpha \\sigma) +\\alpha(1-\\delta)< 1.\n$$\n\nWe now generate a plot that displays the cycle and the stability condition in the $(\\alpha, \\sigma)$-space. We further add a horizontal line at $\\sigma \\left(1+\\frac{\\gamma}{\\delta}\\right)=\\theta=1$, demarcating values of $\\sigma$ for which there is a unique equilibrium (above the line) and for which there are three equilibria (below the line).^[To plot the conditions, we replace the inequalities by equality signs and solve for 0.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Plot cycle and stability condition \n\n# Set fixed parameter values\ndelta=0.2 # depreciation rate\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\n\n# Create function for cycle condition\ncyc= function(alpha, sigma){\n (alpha*(1-sigma) + delta + gamma)^2 - 4*alpha*gamma \n}\n\n# Create function for stability condition\nstab= function(alpha, sigma){\n (1-delta -gamma)*(1-alpha*sigma) +alpha*(1-delta) - 1\n}\n\n# Create a grid of alpha and sigma values\nalpha_vals = seq(0.5, 2, length.out = 100)\nsigma_vals = seq(0, 1, length.out = 100)\ngrid=expand.grid(alpha = alpha_vals, sigma = sigma_vals)\n\n# Evaluate the functions on the grid\ncyc_vals = matrix(cyc(grid$alpha, grid$sigma), nrow = 100)\nstab_vals = matrix(stab(grid$alpha, grid$sigma), nrow = 100)\n\n# Plot the curves\ncontour(alpha_vals, sigma_vals, cyc_vals, levels = 0, col = 1, lwd = 2, \n        xlab = expression(alpha), ylab = expression(sigma), main = \"\")\ncontour(alpha_vals, sigma_vals, stab_vals, levels = 0, col = 2, lwd = 2, add = TRUE)\nabline(h=1/(1+gamma/delta), col=3)\nlegend(\"topleft\", legend = c(\"cycle condition\",\n       \"stability condition\", \"unique equilibrium condition\"), \n       col = 1:3, lty = 1, cex=0.8, bty = \"n\")\n```\n\n::: {.cell-output-display}\n![Cycle and stability conditions](a_Kaldor_model_files/figure-html/fig-bif-2.png){#fig-bif width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\n### Plot cycle and stability condition\nfrom matplotlib.lines import Line2D\n# Set fixed parameter values\ndelta = 0.2  # Depreciation rate\ngamma = 0.6  # Sensitivity of investment to deviations from normal capital stock\n\n# Define functions for cycle and stability conditions\ndef cyc(alpha, sigma):\n    return (alpha * (1 - sigma) + delta + gamma)**2 - 4 * alpha * gamma\n\ndef stab(alpha, sigma):\n    return (1 - delta - gamma) * (1 - alpha * sigma) + alpha * (1 - delta) - 1\n\n# Create a grid of alpha and sigma values\nalpha_vals = np.linspace(0.5, 2, 100)\nsigma_vals = np.linspace(0, 1, 100)\nalpha_grid, sigma_grid = np.meshgrid(alpha_vals, sigma_vals)\n\n# Evaluate the functions on the grid\ncyc_vals = cyc(alpha_grid, sigma_grid)\nstab_vals = stab(alpha_grid, sigma_grid)\n\n# Plot the curves\nplt.figure(figsize=(8, 6))\n\n# Plot cycle condition contour\ncyc_contour = plt.contour(alpha_vals, sigma_vals, cyc_vals, levels=[0], colors='black', linewidths=2)\n\n# Plot stability condition contour\nstab_contour = plt.contour(alpha_vals, sigma_vals, stab_vals, levels=[0], colors='red', linewidths=2)\n\n# Plot unique equilibrium condition\nunique_eq_line = plt.axhline(y=1 / (1 + gamma / delta), color='green', linestyle='-', linewidth=2)\n\n# Customize the plot\nplt.xlabel(r'$\\alpha$', fontsize=12)\nplt.ylabel(r'$\\sigma$', fontsize=12)\n\n# Create custom legend symbols\nlegend_elements = [\n    Line2D([0], [0], color='black', lw=2, label=\"Cycle condition\"),\n    Line2D([0], [0], color='red', lw=2, label=\"Stability condition\"),\n    Line2D([0], [0], color='green', lw=2, label=\"Unique equilibrium condition\")\n]\n\n# Add legend with symbols\nplt.legend(handles=legend_elements, loc=\"upper left\", frameon=False, fontsize=9)\n\nplt.grid(False)\nplt.show()\n```\n:::\n\n:::\n\n\nAccording to @fig-bif, combinations of $\\alpha$ and $\\sigma$ above the cycle and to the right of the stability condition yield eigenvalues of the model that are a pair of complex conjugates with a modulus greater than one. The model will then generate a limit cycle. For combinations of $\\alpha$ and $\\sigma$ to the left of the stability and above the cycle condition, the model yields damped oscillations that will converge to a stable equilibrium. For combinations of $\\alpha$ and $\\sigma$ to the left of the stability and below the cycle condition, the model yields monotonic converges to a stable equilibrium. \n\nThese analytically derived conditions correspond to and illuminate further the numerical results in the bifurcation diagrams above. In @fig-bif-alpha, it could be seen that for a fixed $\\sigma=0.4$, limit cycles appear to occur for $\\alpha \\gtrapprox 1.15$. With the analytical results plotted in @fig-bif we can confirm that this indeed constitutes a Hopf bifurcation, where the equilibrium loses its stability while the eigenvalues are complex. Similarly, in @fig-bif-sigma, it could be seen that for a fixed $\\alpha=1.2$, a limit cycle appears to occur for $\\sigma \\gtrapprox 0.25$. @fig-bif suggests that for values of $\\sigma$ below that critical value, the $Y^*=Y^E$ equilibrium ceases to be unique, and the system is apparently attracted to one of the other two equilibria, which appear to be stable.\n\nFinally, we can also compute the eigenvalues and check the analytical stability and cycle conditions numerically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Stability analysis\n\n# Set parameter values\nalpha=1.2 # adjustment speed of output\ndelta=0.2 # depreciation rate\nsigma=0.4 # propensity to save\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\n\n# Construct Jacobian matrix evaluated at the Y*=Y_E steady state\nJ_base=matrix(c(1+alpha*(1-sigma), -alpha*gamma,\n                1, 1-delta-gamma),\n                 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_base=eigen(J_base)\n(evals_base = ev_base$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.96+0.3773592i 0.96-0.3773592i\n```\n\n\n:::\n\n```{.r .cell-code}\n# Obtain determinant and trace\ntr=sum(diag(J_base)) # trace\n(det=det(J_base))      # determinant\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.064\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate modulus\n(mod_base=Mod(evals_base[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.031504\n```\n\n\n:::\n\n```{.r .cell-code}\n#Check general stability conditions\nprint(1+tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check analytical stability condition\n((1-delta -gamma)*(1-alpha*sigma) +alpha*(1-delta)) < 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\nThese results confirm that the modulus of the complex eigenvalue is indeed larger than unity and the system thus unstable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Check cycle condition and compute cycle length \n\n# Check analytical cycle condition\n((alpha*(1-sigma) + delta + gamma)^2 - 4*alpha*gamma) < 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Save real and imaginary part of complex eigenvalue\nre=Re(evals_base[1])\nim=Im(evals_base[1])\n\n# Calculate cycle length\nL=(2*pi)/(acos(re/mod_base))\nL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16.77624\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n###### Stability analysis\n\n# Set parameter values\nalpha = 1.2  # Adjustment speed of output\ndelta = 0.2  # Depreciation rate\nsigma = 0.4  # Propensity to save\ngamma = 0.6  # Sensitivity of investment to deviations from normal capital stock\n\n# Construct Jacobian matrix evaluated at the Y* = Y_E steady state\nJ_base = np.array([\n    [1 + alpha * (1 - sigma), -alpha * gamma],\n    [1, 1 - delta - gamma]\n])\n\n# Obtain eigenvalues\nevals_base, _ = np.linalg.eig(J_base)\n\n# Print eigenvalues\nprint(\"Eigenvalues:\", evals_base)\n\n# Obtain determinant and trace\ntr = np.trace(J_base)   # Trace\ndet = np.linalg.det(J_base)  # Determinant\n\n# Print determinant\nprint(f\"Determinant: {det}\")\n\n# Calculate and print modulus of the first eigenvalue\nmod_base = abs(evals_base[0])\nprint(f\"Modulus of first eigenvalue: {mod_base}\")\n\n# Check general stability conditions\nprint(f\"1 + tr + det > 0: {1 + tr + det > 0}\")\nprint(f\"1 - tr + det > 0: {1 - tr + det > 0}\")\nprint(f\"1 - det > 0: {1 - det > 0}\")\n\n# Check analytical stability condition\nprint(((1 - delta - gamma) * (1 - alpha * sigma) + alpha * (1 - delta)) < 1)\n\n### Check cycle condition and compute cycle length \n\n# Check analytical cycle condition\nprint(((alpha * (1 - sigma) + delta + gamma)**2 - 4 * alpha * gamma) < 0)\n\n# Save real and imaginary parts of complex eigenvalue\nre = np.real(evals_base[0])\nim = np.imag(evals_base[0])\n\n# Calculate cycle length\nL = (2 * np.pi) / np.arccos(re / mod_base)\nprint(f\"Cycle length: {L}\")\n```\n:::\n\n:::\n\nThe analytical cycle condition confirms that the eigenvalues of the system will be complex and thus generate cycles. The implied cycle length is around 17 periods.\n\n## References\n",
    "supporting": [
      "a_Kaldor_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}