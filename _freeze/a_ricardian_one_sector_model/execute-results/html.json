{
  "hash": "d4723c5758cbca3b07c9e74dfdb74f37",
  "result": {
    "engine": "knitr",
    "markdown": "# A Ricardian One-Sector Model {#sec-ricardo_1}\n\n## Overview\n\nThis model captures some key feature of David Ricardo's theory of growth and distribution as developed in his 1817 book [On the Principles of Political Economy and Taxation](https://en.wikipedia.org/wiki/On_the_Principles_of_Political_Economy_and_Taxation). The model revolves around the determination of real wages, rents, and profits, and how profitability in turn drives capital accumulation.[^a_ricardian_one_sector_model-1] It assumes a corn economy with a single good (corn) that serves both as an investment and consumption good.[^a_ricardian_one_sector_model-2] Corn production is subject to diminishing marginal returns. Real wages are driven down to a subsistence level and rent is a differential surplus landowners gain based on the fertility of their land relative to the marginal plot of land (the plot of land where fertility is lowest and no rent is earned). Profits are a residual. As employment increases and more land is utilised, marginal productivity falls and differential rents increase. As a result, profits are driven down and capital accumulation comes to a halt. A stationary state is reached. Landowners are the main beneficiaries of this process. The model is adapted from @Pasinetti1960.\n\n[^a_ricardian_one_sector_model-1]: See chapter 2 of @Foley2006 for an excellent introduction.\n\n[^a_ricardian_one_sector_model-2]: See @sec-ricardo_2 for a two-sector extension of the model.\n\n## The Model\n\nThe following equations describe the model: \n\n$$\nY_t=AN_t^a\n$$ {#eq-ricardo1_Y}\n\n$$\nW_t=K_t\n$$ {#eq-ricardo1_W}\n\n$$\nw_t =W_t/N_t\n$$ {#eq-ricardo1_w}\n\n$$\nMPL_t =\\frac{\\partial Y_t}{\\partial N_t} =aAN_t^{a-1}\n$$ {#eq-ricardo1_MPL}\n\n$$\nR_t = Y_t - N_tMPL_t \n$$ {#eq-ricardo1_R}\n\n$$\nP_t = Y_t - R_t - N_tw_t\n$$ {#eq-ricardo1_P}\n\n$$\nK_t = K_{t-1} + \\beta P_{t-1} \n$$ {#eq-ricardo1_K}\n\n$$\nN_t = N_{t-1} + \\gamma (w_{t-1} - w^S)\n$$ {#eq-ricardo1_N}\n\nwhere $Y_t$, $A$, $N_t$, $W_t$, $K_t$,$w_t$, $Y_t$, $MPL_t$, $R_t$, $P_t$, and $w^S$ are real output (measured in units of corn), productivity, employment, the real wage bill (or wage fund), the capital stock, the real wage rate, the marginal product of labour, rents, profits, and the subsistence wage, respectively.\n\n@eq-ricardo1_Y is the production function with $\\alpha \\in (0,1)$, i.e. exhibiting diminishing marginal returns to labour.[^a_ricardian_one_sector_model-3] By @eq-ricardo1_W, the wage fund is defined as the capital stock of this model (reflecting the fact that the production of corn only involves labour). @eq-ricardo1_w defines the real wage rate. @eq-ricardo1_w specifies the marginal product of labour. @eq-ricardo1_R captures the determination of (differential) rents as a negative function of the marginal product of labour.[^a_ricardian_one_sector_model-4] Thus, the lower the productivity on the marginal land, the higher the rents. In @eq-ricardo1_P, profits are determined residually. Capital accumulation in @eq-ricardo1_K is driven by the reinvestment of profits (with $\\beta$ determining the proportion of profits that are reinvested). Finally, @eq-ricardo1_N specifies population dynamics, whereby the population increases whenever the actual real wage is above the subsistence wage, echoing the Malthusian population mechanism.\n\n[^a_ricardian_one_sector_model-3]: @Pasinetti1960 specifies a generic function $f(N_t)$ with $f(0) \\geq$ 0, $f'(0) > w^*$, and $f''(N_t) < 0$. @eq-ricardo1_Y satisfies these conditions.\n\n[^a_ricardian_one_sector_model-4]: @eq-ricardo1_R is based on the definition of total rent as the sum of the net gains of the non-marginal landowners. See @Pasinetti1960 for a formal derivation.\n\n## Simulation\n\n### Parameterisation\n\nTable 1 reports the parameterisation and initial values used in the simulation. In line with the Classical tradition, it will be assumed that all profits are reinvested, i.e. $\\beta=1$. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenarios 2 and 3 model two different forms of technological change: an increase in the productivity parameter $A$ and an increase in the elasticity of output with respect to labour ($a$). Scenario 4 considers a higher subsistence wage ($w^S$). In all scenarios the population/employment is initialised below its equilibrium value.\n\n**Table 1: Parameterisation**\n\n| Scenario                           | $A$ | $a$  | $w^S$ |\n|:-----------------------------------|-----|------|-------|\n| 1: baseline                        | 2   | 0.7  | 0.5   |\n| 2: productivity boost I ($A$)      | 3   | 0.7  | 0.5   |\n| 3: productivity boost II ($a$)     | 2   | 0.75 | 0.5   |\n| 4: higher subsistence wage ($w^S$) | 2   | 0.7  | 0.7   |\n\n### Simulation code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=500\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=20\n\n# Create (S x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=S,ncol=Q) # Income/output\nR=matrix(data=1,nrow=S,ncol=Q) # Rent\nP=matrix(data=1,nrow=S,ncol=Q) # Profits\nN=matrix(data=1,nrow=S,ncol=Q) # employment\nw=matrix(data=1,nrow=S,ncol=Q) # real wage\nK=matrix(data=1,nrow=S,ncol=Q) # capital stock\nMPL=matrix(data=1,nrow=S,ncol=Q) # marginal product of labour\nW=matrix(data=1,nrow=S,ncol=Q) # wage bill\nN_eq=vector(length=S)          # equilibrium population\nK_eq=vector(length=S)          # equilibrium capital\n\n# Set baseline parameter values\nA=matrix(data=2,nrow=S,ncol=Q) # productivity\na=matrix(data=0.7,nrow=S,ncol=Q) # labour elasticity of output\nbeta=1 # Sensitivity of investment with respect to profits\ngamma=5 # adjustment speed of population\nwS=matrix(data=0.5,nrow=S,ncol=Q) # subsistence wage rate\n\n# Set parameter values for different scenarios\nA[2,s:Q]=3 # scenario 2: productivity boost I\na[3,s:Q]=0.75 # scenario 3: productivity boost II\nwS[4,s:Q]=0.6 # scenario 4: increase in subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN[,1]=1\nK[,1]=1   \nY[,1]=A[,1]*N[,1]^(a[,1])\nMPL[,1]=a[,1]*A[,1]*(N[,1]^(a[,1]-1))\nw[,1]=wS[,1]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # run the model 1000-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = A[i,t]*N[i,t]^(a[i,t])\n    \n    #(2) Wage bill\n    W[i,t] = K[i,t] \n    \n    #(3) Real wage rate\n    w[i,t] = W[i,t]/N[i,t] \n     \n    #(4) Marginal product of labour\n    MPL[i,t] = a[i,t]*A[i,t]*(N[i,t]^(a[i,t]-1))\n\n    #(5) Rents\n    R[i,t] = Y[i,t] - N[i,t]*MPL[i,t]\n    \n    #(6) Profits\n    P[i,t] = Y[i,t]- R[i,t] - N[i,t]*w[i,t]\n    \n    # (7) Capital accumulation\n    K[i,t] = K[i,t-1] + beta*P[i,t-1]\n    \n    #(8) Employment/population dynamics  \n    N[i,t] = N[i,t-1] + gamma*(w[i,t-1] - wS[i,t-1])\n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n```\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Set number of periods\nQ = 500\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 20\n\n# Create (S x Q)-matrices that will contain the simulated data\nY = np.ones((S, Q))  # Income/output\nR = np.ones((S, Q))  # Rent\nP = np.ones((S, Q))  # Profits\nN = np.ones((S, Q))  # employment\nw = np.ones((S, Q))  # real wage\nK = np.ones((S, Q))  # capital stock\nMPL = np.ones((S, Q))  # marginal product of labour\nW = np.ones((S, Q))  # wage bill\n\n# Set baseline parameter values\nA = np.ones((S, Q)) * 2  # productivity\na = np.ones((S, Q)) * 0.7  # labour elasticity of output\nbeta = 1  # Sensitivity of investment with respect to profits\ngamma = 5  # adjustment speed of population\nwS = np.ones((S, Q)) * 0.5  # subsistence wage rate\n\n# Set parameter values for different scenarios\nA[1, s:Q] = 3  # scenario 2: productivity boost I\na[2, s:Q] = 0.75  # scenario 3: productivity boost II\nwS[3, s:Q] = 0.6  # scenario 4: increase in subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN[:, 0] = 1\nK[:, 0] = 1\nY[:, 0] = A[:, 0] * N[:, 0]**(a[:, 0])\nMPL[:, 0] = a[:, 0] * A[:, 0] * (N[:, 0]**(a[:, 0] - 1))\nw[:, 0] = wS[:, 0]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for iterations in range(1000):  # run the model 1000 times in each period\n            # Model equations\n            # (1) Output\n            Y[i, t] = A[i, t] * N[i, t]**(a[i, t])\n            # (2) Wage bill\n            W[i, t] = K[i, t]\n            # (3) Real wage rate\n            w[i, t] = W[i, t] / N[i, t]\n            # (4) Marginal product of labour\n            MPL[i, t] = a[i, t] * A[i, t] * (N[i, t]**(a[i, t] - 1))\n            # (5) Rents\n            R[i, t] = Y[i, t] - N[i, t] * MPL[i, t]\n            # (6) Profits\n            P[i, t] = Y[i, t] - R[i, t] - N[i, t] * w[i, t]\n            # (7) Capital accumulation\n            K[i, t] = K[i, t - 1] + beta * P[i, t - 1]\n            # (8) Employment/population dynamics\n            N[i, t] = N[i, t - 1] + gamma * (w[i, t - 1] - wS[i, t - 1])\n```\n:::\n\n\n:::\n\n### Plots\n\nFigure 1 displays employment, capital accumulation, and income for the baseline scenario. Starting from a below-equilibrium level of population, the economy grows in terms of output, capital, and employment but then approaches what Ricardo famously called a 'stationary state'. Figure 2 shows that during the adjustment phase, the MPL declines reflecting diminishing marginal returns in the production of corn. This captures the idea that a growing economy will have to utilise less fertile lands. The real wage is initially below the MPL, allowing for profits. Over time, the MPL and actual real wage converge to the exogenously given subsistence wage. Figure 3 shows that profits initially increase but are then squeezed to zero as differential rents increase.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set start and end periods for plots\nTmax=280\nTmin =10\n\n## Baseline\n#Employment, capital accumulation, and income\nplot(N[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Employment, capital accumulation, and income\",ylab = 'N', xlab = 'Time', cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(Y[1, 2:(Tmax+1)]),cex.axis=1,cex.lab=0.75)\nlines(Y[1, Tmin:(Tmax+1)],lty=3, lwd=2)\naxis(side = 4, at = pretty(range(Y[1, 2:(Tmax+1)])))  \nmtext(\"K, Y\", side = 4, line = 2)\nlegend(\"bottomright\", legend=c(\"N\", \"K\", \"Y\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![](a_ricardian_one_sector_model_files/figure-html/ricardo1_2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Real wage, subsistence wage, and MPL\nplot(w[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(wS[1, Tmin:Tmax],w[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 2: Real wage, marginal product of labour, and subsistence wage\", xlab = 'Time',cex=0.8,line=2)\nlines(MPL[1, Tmin:Tmax],lty=2)\nlines(wS[1, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"w\", \"MPL\", \"wS\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![](a_ricardian_one_sector_model_files/figure-html/ricardo1_2-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Profits and Rents\nplot(P[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(P[1, Tmin:Tmax])) \ntitle(main=\"Figure 3: Profits and rents\", xlab = 'Time',cex=0.8,line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(R[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=2, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"P\", \n     ylim=range(R[1, 3:Tmax]), axes=FALSE) \naxis(side = 4, at = pretty(range(R[1, Tmin:(Tmax+1)])))  \nmtext(\"R\", side = 4, line = 2)\nlegend(\"right\", legend=c(\"P\", \"R\"), lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![](a_ricardian_one_sector_model_files/figure-html/ricardo1_2-3.png){width=672}\n:::\n:::\n\n\nFigure 4 displays capital accumulation under the different scenarios described in Table 1. As expected, both forms of technical change boost both the speed of capital accumulation and the equilibrium level of capital. An increase in the subsistence wage reduces the pace of capital accumulation and leads to a lower equilibrium level of capital.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Different scenarios\n# Capital accumulation\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(K[1, 2:Tmax], K[2, Tmin:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 4: Capital accumulation under different scenarios\",ylab = 'K', xlab = 'Time',cex=0.8, line=2)\nlines(K[2, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(K[3, Tmin:(Tmax+1)],lty=3, lwd=2)\nlines(K[4, Tmin:(Tmax+1)],lty=4, lwd=2)\nlegend(\"topleft\", legend=c(\"1: baseline\",\"2: product. boost I\", \"3: product. boost II\", \"4: higher subs. wage\"), lty=1:4, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![](a_ricardian_one_sector_model_files/figure-html/ricardo1_3-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n## Plots (here for employment, capital accumulation, and income only)\n\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 280\nTmin = 10\n\n# Baseline\n# Employment, capital accumulation, and income\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\n\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(K[0, 2:Tmax], linestyle='dashed', label='K', linewidth=0.8, color=\"black\")\nax2.plot(Y[0, 2:Tmax], linestyle='dotted', label='Y', linewidth=0.8, color=\"black\")\nax2.set_ylabel('Y, K', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.title(\"Figure 1: Employment, capital accumulation, and income\")\nplt.show()\n```\n:::\n\n\n:::\n\n## Directed graph\n\nAnother perspective on the model's properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node $x_1$ to node $x_2$ indicates a causal impact of $x_1$ on $x_2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 10 variables: Y W w MPL R P K N A wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\nM_mat=matrix(c(0,0,0,0,0,0,0,1,1,0,\n               0,0,0,0,0,0,1,0,0,0,\n               0,1,0,0,1,0,0,1,0,0,\n               0,0,0,0,0,0,0,1,1,0,\n               1,0,0,1,0,0,0,1,0,0,\n               1,0,1,0,1,0,0,1,0,0,\n               0,0,0,0,0,1,0,0,0,0,\n               0,0,1,0,0,0,0,0,0,1,\n               0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0), 10,10, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create and plot directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"W\", \"w\", \"MPL\", \"R\", \"P\", \"K\", \"N\", \"A\", expression(w^S))\n\n# Plot directed graph\nplot(dg, main=\"Figure 5: Directed graph of Ricardian One-Sector Model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n```\n\n::: {.cell-output-display}\n![](a_ricardian_one_sector_model_files/figure-html/ricardo1_4-2.png){width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Create directed graph\n\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 10 variables: Y W w MPL R P K N A wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\nM_mat = np.array([\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 1, 0, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n    [1, 0, 1, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: 'Y', 1: 'W', 2: 'w', 3: 'MPL', 4: 'R', 5: 'P', 6: 'K', 7: 'N', 8: 'A', 9: 'wS'}\n\n# Plot the graph\npos = nx.spring_layout(G)\nnx.draw_networkx(G, pos, node_size=500, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='->', font_size=12, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure 5: Directed graph of Ricardian One-Sector Model\")\nplt.show()\n```\n:::\n\n\n:::\n\nIn Figure 5, it can be seen that productivity ($A$) and the subsistence wage ($w^S$) are the key exogenous variables that impact income and the marginal product of labour, and population dynamics, respectively. Most other variables are endogenous and form a closed loop (or cycle) within the system. Profits are a residual. The directed graph illustrates the supply-driven nature of the model, where productivity determines employment and distribution, which in turn feed back into income and capital accumulation. At the same time, income distribution has an exogenous element in the form of the subsistence wage, which feeds into the system.\n\n## Analytical discussion {#sec-ricardo_1_analytical}\n\nTo analyse the dynamics, combine @eq-ricardo1_Y to @eq-ricardo1_P and substitute into @eq-ricardo1_K. Further use @eq-ricardo1_W and @eq-ricardo1_w in @eq-ricardo1_N. This yields the two-dimensional dynamic system in $K_t$ and $N_t$:\n\n$$\nK_t = (1-\\beta)K_{t-1}+\\beta(aA N_{t-1}^a )\n$$ $$\nN_t = N_{t-1} +\\gamma\\left(\\frac{K_{t-1}}{N_{t-1}} -w^S\\right) \n$$ The Jacobian matrix is given by: $$\nJ(K, N)=\\begin{bmatrix} 1-\\beta& \\beta a^2AN^{\\alpha-1} \\\\\\frac{\\gamma}{N} & 1-\\frac{\\gamma K}{N^2} \\end{bmatrix}.\n$$\n\nFrom equations @eq-ricardo1_K and @eq-ricardo1_N, it can readily be seen that an equilibrium is reached when $$\nP^*=0\n$$ and $$\nw^*=w^S.\n$$ Using $P^*=0$ with @eq-ricardo1_R and @eq-ricardo1_P, yields $w^*=w^S=MPL$. Thus, in equilibrium, profits are zero, and the real wage is equal to the MPL and the subsistence wage. Setting $K_t=K_{t-1}$ and $N_t=N_{t-1}$, we can further derive:\n\n$$\nK^*=aA\\left(\\frac{w^S}{aA}\\right)^{-\\frac{a}{1-a}}\n$$ and\n\n$$\nN^*=\\left(\\frac{w^S}{aA}\\right)^{-\\frac{1}{1-a}}\n$$ With this, we can evaluate the Jacobian at the steady state: $$\nJ(K^*, N^*)=\\begin{bmatrix} 1-\\beta & \\beta a w^S \\\\ \\gamma \\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}} & 1-\\gamma aA \\left(\\frac{w^S}{aA}\\right)^{\\frac{2-a}{1-a}} \n\\end{bmatrix}.\n$$ For the system to be stable, both eigenvalues of the Jacobian need to be inside the unit circle. This requires the following three conditions to hold:\n\n$$\n1+tr(J)+det(J)>0\n$$ $$\n1-tr(J)+det(J)>0\n$$ $$\n1-det(J)>0,\n$$ where $tr(J)$ is the trace and $det(J)$ is the determinant of the Jacobian.\n\nLet us consider the Classical case where $\\beta=1$, i.e. all profits are reinvested. Then we have\n\n$$\ndet(J)=-aw^S \\gamma \\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}}<0,\n$$ so that the third condition is always satisfied and it is the first one that is binding. The first condition then becomes\n\n$$\n2-\\gamma a \\left[ A \\left(\\frac{w^S}{aA}\\right)^{\\frac{2-a}{1-a}} + w^S\\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}} \\right]>0\n$$\n\nWe can check the analytical solutions and stability conditions numerically:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate equilibrium solutions\nfor (i in 1:S){\n  N_eq[i]=(wS[i,Q]/(a[i,Q]*A[i,Q]))^(-1/(1-a[i,Q]))\n  K_eq[i]=a[i,Q]*A[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^(-a[i,Q]/(1-a[i,Q]))\n}\n\n# Compare with numerical solutions (here only for baseline)\nN_eq[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30.94046\n```\n\n\n:::\n\n```{.r .cell-code}\nN[1,Q]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30.94031\n```\n\n\n:::\n\n```{.r .cell-code}\nK_eq[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.47023\n```\n\n\n:::\n\n```{.r .cell-code}\nK[1,Q]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.47018\n```\n\n\n:::\n\n```{.r .cell-code}\n### Examine model properties (here for the baseline scenario only)\n# Construct Jacobian matrix at the equilibrium \nJ=matrix(c(1-beta, beta*a[1,Q]*wS[1,Q],\n           beta*(wS[1,Q]/(a[1,Q]*A[1,Q]))^(1/(1-a[1,Q])),\n           1-gamma*a[1,Q]*A[1,Q]*(wS[1,Q]/(a[1,Q]*A[1,Q]))^((2-a[1,Q])/(1-a[1,Q]))), 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values = ev$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0.93134557 -0.01214592\n```\n\n\n:::\n\n```{.r .cell-code}\n# Obtain determinant and trace\ndet=det(J)      # determinant\ntr=sum(diag(J)) # trace\n\n#Check general stability conditions\nprint(1+tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check specific stability condition for the case beta=1\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(2-gamma*a[i,Q]*(A[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^((2-a[i,Q])/(1-a[i,Q])) \n                      + wS[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^(1/(1-a[i,Q])))>0)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Initialize arrays for equilibrium solutions\nN_eq = np.zeros(S)\nK_eq = np.zeros(S)\n\n# Calculate equilibrium solutions\nfor i in range(S):\n    N_eq[i] = (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (-1 / (1 - a[i, Q-1]))\n    K_eq[i] = a[i, Q-1] * A[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (-a[i, Q-1] / (1 - a[i, Q-1]))\n\n# Compare with numerical solutions (here only for baseline)\nN_eq[0]\nN[0,Q-1]\n\n# Construct Jacobian matrix at the equilibrium \nJ = np.array([\n    [1 - beta, beta * a[0, Q-1] * wS[0, Q-1]],\n    [beta * (wS[0, Q-1] / (a[0, Q-1] * A[0, Q-1])) ** (1 / (1 - a[0, Q-1])),\n     1 - gamma * a[0, Q-1] * A[0, Q-1] * (wS[0, Q-1] / (a[0, Q-1] * A[0, Q-1])) ** ((2 - a[0, Q-1]) / (1 - a[0, Q-1]))]\n])\n\n# Obtain eigenvalues\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\n\n# Check general stability conditions\nprint(1+tr+det>0)\nprint(1-tr+det>0)\nprint(1-det>0)\n\n# Check specific stability condition for the case beta=1\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(2 - gamma * a[i, Q-1] * (\n        A[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** ((2 - a[i, Q-1]) / (1 - a[i, Q-1])) +\n        wS[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (1 / (1 - a[i, Q-1]))\n    ) > 0)\n```\n:::\n\n\n:::\n\n## References\n",
    "supporting": [
      "a_ricardian_one_sector_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}