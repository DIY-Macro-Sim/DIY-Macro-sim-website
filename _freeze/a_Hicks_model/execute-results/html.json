{
  "hash": "6166aa1c8eca71217deb95a9759c325c",
  "result": {
    "engine": "knitr",
    "markdown": "# A Hicksian Business Cycle Model with Floors and Ceilings {#sec-hicks}\n\n## Overview\n\nThis model captures some key features of John R. @Hicks1950' nonlinear model of business cycle fluctuations. The model builds on @Samuelson1939's linear multiplier-accelerator model analysed in @sec-how-to-simulate and @sec-stab_analysis, but gives it a different twist. While @Samuelson1939's business cycle model usually requires repeated external shocks to produce sustained cycles, @Hicks1950's model produces permanent, shock-independent fluctuations that are bounded by a floor and a ceiling.^[More precisely, @Samuelson1939's model generates shock-independent cycles only for a very specific parameter combination, whereas @Hicks1950's model generates endogenous cycles for a much broader set of parameters.] The goods market equilibrium is assumed to be locally unstable due to a strong accelerator effect, i.e. investment reacts strongly to increases in aggregate output, which creates more output and boosts investment even further. However, aggregate output is constrained by a ceiling that may stem from full employment (and a fixed labour supply). On the downward trajectory, output is constrained by a floor that is given by a minimum amount of investment needed to replace the depreciated capital stock.  \n\nWe present a version of the model that is adapted from @Gabisch1989, chapter 2.1.^[Following @Hommes1995, we consider a stationary version of the model that abstracts from the growth path assumed in @Hicks1950.]\n\n## The Model\n\n$$\n  Y_{t}=\\min[C_t + I_t, Y^C] \n$$ {#eq-hicks_Y}\n\n$$\nC_{t} = c_0 + c_1 Y_{t-1},  \\quad c_1 \\in (0,1)\n$$ {#eq-hicks_C}\n\n$$\nI_{t} = I_0 + \\max[\\beta(Y_{t-1} - Y_{t-2}), -D],  \\quad \\beta > 1, D >0 \n$$ {#eq-hicks_I}\n\nwhere $Y_t$, $C_t$, $I_t$, $Y^C$, and $D$, represent output, consumption, investment, the (full employment) output ceiling, and depreciation, respectively.\n\n@eq-hicks_Y specifies aggregate income. For values below the ceiling $Y^C$, aggregate income is determined by aggregate demand (consisting only of consumption and net investment). As soon as aggregate demand hits the ceiling, aggregate income is given by the ceiling. @eq-hicks_C is a simple linear Keynesian consumption function. @eq-hicks_I is the investment function. For investment levels above depreciation $D$, net investment is given by an autonomous component $I_0$ and an accelerator component that is responsive to the change in aggregate income.^[ This differs from @Samuelson1939, who assumed that investment reacts to changes in consumption, see @sec-how-to-simulate.] The reaction coefficient $\\beta$ is assumed to be sufficiently large to generate explosive dynamics. Once the change in aggregate income has fallen below the negative of the level of depreciation $D$, net investment is given by the floor $I_0 - D$.\n\n## Simulation\n\n### Parameterisation\n\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (scenario 1), we consider a fall in the output ceiling $Y^C$ in scenario 2, an increase in the investment floor $I_0 - D$ in scenario 3, and finally a decrease in the accelerator coefficient $\\beta$ (scenario 4).\n\n**Table 1: Parameterisation**\n\n|     Scenario                                    | $c_0$ | $c_1$ | $I_0$ | $\\beta$ | $Y^C$ | $D$ |\n|-------------------------------------------------|-----|---------|-------|---------|-------|-----|\n| 1: baseline                                     | 0   | 0.75    | 10    | 1.25    | 80    | 10  | \n| 2: fall in output ceiling ($Y^C$)               | 0   | 0.75    | 10    | 1.25    | 100   | 10  |\n| 3: increase in investment floor ($I_0 - D$)     | 0   | 0.75    | 10    | 1.25    | 80    | 1   | \n| 4: decrease in accelerator coefficient ($\\beta$)| 0   | 0.75    | 10    | 0.8     | 80    | 10  | \n\n\n### Simulation code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=200\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=50\n\n# Create (S x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=S,ncol=Q) # Income/output\nC=matrix(data=1,nrow=S,ncol=Q) # Consumption\nI=matrix(data=1,nrow=S,ncol=Q) # Investment\n\n# Set fixed parameter values\nc0=0\nc1=0.75\nI0=10\n\n# Set baseline parameter values\nYc=matrix(data=80,nrow=S,ncol=Q)      # output ceiling\nD=matrix(data=10,nrow=S,ncol=Q)       # investment floor (depreciation)\nbeta=matrix(data=1.25,nrow=S,ncol=Q)  # accelerator coefficient\n\n# Set parameter values for different scenarios\nYc[2,s:Q]=100 # scenario 2: increase in output ceiling\nD[3,s:Q]=1    # scenario 3: increase in investment floor\nbeta[4,s:Q]=0.8 # scenario 4: reduction in accelerator coefficient\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:500){ # run the model 500-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = min(C[i,t]+I[i,t], Yc[i,t])\n    \n    #(2) Consumption\n    C[i,t] = c0 + c1*Y[i,t-1]\n    \n    #(3) Investment\n    I[i,t] = I0 + max(beta[i,t]*(Y[i,t-1] - Y[i,t-2]), -D[i,t]) \n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n```\n:::\n\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Set number of periods\nQ = 200\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 50\n\n# Create (S x Q)-arrays that will contain the simulated data\nY = np.ones((S, Q))  # Income/output\nC = np.ones((S, Q))  # Consumption\nI = np.ones((S, Q))  # Investment\n\n# Set fixed parameter values\nc0 = 0\nc1 = 0.75\nI0 = 10\n\n# Set baseline parameter values\nYc = np.full((S, Q), 80)      # output ceiling\nD = np.full((S, Q), 10)       # investment floor (depreciation)\nbeta = np.full((S, Q), 1.25)  # accelerator coefficient\n\n# Set parameter values for different scenarios\nYc[1, s:Q] = 100     # scenario 2: increase in output ceiling\nD[2, s:Q] = 1        # scenario 3: increase in investment floor\nbeta[3, s:Q] = 0.8   # scenario 4: reduction in accelerator coefficient\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    \n    for t in range(1, Q):\n        \n        for iterations in range(500):  # run the model 500-times in each period\n            \n            # Model equations\n            \n            # (1) Output\n            Y[i, t] = min(C[i, t] + I[i, t], Yc[i, t])\n            \n            # (2) Consumption\n            C[i, t] = c0 + c1 * Y[i, t - 1]\n            \n            # (3) Investment\n            I[i, t] = I0 + max(beta[i, t] * (Y[i, t - 1] - Y[i, t - 2]), -D[i, t])\n            \n        # Close iterations loop\n    # Close time loop\n# Close scenario loop\n```\n:::\n\n\n:::\n\n\n### Plots\n\n@fig-baseline displays the model's dynamics under the baseline scenario. The model generates cycles in aggregate output, consumption and investment that are constrained by the output ceiling $Y^C=80$ and the investment floor $I_0-D=0$. These cycles are permanent, i.e. they don't require any external shocks, and they are (roughly) periodic, with a cycle length from peak (trough) to peak (trough) of around 13.5 periods. What generates the turning points? Suppose income is on an increasing trajectory. The accelerator effect on investment will amplify this process as firms will increase their investment, which raises aggregate demand and increases income further. When the output ceiling is reached, the change in income becomes zero, and investment demand decreases relative to the boom phase. This decrease in investment lowers aggregate output, and the accelerator effect again amplifies this tendency that now plays out on a downward trajectory until net investment hits the lower bound. Once investment has stopped its downward trajectory, aggregate income stops falling as well, which allows the accelerator effect to turn positive again and thereby induce a new cycle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set start and end periods for plots\nTmax=100\nTmin =10\n\n#Income, consumption, and investment\nplot(Y[1, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[1, Tmin:Tmax],Y[1, Tmin:(Tmax)]))\ntitle(main=\"Income, consumption, and investment (baseline)\", xlab = 'Time',cex=0.8,line=2)\nlines(C[1, Tmin:Tmax],lty=2)\nlines(I[1, Tmin:Tmax],lty=3)\nlegend(\"topleft\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Income, consumption, and investment (baseline)](a_Hicks_model_files/figure-html/fig-baseline-1.png){#fig-baseline width=672}\n:::\n:::\n\n\nIn @fig-scen2, the output ceiling rises to $Y^C = 100$ in $t=50$. This raises the amplitude of the cycles. Interestingly, the ceiling is no longer binding, but the cycles still do not explode. This illustrates a feature of the model that has been noted before: it actually does not need a ceiling to generate bounded cycles (see, e.g., @Puu2005). The acceleration of income during a boom will become smaller and smaller, and eventually turn negative, thereby lowering investment and inducing a switch from boom to bust. Hence, cycles (and thus turning points) will occur even without floor and ceilings, but to prevent these cycles to become larger and larger, a floor is sufficient. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Scenario 2: increase in ceiling\nplot(Y[2, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[2, Tmin:Tmax],Y[2, Tmin:(Tmax)]))\ntitle(main=\"Scenario 2: Increase in output ceiling\", xlab = 'Time',cex=0.8,line=2)\nlines(C[2, Tmin:Tmax],lty=2)\nlines(I[2, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Increase in output ceiling](a_Hicks_model_files/figure-html/fig-scen2-1.png){#fig-scen2 width=672}\n:::\n:::\n\nAn increase in the investment floor to $I_0 - D = 9$ in period $t=50$, displayed in @fig-scen3, has the effect of reducing the amplitude of the fluctuations. Intuitively, the milder the bust, the milder the recovery.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Scenario 3: increase in investment floor\nplot(Y[3, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[3, Tmin:Tmax],Y[3, Tmin:(Tmax)]))\ntitle(main=\"Scenario 3: Increase in investment floor\", xlab = 'Time',cex=0.8,line=2)\nlines(C[3, Tmin:Tmax],lty=2)\nlines(I[3, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Increase in investment floor](a_Hicks_model_files/figure-html/fig-scen3-1.png){#fig-scen3 width=672}\n:::\n:::\n\nFinally, @fig-scen4 displays the scenario where the accelerator coefficient $\\beta$ falls, rendering investment much less sensitive to changes in aggregate income. As a result, the model's regular cycles turn into damped oscillations that eventually converge to a stable equilibrium. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Scenario 4: Reduction in accelerator coefficient\nplot(Y[4, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[4, Tmin:Tmax],Y[4, Tmin:(Tmax)]))\ntitle(main=\"Scenario 4: Reduction in accelerator coefficient\", xlab = 'Time',cex=0.8,line=2)\nlines(C[4, Tmin:Tmax],lty=2)\nlines(I[4, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Reduction in accelerator coefficient](a_Hicks_model_files/figure-html/fig-scen4-1.png){#fig-scen4 width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n### Plots (here only for baseline)\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 100\nTmin = 10\n\n# Plot income (Y), consumption (C), and investment (I)\nplt.plot(range(Tmin, Tmax), Y[0, Tmin:Tmax], label='Y', color='black', linewidth=2, linestyle='-')\nplt.title(\"Income, consumption, and investment (baseline)\", fontsize=10)\nplt.xlabel('Time')\nplt.ylabel('Y, C, I')\nplt.plot(range(Tmin, Tmax), C[0, Tmin:Tmax], label='C', linestyle='--', color='black',)\nplt.plot(range(Tmin, Tmax), I[0, Tmin:Tmax], label='I', linestyle=':', color='black',)\n\n# Add a legend to the top-left corner\nplt.legend(loc='upper left', fontsize=8, frameon=False)\n\n# Show the plot\nplt.show()\n```\n:::\n\n\n:::\n\n## Directed graph\n\nAnother perspective on the model's properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node $x_1$ to node $x_2$ indicates a causal impact of $x_1$ on $x_2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 5 variables: \n  # endogenous: (1) Y, (2) C, (3) I\n  # exogenous: (4) I0-D, (5) Yc\n\n              #Y C I I0-D Yc\nM_mat=matrix(c(0,1,1, 0,  1, # Y\n               1,0,0, 0,  0, # C\n               1,0,0, 1,  0, # I\n               0,0,0, 0,  0, # I0-D\n               0,0,0, 0,  0),# Yc\n               5, 5, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(I[0]-D), expression(Y^C))\n\n# Plot directed graph matrix\nplot(dg, main=\"Directed graph of Hicks model\", vertex.size=40, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n```\n\n::: {.cell-output-display}\n![](a_Hicks_model_files/figure-html/hicks_6-2.png){width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n### Directed graph\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 5 variables: \n# endogenous: (1) Y, (2) C, (3) I\n# exogenous: (4) I0-D, (5) Yc\n\n# Create the matrix M_mat\nM_mat = np.array([[0, 1, 1, 0, 1],  # Y\n                  [1, 0, 0, 0, 0],  # C\n                  [1, 0, 0, 1, 0],  # I\n                  [0, 0, 0, 0, 0],  # I0-D\n                  [0, 0, 0, 0, 0]]) # Yc\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat = M_mat.T\n\n# Create directed graph from adjacency matrix using networkx\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"Y\", 1: \"C\", 2: \"I\", 3: \"$I_0 - D$\", 4: \"$Y^C$\"}\n\n# Plot directed graph\npos = nx.spring_layout(G, k=0.08)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='->', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Directed Graph of Lewis Model\")\nplt.show()\n```\n:::\n\n\n:::\n\n\nIt can thus be seen that the key exogenous variables in the @Hicks1950 model are the output ceiling $Y^C$ and the investment floor $I_0 - D$, which constrain the endogenous cycle generated by the interaction between the endogenous variables income $Y$, investment $I$, and consumption $C$. \n\n## Analytical discussion\nThe dynamic properties of the @Hicks1950 model when the floor and ceiling are not binding are similar, but not entirely equivalent to the @Samuelson1939 model analysed in @sec-stab_analysis. \n\nFirst, define $X_t = Y_{t-1}$ to re-write the system as:\n\n$$\n  X_{t}=\\min[C_{t-1} + I_{t-1}, Y^C] \n$$  {#eq-hicks_X}\n\n$$\nC_{t} = c_0 + c_1 X_{t}\n$$  {#eq-hicks_C_mod}\n\n$$\nI_{t} = I_0 + \\max[\\beta(X_{t} - X_{t-1}), -D].\n$$ {#eq-hicks_I_mod}\n\nThen shift @eq-hicks_C_mod one period back and substite into @eq-hicks_X to obtain:\n\n$$\n  X_{t}=\\min [c_0 + c_1 X_{t-1} + I_{t-1}, Y^C]. \n$$  {#eq-hicks_X_mod}\n\nNext, substitute @eq-hicks_X_mod into @eq-hicks_I_mod:\n\n$$\nI_{t} = I_0 + \\max[\\beta( c_0 + (c_1 -1) X_{t-1} + I_{t-1}), -D].\n$$ {#eq-hicks_I_mod2}\n\n@eq-hicks_X_mod and @eq-hicks_I_mod2 are a two-dimensional dynamic system in $X_t$ and $It$. \n\nFor $Y_t < Y^C$ and $I_t > I_0 - D$, the system's Jacobian matrix is given by:\n\n$$\nJ=\\begin{bmatrix} c_1 & 1 \\\\ \\beta(c_1-1) & \\beta  \\end{bmatrix}.\n$$\n\nThe characteristic polynomial yielding the eigenvalues of the Jacobian is:\n\n$$\\lambda^2-\\lambda(c_1+\\beta)+\\beta=0,$$\n\nwhere $c_1+\\beta =tr(J)$ and $\\beta = det(J)$.\n\nThus, we have:\n\n$$\n\\lambda_{1,2} = \\frac{(c_1+\\beta) \\pm \\sqrt{(c_1+\\beta)^2-4\\beta}}{2},\n$$\n\nand two eigenvalues will be a pair of complex conjugates if $(c_1+\\beta)^2-4\\beta <0$ or $\\left( \\frac{c_1+\\beta}{2} \\right)^2 < \\beta$.\n\nTo assess stability, we need to check whether the modulus of the complex eigenvalue $R$ is inside the unit circle, i.e. $R \\in (-1,1)$. For a two-dimensional system with complex eigenvalues, we have $R=\\sqrt{det(J)}$. Thus, the stability condition for the Hicks model is $\\beta <1$.\n\nThe following code generates a plot that displays the condition for cycles, $\\left( \\frac{c_1+\\beta}{2} \\right)^2 < \\beta$, and the stability condition, $\\beta <1$, in the $(\\beta, c_1)$-space:^[To create the function for the cycle condition, we set $\\left( \\frac{c_1+\\beta}{2} \\right)^2 = \\beta$ and solve for $c_1$, where we only consider positive values for $c_1$ and $\\beta$.]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create function for cycle condition using beta as argument\ncyc= function (beta) {\n  2*sqrt(beta)-beta\n}\n\n# Plot the two conditions in (beta, c1)-space\ncurve(cyc, from = 0, to = 4.5, col = 1, xlab=expression(beta), ylab=expression(c[1]) , main=\"\",\n      lwd=1.5, n=10000, ylim=range(0,1.5))\nabline(v=1, col=2)\nlegend(\"topright\", legend = c(\"cycle condition\", \"stability condition\"), \n       col = c(1, 2), lwd = 2)\n```\n\n::: {.cell-output-display}\n![](a_Hicks_model_files/figure-html/hicks_7-2.png){width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Create function for cycle condition using beta as an argument\ndef cyc(beta):\n    return 2 * np.sqrt(beta) - beta\n\n# Define the range for beta \nbeta_values = np.linspace(0, 4.5, 10000)\n\n# Compute the corresponding c1 values using the cyc function\nc1_values = cyc(beta_values)\n\n# Plot the cycle condition in (beta, c1)-space\nplt.plot(beta_values, c1_values, color='black', linewidth=1.5, label='cycle condition')\n\n# Plot the stability condition as a vertical line at beta = 1\nplt.axvline(x=1, color='red', linewidth=2, label='stability condition')\n\n# Set labels and title\nplt.xlabel(r'$\\beta$', fontsize=12)\nplt.ylabel(r'$c_1$', fontsize=12)\nplt.title('')\n\n# Set y-axis limit \nplt.ylim(0, 1.5)\n\n# Add legend\nplt.legend(loc='upper right')\n\n# Show the plot\nplt.show()\n```\n:::\n\n\n:::\n\n\nThe Hicks model requires combinations of $c_1$ and $\\beta$ below the cycle condition and to the right of the stability condition to yield cycles that would be explosive without the floor.\n\nWe can also compute the eigenvalues and check the general stability conditions numerically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Stability analysis\n## Baseline\n\n# Construct Jacobian matrix \nJ_base=matrix(c(c1, 1,\n           beta[1,1]*(c1-1), beta[1,1]),\n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_base=eigen(J_base)\n(evals_base = ev_base$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1+0.5i 1-0.5i\n```\n\n\n:::\n\n```{.r .cell-code}\n# Obtain determinant and trace\n(det=det(J_base))      # determinant\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.25\n```\n\n\n:::\n\n```{.r .cell-code}\ntr=sum(diag(J_base)) # trace\n\n# Calculate modulus\n(mod_base=Mod(evals_base[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.118034\n```\n\n\n:::\n\n```{.r .cell-code}\n#Check general stability conditions\nprint(1+tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check analytical stability condition\nbeta[1,1] < 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n## Compare with scenario 4\nJ_scen4=matrix(c(c1, 1,\n           beta[4,s]*(c1-1), beta[4,s]),\n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_scen4=eigen(J_scen4)\n(evals_scen4 = ev_scen4$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.775+0.4465143i 0.775-0.4465143i\n```\n\n\n:::\n\n```{.r .cell-code}\n# Obtain determinant and trace\n(det=det(J_scen4))      # determinant\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8\n```\n\n\n:::\n\n```{.r .cell-code}\ntr=sum(diag(J_scen4)) # trace\n\n# Calculate modulus\n(mod_scen4=Mod(evals_scen4[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8944272\n```\n\n\n:::\n\n```{.r .cell-code}\n#Check general stability conditions\nprint(1+tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-tr+det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(1-det>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check analytical stability condition\nbeta[4,s] < 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nFor the baseline, the modulus of the complex eigenvalue is indeed larger than unity and the system thus unstable. This is due to the accelerator coefficient $\\beta$ being larger than unity. By contrast, in scenario 4, we have $\\beta < 1$ and the system is thus stable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Check cycle condition and compute cycle length (baseline)\n\n# Check analytical cycle condition\n(c1+beta[1,1])^2 - 4*beta[1,1] < 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Save real and imaginary part of complex eigenvalue\nre=Re(evals_base[1])\nim=Im(evals_base[1])\n\n# Calculate cycle length\nL=(2*pi)/(acos(re/mod_base))\nL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13.55164\n```\n\n\n:::\n:::\n\n\nThe analytical cycle condition confirms that the eigenvalues of the system will be complex and thus generate cycles. The implied cycle length is around 13.5 periods.\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n### Stability Analysis - Baseline\n# Construct the Jacobian matrix for the baseline scenario\nJ_base = np.array([[c1, 1],\n                   [beta[0, 0] * (c1 - 1), beta[0, 0]]])\n\n# Obtain eigenvalues\nevals_base, _ = np.linalg.eig(J_base)\nprint(\"Eigenvalues (Baseline):\", evals_base)\n\n# Obtain determinant and trace\ndet_base = np.linalg.det(J_base)  # determinant\ntr_base = np.trace(J_base)  # trace\n\n# Calculate modulus of the first eigenvalue\nmod_base = np.abs(evals_base[0])\nprint(\"Modulus (Baseline):\", mod_base)\n\n# Check general stability conditions\nprint(\"Stability conditions (Baseline):\")\nprint(1 + tr_base + det_base > 0)\nprint(1 - tr_base + det_base > 0)\nprint(1 - det_base > 0)\n\n# Check analytical stability condition\nprint(\"Analytical stability condition (Baseline):\", beta[0, 0] < 1)\n\n\n### Compare with Scenario 4\n# Construct the Jacobian matrix for scenario 4\nJ_scen4 = np.array([[c1, 1],\n                    [beta[3, s] * (c1 - 1), beta[3, s]]])\n\n# Obtain eigenvalues\nevals_scen4, _ = np.linalg.eig(J_scen4)\n\n# Print eigenvalues\nprint(\"Eigenvalues (Scenario 4):\", evals_scen4)\n\n# Obtain determinant and trace\ndet_scen4 = np.linalg.det(J_scen4)  # determinant\ntr_scen4 = np.trace(J_scen4)  # trace\n\n# Calculate modulus of the first eigenvalue\nmod_scen4 = np.abs(evals_scen4[0])\nprint(\"Modulus (Scenario 4):\", mod_scen4)\n\n# Check general stability conditions\nprint(\"Stability conditions (Scenario 4):\")\nprint(1 + tr_scen4 + det_scen4 > 0)\nprint(1 - tr_scen4 + det_scen4 > 0)\nprint(1 - det_scen4 > 0)\n\n# Check analytical stability condition\nprint(\"Analytical stability condition (Scenario 4):\", beta[3, s] < 1)\n\n### Check cycle condition (baseline)\ncycle_condition = (c1 + beta[0, 0])**2 - 4 * beta[0, 0] < 0\nprint(\"Cycle condition (Baseline):\", cycle_condition)\n\n# Save real and imaginary parts of the complex eigenvalue\nre = np.real(evals_base[0])\nim = np.imag(evals_base[0])\n\n# Calculate cycle length (L)\nL = (2 * np.pi) / np.arccos(re / mod_base)\nprint(\"Cycle length (Baseline):\", L)\n```\n:::\n\n\n:::\n\n\n## References\n\n\n",
    "supporting": [
      "a_Hicks_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}