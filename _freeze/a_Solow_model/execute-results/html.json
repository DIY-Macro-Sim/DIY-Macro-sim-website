{
  "hash": "0579d4aa5a6e981f6f8bfe648fc238f8",
  "result": {
    "engine": "knitr",
    "markdown": "# The Solow Growth Model {#sec-solow}\n\n## Overview\n\nThis section presents a version of the famous neoclassical growth model developed by @Solow1956.^[An intermediate textbook treatment of the model can be found in chapter 5 of @Garin2021. A rigorous formal analysis is presented in chapter 2 of @Acemoglu2009.] The model is based on a neoclassical aggregate production function with capital and labour as inputs that are substitutable. The production function exhibits constant returns to scale (a doubling of both inputs leads to a doubling of output), but diminishing marginal returns to its individual inputs. Unlike the Keynesian growth models analysed in @sec-kaldor-robinson and @sec-post-kaleckian, growth in the neoclassical model is supply driven. There is no independent investment function; instead it is assumed that all saving is automatically invested. In the simplest version of the model with fixed productivity, growth in output and capital is driven by exogenous population growth. The output-labour ratio only grows during the adjustment towards the steady state, but then reaches a constant value that is positively related to the saving propensity and productivity. In an augmented version with exogenous labour-saving technical progress, the output-labour ratio grows at the exogenous rate of technical change.\n\nThis section present a continuous-time version of the model with a Cobb-Douglas production function.\n\n## The Model\n\n$$\nY_{t}= A K_t^{\\alpha} L_t^{1-\\alpha},  \\quad \\alpha \\in (0,1)\n$$ {#eq-solow_Y}\n\n$$\n\\dot{K}_{t} = I_t - \\delta K_{t},  \\quad \\delta \\in (0,1)\n$$ {#eq-solow_K}\n\n$$\nS_{t} = sY_t,  \\quad s \\in (0,1)\n$$ {#eq-solow_S}\n\n$$\nI_{t} = S_t,  \n$$ {#eq-solow_I}\n\n$$\n\\dot{L}_{t} = nL_t,  \n$$ {#eq-solow_L}\n\nwhere $Y_t$, $K_t$, $S_t$, $I_t$, and $L_t$ represent aggregate output, the capital stock, saving, investment, and the labour force, respectively.\n\n@eq-solow_Y is the aggregate production function, which is of the Cobb-Douglas type. The coefficient $\\alpha$ represents the capital elasticity of output Since $\\alpha \\in (0,1)$, the production function exhibits diminishing returns to capital and labour, but constant returns to scale.  @eq-solow_K is the law of motion of the capital stock, with $\\delta$ representing the rate of depreciation. @eq-solow_S is the saving function with a constant marginal propensity to save out of income $s$. The neoclassical growth model assumes that all saving is invested (@eq-solow_I); hence there is no independent investment function. Finally, @eq-solow_L specifies exogenous labour force growth at the rate $n$.\n\n\n## Simulation\n\n### Parameterisation\n\nTable 1 reports the parameterisation used in the simulation. Beyond a baseline scenario, we will consider the effects of a rise in the propensity to save ($s$), a rise in in the capital elasticity of output ($\\alpha$), a rise in the population growth rate ($n$), and a rise in total factor productivity ($A$).\n\n**Table 1: Parameterisation**\n\n| Scenario                          | $s$ | $\\alpha$ | $n$    | $\\delta$ | $A$ |\n|----------------------------------|-----|----------|--------|----------|-----|\n| 1: baseline                       | 0.2 | 0.3      | 0.02   | 0.01     | 1   |\n| 2: rise in prop. save ($s$)       | 0.3 | 0.3      | 0.02   | 0.01     | 1   |\n| 3: rise in capital elast. ($\\alpha$) | 0.2 | 0.4      | 0.02   | 0.01     | 1   |\n| 4: rise in pop. growth ($n$)      | 0.2 | 0.3      | 0.03   | 0.01     | 1   |\n| 5: rise in productivity ($A$)     | 0.2 | 0.3      | 0.02   | 0.01     | 1.1 |\n\n\n### Simulation code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set number of periods\nQ = 5000\n\n# Set number of scenarios (including baseline)\nsc=5\n\n# Set period in which exogenous shift will occur\nq=1\n\n# Set time increment\nd=0.1\n\n#Create (S x Q) matrices in which equilibrium solutions from different parameterisations will be stored\nY=matrix(data=1, nrow=sc, ncol=Q)   # output\nK=matrix(data=1, nrow=sc, ncol=Q)   # capital\nL=matrix(data=1, nrow=sc, ncol=Q)   # labour force\nS=matrix(data=1, nrow=sc, ncol=Q)   # saving\nI=matrix(data=1, nrow=sc, ncol=Q)   # investment\n\n# Set constant parameters\ndelta=0.01   # depreciation rate\n\n# Set and initialise exogenous variables/parameters that will be shifted\ns=matrix(data=0.2, nrow=sc, ncol=Q)     # saving propensity\nA=matrix(data=1, nrow=sc, ncol=Q)       # productivity\nalpha=matrix(data=0.3, nrow=sc, ncol=Q) # elasticity of output with respect to capital\nn=matrix(data=0.02, nrow=sc, ncol=Q)    # labour force growth rate\n\n# Set parameter values for different scenarios\ns[2,q:Q]=0.3     # scenario 2: rise in saving propensity\nalpha[3,q:Q]=0.4 # scenario 3: rise in capital elasticity of output\nn[4,q:Q]=0.03    # scenario 4: rise in population growth rate\nA[5,q:Q]=1.1     # scenario 5: rise in productivity\n\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:sc){\n  \n  for (t in 2:Q){\n    \n      # Labour force growth\n      L[i,t] = L[i, t-1]*(1+n[i,t-1]*d)\n\n      # Capital stock dynamics\n      K[i,t] = K[i, t-1] + (I[i,t-1]-delta*K[i, t-1])*d\n                  \n      # Output\n      Y[i,t] =A[i,t]*(K[i,t]^(alpha[i,t]))*L[i,t]^(1-alpha[i,t]) \n      \n      # Saving \n      S[i,t] = s[i,t]*Y[i,t]\n      \n      # Investment\n      I[i,t] = S[i,t]\n      \n  }  # close time loop\n}   # close scenarios loop\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Set number of periods\nQ = 5000\n\n# Set number of scenarios (including baseline)\nsc = 5\n\n# Set period in which exogenous shift will occur\nq = 1   # Python uses 0-based indexing; we adjust below\n\n# Set time increment\nd = 0.1\n\n# Create (S x Q) matrices in which equilibrium solutions from different parameterisations will be stored\nY = np.ones((sc, Q))  # output\nK = np.ones((sc, Q))  # capital\nL = np.ones((sc, Q))  # labour force\nS = np.ones((sc, Q))  # saving\nI = np.ones((sc, Q))  # investment\n\n# Set constant parameters\ndelta = 0.01   # depreciation rate\n\n# Set and initialise exogenous variables/parameters that will be shifted\ns = np.full((sc, Q), 0.2)     # saving propensity\nA = np.full((sc, Q), 1.0)     # productivity\nalpha = np.full((sc, Q), 0.3) # elasticity of output with respect to capital\nn = np.full((sc, Q), 0.02)    # labour force growth rate\n\n# Set parameter values for different scenarios\n# (adjusting q to Python’s 0-based indexing: q:R → q-1:Python)\ns[1, q-1:Q] = 0.3         # scenario 2: rise in saving propensity\nalpha[2, q-1:Q] = 0.4     # scenario 3: rise in capital elasticity of output\nn[3, q-1:Q] = 0.03        # scenario 4: rise in population growth rate\nA[4, q-1:Q] = 1.1         # scenario 5: rise in productivity\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(sc):\n\n    for t in range(1, Q):\n\n        # Labour force growth\n        L[i, t] = L[i, t-1] * (1 + n[i, t-1] * d)\n\n        # Capital stock dynamics\n        K[i, t] = K[i, t-1] + (I[i, t-1] - delta * K[i, t-1]) * d\n\n        # Output\n        Y[i, t] = A[i, t] * (K[i, t] ** alpha[i, t]) * (L[i, t] ** (1 - alpha[i, t]))\n\n        # Saving\n        S[i, t] = s[i, t] * Y[i, t]\n\n        # Investment\n        I[i, t] = S[i, t]\n```\n:::\n\n::: \n\n### Plots\n@fig-growth plots the natural logarithm of output, the labour force, and the capital stock. In the steady state, all these variables grow at the exogenously given labour force growth rate $n$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set maximum period for plots\nTmin=5\nTmax=4000\n\n# Log output, labour force, and capital\nplot(Tmin:Tmax,log(Y)[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = '',xlab = 'Time',ylim=range(log(Y)[1:3, Tmin:Tmax]), xlim=c(0,Tmax), cex.axis=1,cex.lab=0.75)\ntitle(main=\"\",cex=0.8 ,line=2)\nlines(Tmin:Tmax,log(L)[1, Tmin:Tmax],lty=2)\nlines(Tmin:Tmax,log(K)[1, Tmin:Tmax],lty=3)\nlegend(\"bottomright\", legend=c(\"log(Y)\", \"log(L)\", \"log(K)\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Logs of output, labour force, and capital](a_Solow_model_files/figure-html/fig-growth-1.png){#fig-growth width=672}\n:::\n:::\n\n\n@fig-output-pt1 and @fig-output-pt2 display the dynamics of the output-labour ratio $y=\\frac{Y}{L}$ for the different scenarios. During the adjustment from the initialisation to the steady state, the model generates income-per-capita growth. In the steady state, where all variables grow at the same rate, ratios stabilise at finite values. Changes to any of the parameters other than $n$ will change the growth *path*, but not the growth *rate*. It can be seen that compared to the baseline, a rise in the saving propensity $s$ raises the growth path and yields a higher steady-state output-labour ratio. A similar effect occurs for a rise in the capital elasticity of output  ($\\alpha$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute output-labour ratio\ny=Y/L\n\n# Output-labour ratio, pt. 1\nplot(Tmin:Tmax,y[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'y',xlab = 'Time',ylim=range(y[1:3, Tmin:Tmax]), xlim=c(0,Tmax), cex.axis=1,cex.lab=0.75)\ntitle(main=\"\",cex=0.8 ,line=2)\nlines(Tmin:Tmax,y[2, Tmin:Tmax],lty=2)\nlines(Tmin:Tmax,y[3, Tmin:Tmax],lty=3)\nlegend(\"bottomright\", legend=c(\"1:Baseline\", \"2:Rise saving prop.\", \"3:Rise capital elasticity\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Output-labour ratio (pt. 1)](a_Solow_model_files/figure-html/fig-output-pt1-1.png){#fig-output-pt1 width=672}\n:::\n:::\n\n\nIn @fig-output-pt2 it can be seen that a rise in labour force growth rate $n$ lowers income-per-capita in the steady state, despite raising the growth rate of all variables in levels. By contrast, a rise in total factor productivity $A$ leads to higher income-per-capita.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Output-labour ratio, pt. 2\nplot(Tmin:Tmax, y[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'y',xlab = 'Time',ylim=range(y[4:5, Tmin:Tmax]), xlim=range(0:Tmax), cex.axis=1,cex.lab=0.75)\ntitle(main=\"\",cex=0.8 ,line=2)\nlines(Tmin:Tmax, y[4, Tmin:Tmax],lty=2)\nlines(Tmin:Tmax, y[5, Tmin:Tmax],lty=3)\nlegend(\"bottomright\", legend=c(\"Baseline\", \"4:Rise pop. growth\", \"5:Rise productivity\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Output-labour ratio (pt. 2)](a_Solow_model_files/figure-html/fig-output-pt2-1.png){#fig-output-pt2 width=672}\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmin = 5\nTmax = 4000\n\n# Log output, labour force, and capital\nt_range = np.arange(Tmin, Tmax + 1)\n\nplt.plot(\n    t_range,\n    np.log(Y[0, Tmin:Tmax+1]),   # scenario 1, log(Y)\n    linewidth=2,\n    linestyle='-',\n    color='black'\n)\n\nplt.title(\"\")   # main title\nplt.ylabel('')\nplt.xlabel('Time')\n\n# match R's ylim = range(log(Y)[1:3, Tmin:Tmax])\nylim_min = np.log(Y[0:3, Tmin:Tmax+1]).min()\nylim_max = np.log(Y[0:3, Tmin:Tmax+1]).max()\nplt.ylim(ylim_min, ylim_max)\n\nplt.xlim(0, Tmax)\n\n# Add lines for log(L) and log(K)\nplt.plot(t_range, np.log(L[0, Tmin:Tmax+1]), linestyle='--', color='black')\nplt.plot(t_range, np.log(K[0, Tmin:Tmax+1]), linestyle=':', color='black')\n\n# Legend\nplt.legend([\"log(Y)\", \"log(L)\", \"log(K)\"], loc=\"lower right\")\n\nplt.show()\n\n\n# compute output-labour ratio\ny = Y / L\n\n# Output-labour ratio, pt. 1\nt_range = np.arange(Tmin, Tmax + 1)\n\nplt.plot(\n    t_range,\n    y[0, Tmin:Tmax+1],        # scenario 1 (baseline)\n    linewidth=2,\n    linestyle='-',\n    color='black'\n)\n\nplt.title(\"\", fontsize=8)\nplt.ylabel('y')\nplt.xlabel('Time')\n\n# ylim = range(y[1:3, Tmin:Tmax])\nylim_min = y[0:3, Tmin:Tmax+1].min()\nylim_max = y[0:3, Tmin:Tmax+1].max()\nplt.ylim(ylim_min, ylim_max)\n\nplt.xlim(0, Tmax)\n\n# Add additional scenarios\nplt.plot(t_range, y[1, Tmin:Tmax+1], linestyle='--', color='black')  # scenario 2\nplt.plot(t_range, y[2, Tmin:Tmax+1], linestyle=':', color='black')   # scenario 3\n\nplt.legend(\n    [\"1: Baseline\", \"2: Rise saving prop.\", \"3: Rise capital elasticity\"],\n    loc=\"lower right\",\n    frameon=False\n)\n\nplt.show()\n\n\n# Output-labour ratio, pt. 2\nt_range = np.arange(Tmin, Tmax + 1)\n\nplt.plot(\n    t_range,\n    y[0, Tmin:Tmax+1],          # baseline (R's y[1,] → Python y[0,])\n    linewidth=2,\n    linestyle='-',\n    color='black'\n)\n\nplt.title(\"\", fontsize=8)\nplt.ylabel('y')\nplt.xlabel('Time')\n\n# ylim = range(y[4:5, Tmin:Tmax])  → R rows 4 & 5 → Python rows 3 & 4\nylim_min = y[3:5, Tmin:Tmax+1].min()\nylim_max = y[3:5, Tmin:Tmax+1].max()\nplt.ylim(ylim_min, ylim_max)\n\n# xlim = range(0:Tmax) in R; Python equivalent:\nplt.xlim(0, Tmax)\n\n# Additional scenarios\nplt.plot(t_range, y[3, Tmin:Tmax+1], linestyle='--', color='black')   # scenario 4 (pop. growth)\nplt.plot(t_range, y[4, Tmin:Tmax+1], linestyle=':', color='black')    # scenario 5 (productivity)\n\nplt.legend(\n    [\"Baseline\", \"4: Rise pop. growth\", \"5: Rise productivity\"],\n    loc=\"lower right\",\n    frameon=False\n)\n\nplt.show()\n```\n:::\n\n::: \n\n## Directed graph\n\nAnother perspective on the model's properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node $x_1$ to node $x_2$ indicates a causal impact of $x_1$ on $x_2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 9 variables: \n  # endogenous: (1) Y, (2) K, (3) S, (4) I, (5) L\n  # exogenous: (6) s, (7) A, (8) alpha, (9) n\n\n              #Y K S I L s A a n \nM_mat=matrix(c(0,1,0,0,1,0,1,1,0,# Y\n               0,0,0,1,0,0,0,0,0,# K\n               1,0,0,0,0,1,0,0,0,# S\n               0,0,1,0,0,0,0,0,0,# I\n               0,0,0,0,0,0,0,0,1,# L\n               0,0,0,0,0,0,0,0,0,# s\n               0,0,0,0,0,0,0,0,0,# A\n               0,0,0,0,0,0,0,0,0,# alpha\n               0,0,0,0,0,0,0,0,0# n\n               ),       \n               9, 9, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"K\", \"S\", \"I\", \"L\", \"s\", \"A\", expression(alpha), \"n\")\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=30, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n```\n\n::: {.cell-output-display}\n![Directed graph of Solow model](a_Solow_model_files/figure-html/fig-dag-4.png){#fig-dag width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport networkx as nx\n\n# -----------------------------------------------------\n# Create directed graph\n# Construct auxiliary Jacobian matrix for 9 variables:\n# endogenous: (1) Y, (2) K, (3) S, (4) I, (5) L\n# exogenous: (6) s, (7) A, (8) alpha, (9) n\n# -----------------------------------------------------\n\n# Y  K  S  I  L  s  A  a  n \nM_mat = np.array([\n    [0,1,0,0,1,0,1,1,0],  # Y\n    [0,0,0,1,0,0,0,0,0],  # K\n    [1,0,0,0,0,1,0,0,0],  # S\n    [0,0,1,0,0,0,0,0,0],  # I\n    [0,0,0,0,0,0,0,0,1],  # L\n    [0,0,0,0,0,0,0,0,0],  # s\n    [0,0,0,0,0,0,0,0,0],  # A\n    [0,0,0,0,0,0,0,0,0],  # alpha\n    [0,0,0,0,0,0,0,0,0]   # n\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat = M_mat.T\n\n# Create directed graph from adjacency matrix\ndg = nx.from_numpy_array(A_mat, create_using=nx.DiGraph)\n\n# Define node labels\nlabels = {\n    0: \"Y\",\n    1: \"K\",\n    2: \"S\",\n    3: \"I\",\n    4: \"L\",\n    5: \"s\",\n    6: \"A\",\n    7: r\"$\\alpha$\",\n    8: \"n\"\n}\n\n# Plot directed graph\nplt.figure(figsize=(7,7))\npos = nx.spring_layout(dg, seed=23)  # automatic layout\n\nnx.draw(\n    dg, pos,\n    labels=labels,\n    node_size=1200,\n    node_color=\"lightblue\",\n    edge_color=\"black\",\n    width=1.1,\n    arrowsize=15,\n    arrowstyle=\"-|>\",\n    font_size=12,\n    font_color=\"black\"\n)\n\nplt.title(\"\")\nplt.axis(\"off\")\nplt.show()\n```\n:::\n\n:::\n\n@fig-dag illustrates the critical role of labour force growth $n$ as the driver of economic growth. Higher labour input translates into higher output, a fixed portion of which is saved. Savings, in turn, drive investment, which raises the capital stock that can be used to produce more output. \n\nNext, we will consider a version with exogenous technical progress, in which $A$ becomes the main driver of growth, triggering the same feedback loop between output, saving, and investment.\n\n## Adding exogenous technical progress\nWe have seen that the neoclassical growth model with fixed total factor productivity $A$ does not generate permanent income-per-capita growth. A common extension is to let productivity grow at an exogenous rate $\\mu$:\n\n$$\n\\dot{A}=A\\mu.\n$$\nFor exogenous technical progress to yield balanced growth where output grows at a constant rate and the capital-output ratio remains constant in the steady state, it must be *labour augmenting*:^[See @Acemoglu2009, chap. 2.7, for details. Labour-augmenting technical progress is also called Harrod-neutral.] $Y_t=F(K_t, A_t L_t)$. \n\nWith a Cobb-Douglas production function, this requires:\n\n$$\nY_{t}=  K_t^{\\alpha} (A_tL_t)^{1-\\alpha},  \\quad \\alpha \\in (0,1).\n$$ {#eq-solow_y_aug}\n\nLet's simulate the model with labour-augmenting technical progress.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n#Set number of periods\nQ = 20000\n\n# Set number of scenarios (including baseline)\nsc=5\n\n# Set period in which exogenous shift will occur\nq=1\n\n# Set time increment\nd=0.01\n\n#Create (S x Q) matrices in which equilibrium solutions from different parameterisations will be stored\nY=matrix(data=1, nrow=sc, ncol=Q)   # output\nK=matrix(data=1, nrow=sc, ncol=Q)   # capital\nL=matrix(data=1, nrow=sc, ncol=Q)   # labour force\nA=matrix(data=1, nrow=sc, ncol=Q)   # total factor productivity\nS=matrix(data=1, nrow=sc, ncol=Q)  # saving\nI=matrix(data=1, nrow=sc, ncol=Q)  # investment\n\n# Set constant parameters\ndelta=0.01   # depreciation rate\n\n# Set and initialise exogenous variables/parameters that will be shifted\ns=matrix(data=0.2, nrow=sc, ncol=Q)     # saving propensity\nA=matrix(data=1, nrow=sc, ncol=Q)       # productivity\nalpha=matrix(data=0.3, nrow=sc, ncol=Q) # elasticity of output with respect to capital\nn=matrix(data=0.02, nrow=sc, ncol=Q)    # labour force growth rate\nmu=matrix(data=0.04, nrow=sc, ncol=Q)   # productivity growth rate\n\n# Set parameter values for different scenarios\ns[2,q:Q]=0.3     # scenario 2: rise in saving propensity\nalpha[3,q:Q]=0.4 # scenario 3: rise in capital elasticity of output\nn[4,q:Q]=0.03    # scenario 4: rise in population growth rate\nmu[5,q:Q]=0.06   # scenario 5: rise in productivity growth rate\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:sc){\n  \n  for (t in 2:Q){\n    \n      # Labour force growth\n      L[i,t] = L[i, t-1]*(1+n[i,t-1]*d)\n\n      # Productivity growth\n      A[i,t] = A[i,t-1]*(1+mu[i,t-1]*d)\n      \n      # Capital stock dynamics\n      K[i,t] = K[i, t-1] + (I[i,t-1]-delta*K[i, t-1])*d\n                  \n      # Output\n      Y[i,t] = (K[i,t]^alpha[i,t])*(A[i,t]*L[i,t])^(1-alpha[i,t]) \n      \n      # Saving \n      S[i,t] = s[i,t]*Y[i,t]\n      \n      # Investment\n      I[i,t] = S[i,t]\n      \n  }  # close time loop\n}   # close scenarios loop\n```\n:::\n\n\n\n\n@fig-growth-aug shows that with labour-augmenting technical progress, the output-labour ratio grows at the rate $\\mu$ (and so does the capital-output ratio), while the labour force continues to grow at $n$. Output grows at $\\mu + n$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set maximum period for plots\nTmin=5\nTmax=6000\n\n# Log output-labour, labour force, and output\nplot(Tmin:Tmax,log(Y/L)[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = '',xlab = 'Time',ylim=range(log(Y/L)[1, Tmin:Tmax], log(L)[1, Tmin:Tmax], log(K/L)[1, Tmin:Tmax]), xlim=c(0,Tmax), cex.axis=1,cex.lab=0.75)\ntitle(main=\"\",cex=0.8 ,line=2)\nlines(Tmin:Tmax,log(L)[1, Tmin:Tmax],lty=2)\nlines(Tmin:Tmax,log(Y)[1, Tmin:Tmax],lty=3)\nlegend(\"bottomright\", legend=c(\"log(Y/L)\", \"log(L)\", \"log(Y)\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Logs of output-labour ratio, labour force, and output](a_Solow_model_files/figure-html/fig-growth-aug-1.png){#fig-growth-aug width=672}\n:::\n:::\n\n\nIn the model with labour-augmenting technical progress, it is common to normalise variables by units of \"effective labour\" $A_tL_t$. The output-effective labour ratio is then defined as $y^*=\\frac{Y_t}{A_t L_t}$. @fig-output-pt3 - @fig-output-pt4 plots the dynamics of this ratio for the different scenarios, where the last scenario is now given by an increase in the productivity growth rate $\\mu$. As in the model without productivity growth, a rise in the saving propensity $s$ raises the growth path and yields a higher steady-state output-effective labour ratio. A similar effect occurs for a rise in the capital elasticity of output  ($\\alpha$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute output-labour ratio in effective labour units\ny=Y/(A*L)\n\n#  Output-effective labour ratio\nplot(Tmin:Tmax,y[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'y*',xlab = 'Time',ylim=range(y[1:3, Tmin:Tmax]), xlim=c(0,Tmax), cex.axis=1,cex.lab=0.75)\ntitle(main=\"\",cex=0.8 ,line=2)\nlines(Tmin:Tmax,y[2, Tmin:Tmax],lty=2)\nlines(Tmin:Tmax,y[3, Tmin:Tmax],lty=3)\nlegend(\"bottomright\", legend=c(\"1:Baseline\", \"2: Rise saving prop.\", \"3: Rise capital elasticity\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Output-effective labour ratio (pt. 1)](a_Solow_model_files/figure-html/fig-output-pt3-1.png){#fig-output-pt3 width=672}\n:::\n:::\n\nA rise in either the population or in the productivity growth rate reduces the steady-state output-effective labour ratio.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  Output-effective labour ratio\nplot(Tmin:Tmax, y[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'y*',xlab = 'Time',ylim=range(y[1, Tmin:Tmax], y[4:5, Tmin:Tmax]), xlim=range(0:Tmax), cex.axis=1,cex.lab=0.75)\ntitle(main=\"\",cex=0.8 ,line=2)\nlines(Tmin:Tmax, y[4, Tmin:Tmax],lty=2)\nlines(Tmin:Tmax, y[5, Tmin:Tmax],lty=3)\nlegend(\"bottomright\", legend=c(\"1: Baseline\", \"4: Rise pop. growth\", \"5:Rise prod. growth\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n```\n\n::: {.cell-output-display}\n![Output-effective labour ratio (pt. 2)](a_Solow_model_files/figure-html/fig-output-pt4-1.png){#fig-output-pt4 width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# --------------------------------------------------\n# Set number of periods\n# --------------------------------------------------\nQ = 20000\n\n# Set number of scenarios (including baseline)\nsc = 5\n\n# Set period in which exogenous shift will occur\nq = 1   # Will adjust to Python's 0-based index in slicing\n\n# Set time increment\nd = 0.01\n\n# --------------------------------------------------\n# Create (S x Q) matrices in which equilibrium solutions \n# from different parameterisations will be stored\n# --------------------------------------------------\nY = np.ones((sc, Q))   # output\nK = np.ones((sc, Q))   # capital\nL = np.ones((sc, Q))   # labour force\nA = np.ones((sc, Q))   # total factor productivity\nS = np.ones((sc, Q))   # saving\nI = np.ones((sc, Q))   # investment\n\n# --------------------------------------------------\n# Set constant parameters\n# --------------------------------------------------\ndelta = 0.01   # depreciation rate\n\n# --------------------------------------------------\n# Set and initialise exogenous variables/parameters \n# that will be shifted\n# --------------------------------------------------\ns     = np.full((sc, Q), 0.2)     # saving propensity\nA_ex  = np.full((sc, Q), 1.0)     # productivity (renamed A_ex to avoid confusion with A above)\nalpha = np.full((sc, Q), 0.3)     # elasticity of output wrt capital\nn     = np.full((sc, Q), 0.02)    # labour force growth rate\nmu    = np.full((sc, Q), 0.04)    # productivity growth rate\n\n# --------------------------------------------------\n# Set parameter values for different scenarios\n# (convert R's q:Q to Python's q-1:Q)\n# --------------------------------------------------\ns[1,     q-1:Q] = 0.3    # scenario 2: rise in saving propensity\nalpha[2, q-1:Q] = 0.4    # scenario 3: rise in capital elasticity\nn[3,     q-1:Q] = 0.03   # scenario 4: rise in population growth rate\nmu[4,    q-1:Q] = 0.06   # scenario 5: rise in productivity growth rate\n\n# --------------------------------------------------\n# Simulate the model by looping over time periods \n# for S different scenarios\n# --------------------------------------------------\nfor i in range(sc):\n\n    for t in range(1, Q):\n\n        # Labour force growth\n        L[i, t] = L[i, t-1] * (1 + n[i, t-1] * d)\n\n        # Productivity growth\n        A[i, t] = A[i, t-1] * (1 + mu[i, t-1] * d)\n\n        # Capital stock dynamics\n        K[i, t] = K[i, t-1] + (I[i, t-1] - delta * K[i, t-1]) * d\n\n        # Output\n        Y[i, t] = (K[i, t] ** alpha[i, t]) * ((A[i, t] * L[i, t]) ** (1 - alpha[i, t]))\n\n        # Saving\n        S[i, t] = s[i, t] * Y[i, t]\n\n        # Investment\n        I[i, t] = S[i, t]\n\n\n\n\n# Set maximum period for plots\nTmin = 5\nTmax = 6000\n\nt_range = np.arange(Tmin, Tmax + 1)\n\n# Compute ratios\nYL = Y / L        # Y/L\nKL = K / L        # K/L\n\n# Log output-labour, labour force, and output\nplt.plot(\n    t_range,\n    np.log(YL[0, Tmin:Tmax+1]),        # log(Y/L), baseline scenario\n    linewidth=2,\n    linestyle='-',\n    color='black'\n)\n\nplt.title(\"\", fontsize=8)\nplt.xlabel(\"Time\")\nplt.ylabel(\"\")\n\n# R equivalent:\n# ylim = range(log(Y/L)[1,...], log(L)[1,...], log(K/L)[1,...])\nylim_min = min(\n    np.log(YL[0, Tmin:Tmax+1]).min(),\n    np.log(L[0, Tmin:Tmax+1]).min(),\n    np.log(KL[0, Tmin:Tmax+1]).min()\n)\nylim_max = max(\n    np.log(YL[0, Tmin:Tmax+1]).max(),\n    np.log(L[0, Tmin:Tmax+1]).max(),\n    np.log(KL[0, Tmin:Tmax+1]).max()\n)\nplt.ylim(ylim_min, ylim_max)\n\nplt.xlim(0, Tmax)\n\n# Additional lines\nplt.plot(t_range, np.log(L[0, Tmin:Tmax+1]), linestyle='--', color='black')   # log(L)\nplt.plot(t_range, np.log(Y[0, Tmin:Tmax+1]), linestyle=':', color='black')    # log(Y)\n\n# Legend\nplt.legend(\n    [\"log(Y/L)\", \"log(L)\", \"log(Y)\"],\n    loc=\"lower right\",\n    frameon=False\n)\n\nplt.show()\n```\n:::\n\n:::\n\n## Analytical discussion\nTo study mathematically the Solow model (firstly without technical progress), it is common to reduce the model to a differential equation in the capital-labour ratio $k=\\frac{K}{L}$. Differentiating this ratio with respect to time (where $\\dot{x}=\\frac{dx}{dt}$ and $\\hat{x}=\\frac{\\dot{x}}{x}$), we have:\n\n$$\n\\dot{k}=\\frac{\\dot K}{L}-\\hat{L}k.\n$$\n\nUsing @eq-solow_K, @eq-solow_I, @eq-solow_S, @eq-solow_L, and @eq-solow_Y, and simplifying we get:\n$$\n\\dot{k}= sAk^{\\alpha}-(n+\\delta)k.\n$$ {#eq-solow_k}\n\nThis is a nonlinear differential equation called [Bernoulli differential equation](https://en.wikipedia.org/wiki/Bernoulli_differential_equation) that has the general form $\\dot{y} + ay = by^n$. A convenient feature of the Bernoulli equation is that it can easily be transformed into a linear differential equation that can then be analysed in the standard way.\n\nTo do this, re-write @eq-solow_k as follows:\n$$\n\\dot{k} +(n+\\delta)k= sAk^{\\alpha},\n$$ \nand multiply through by $k^{-\\alpha}$:\n\n$$\n\\dot{k}k^{-\\alpha} +(n+\\delta)k^{1-\\alpha}= sAk.\n$$ \nNow define $z=k^{1-\\alpha}$ with time derivative $\\dot{z}=(1-\\alpha)k^{-\\alpha}\\dot{k}$, so that $\\dot{k}= \\frac{\\dot{z}}{(1-\\alpha)k^{-\\alpha}}$. With these definitions, our equation can be written as:\n\n$$\n\\frac{\\dot{z}}{(1-\\alpha)k^{-\\alpha}}k^{-\\alpha} + (n+\\delta)z=sA,\n$$\nwhich can be simplified to:\n$$\n\\dot{z}(1-\\alpha)(n+\\delta)z=(1-\\alpha)sA,\n$$ {#eq-solow_z}\n\nwhich is now a linear differential equation in $z$.\n\nSetting $\\dot{z}=0$, we can find its steady state solution:\n$$\nz^*=\\frac{sA}{n+\\delta}.\n$$\nUsing the definition $z=k^{1-\\alpha}$, this gives us the following steady state solutions for the capital-labour ratio $k$ and the capital-output ratio $y$:\n\n$$\nk^*=\\left(\\frac{sA}{n+\\delta}\\right)^\\frac{1}{1-\\alpha},\n$$\n\n$$\ny^*=Ak^{*\\alpha}.\n$$\nUnder which conditions will the system converge to the steady state? From @eq-solow_z, we can see that if $(1-\\alpha)(n+\\delta)>0$, we have $\\frac{d\\dot{z}}{dz}<0$, so that deviations from the steady state are self-correcting, yielding stability. With diminishing returns in the production function ($\\alpha <1$), the stability condition is always satisfied.\n\nThe formal analysis of the model with exogenous technical progress is very similar. It is common to normalise variables by \"effective labour\" $A_tL_t$, so that $k=\\frac{K_t}{A_tL_t}$ and $y=\\frac{Y_t}{A_tL_t}$. Differentiation of $k$ with respect to time then yields:\n\n$$\n\\dot{k}=\\frac{\\dot K}{AL}-\\hat{L}k-\\hat{A}k.\n$$\nUsing the relevant equations as before as well as $y=\\frac{Y_t}{A_tL_t}=k^\\alpha$, this expression can be written as:\n$$\n\\dot{k}= sk^{\\alpha}-(n+\\delta+\\mu)k,\n$$\nwhich is very similar to @eq-solow_k, except for the presence of $\\mu$. The resulting steady state $k$ and $y$ are given by:\n\n$$\nk^*=\\left(\\frac{s}{n+\\delta+\\mu}\\right)^\\frac{1}{1-\\alpha},\n$$\n\n$$\ny^*=k^{*\\alpha}.\n$$\nWe can confirm these analytical results using the numerical simulation of the model with technical progress:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check analytical results (here for baseline only)\nk=K/(A*L) # construct capital-effective labour ratio\ny=Y/(A*L) # construct output-effective labour ratio\n\nk[1,Q]      # numerical solution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.479588\n```\n\n\n:::\n\n```{.r .cell-code}\n(s[1,Q]/(n[1,Q] + delta + mu[1,Q]))^(1/(1-alpha[1,Q])) # analytical solution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.48055\n```\n\n\n:::\n\n```{.r .cell-code}\ny[1,Q]   # numerical solution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.568092\n```\n\n\n:::\n\n```{.r .cell-code}\n(s[1,Q]/(n[1,Q] + delta + mu[1,Q]))^(alpha[1,Q]/(1-alpha[1,Q])) # analytical solution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.568193\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nk=K/(A*L) # construct capital-effective labour ratio\ny=Y/(A*L) # construct output-effective labour ratio\n\nk[0,Q-1]      # numerical solution\n(s[0,Q-1]/(n[0,Q-1] + delta + mu[0,Q-1]))**(1/(1-alpha[0,Q-1])) # analytical solution\n\ny[0,Q-1]   # numerical solution\n(s[0,Q-1]/(n[0,Q-1] + delta + mu[0,Q-1]))**(alpha[0,Q-1]/(1-alpha[0,Q-1])) # analytical solution\n```\n:::\n\n:::\n\n\n\nUp to a small approximation error, the solutions match. \n\nFinally, we can derive the growth rate of output, by taking the log of @eq-solow_y_aug, giving:\n\n$$\n\\ln(Y_t)=\\alpha \\ln(K_t)+(1-\\alpha)[\\ln(A_t)+\\ln(L_t)].\n$$\nDifferentiating with respect to time yields:\n$$\ng_Y = \\alpha g_K + (1- \\alpha)(g_A+g_L),\n$$\nwhere $g_Y$ is the growth rate of $Y$ and so forth.\n\nOn a balanced growth path with a constant output-capital ratio, we have $g_K=g_Y$, giving:\n$$\ng_Y = g_A + g_L = \\mu + n.\n$$\n\n## References\n\n",
    "supporting": [
      "a_Solow_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}