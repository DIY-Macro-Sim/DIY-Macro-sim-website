{
  "hash": "e82340c5467276da9251d6310aef6497",
  "result": {
    "engine": "knitr",
    "markdown": "# A Malthusian Model {#sec-malthus}\n\n## Overview\n\nThis model captures some key feature of Thomas Malthus' theory of population dynamics as developed in his 1798 book [An Essay on the Principle of Population](https://en.wikipedia.org/wiki/An_Essay_on_the_Principle_of_Population). The theory revolves around the interaction between living standards and population growth.[^a_malthusian_model-1] It assumes that birth rates increase with rising living standards, while death rates decline. Economic growth thus spurs population growth. However, due to supply constraints in agricultural production, population growth drives up food prices and thereby undermines real income, bringing population growth to a halt. The model is adapted from [Karl Whelan's lecture notes](https://karlwhelan.com/blog/?p=759).\n\n[^a_malthusian_model-1]: See chapter 2 of @Foley2006 for an excellent introduction.\n\n## The Model\n\nThe following equations describe the model:\n\n$$\nN_t = N_{t-1} + B_{t-1} - D_{t-1} \n$$ {#eq-malthus_N}\n\n$$\n\\frac{B_{t}}{N_t} = b_0 + b_1Y_t \n$$ {#eq-malthus_B}\n\n$$\n\\frac{D_{t}}{N_t} = d_0 - d_1Y_t \n$$ {#eq-malthus_D}\n\n$$\nY_t = a_0-a_1N_t \n$$ {#eq-malthus_Y}\n\nwhere $N_t$, $B_t$, $D_t$, and $Y_t$ represent population, number of births, number of deaths, and real income, respectively.\n\n@eq-malthus_N describes population dynamics as driven by births and deaths.  @eq-malthus_B and @eq-malthus_D the Malthusian hypothesis that birth rates are positively and death rates negatively related to income.  @eq-malthus_Y makes real income a negative function of the population, which captures the idea of supply constraints in agriculture.\n\n## Simulation\n\n### Parameterisation\n\nTable reports the parameterisation and initial values used in the simulation. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenario 2 models what Malthus called preventative checks: a fall in the exogenous component of the birth rate ($b_0$) due to an increased use of contraception, changes in marriage norms etc. Scenario 3 models\\`positive checks': a rise in the sensitivity of real income with respect to the population ($a_1$), capturing factors such as increased food scarcity. Scenario 4 considers a rise in the exogenous component of real income ($a_0$), which could be interpreted as a productivity boost due to the invention of better fertilisers. All scenarios initialise the population below its steady state value at $N_0=1$ and the other variables at their steady state values.\n\n**Table 1: Parameterisation**\n\n| Scenario                                 | $b_0$ | $b_1$ | $d_0$ | $d_1$ | $a_0$ | $a_1$ |\n|------------------------------------------|-------|-------|-------|-------|-------|-------|\n| 1: baseline                              | 0.5   | 0.5   | 2.5   | 0.5   | 2.5   | 0.05  |\n| 2: fall in exog birth rate ($b_0$)       | 0.4   | 0.5   | 2.5   | 0.5   | 2.5   | 0.05  |\n| 3: rise in sensitivity of income ($a_1$) | 0.5   | 0.5   | 2.5   | 0.5   | 2.5   | 0.07  |\n| 4: productivity boost ($a_0$)            | 0.5   | 0.5   | 2.5   | 0.5   | 2.6   | 0.05  |\n\n### Simulation code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nT=100\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=5\n\n# Create (S x T)-matrices that will contain the simulated data\nN=matrix(data=0,nrow=S,ncol=T) # population\nY=matrix(data=0,nrow=S,ncol=T) # real income\nB=matrix(data=0,nrow=S,ncol=T) # births\nD=matrix(data=0,nrow=S,ncol=T) # deaths\nN_eq=vector(length=S)          # equilibrium population\nY_eq=vector(length=S)          # equilibrium real income\nB_eq=vector(length=S)          # equilibrium births\nD_eq=vector(length=S)          # equilibrium deaths\n\n# Set baseline parameter values\nb0=matrix(data=0.5,nrow=S,ncol=T) # Exogenous birth rate\nb1=0.5 # Sensitivity of births with respect to real income\nd0=2.5 # Exogenous death rate\nd1=0.5 # Sensitivity of deaths with respect to real income\na0=matrix(data=2.5,nrow=S,ncol=T) # Exogenous component of real income \na1=matrix(data=0.05,nrow=S,ncol=T) #Sensitivity of the real income with respect to population\n\n# Set parameter values for different scenarios\nb0[2,s:T]=0.4  # scenario 2: reduction in birth rate\na1[3,s:T]=0.07 # scenario 3: increase in sensitivity of real income with respect to population\na0[4,s:T]=2.6  # scenario 4: improvement in productivity\n\n# Initialise \nN[,1]=1\nY[,1]=1\nB[,1]=1\nD[,1]=1\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor (i in 1:S){  \n\n  for (t in 2:T){\n \n    for (iterations in 1:1000){ # run the model 1000-times in each period \n       \n      # (1) Population dynamics    \n      N[i,t] = N[i,t-1] + B[i,t-1] - D[i,t-1]\n      \n      # (2) Births\n      B[i,t] = (b0[i,t] + b1*Y[i,t])*N[i,t]\n      \n      # (3) Deaths\n      D[i,t] = (d0 - d1*Y[i,t])*N[i,t]  \n      \n      # (4) Real income\n      Y[i,t] = a0[i,t] - a1[i,t]*N[i,t]   \n      \n    }  # close iterations loop \n  }    # close time loop\n}      # close scenario loop\n```\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Load relevant libraries\nimport numpy as np\n\n# Set number of periods\nT = 100\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 5\n\n# Create (S x T)-matrices that will contain the simulated data\nN = np.zeros((S, T))  # population\nY = np.zeros((S, T))  # real income\nB = np.zeros((S, T))  # births\nD = np.zeros((S, T))  # deaths\nN_eq = np.zeros((S))  # equilibrium population\nY_eq = np.zeros((S))  # equilibrium real income\nB_eq = np.zeros((S))  # equilibrium births\nD_eq = np.zeros((S))  # equilibrium deaths\n\n# Set baseline parameter values\nb0 = np.zeros((S, T)) + 0.5  # Exogenous birth rate\nb1 = 0.5  # Sensitivity of births with respect to real income\nd0 = 2.5  # Exogenous death rate\nd1 = 0.5  # Sensitivity of deaths with respect to real income\na0 = np.zeros((S, T)) + 2.5  # Exogenous component of real income\na1 = np.zeros((S, T)) + 0.05  # Sensitivity of the real income with respect to population\n\n# Set parameter values for different scenarios\nb0[1, s:T] = 0.4  # scenario 2: reduction in birth rate\na1[2, s:T] = 0.07  # scenario 3: increase in sensitivity of real income with respect to population\na0[3, s:T] = 2.6  # scenario 4: improvement in productivity\n\n# Initialise \nN[:,0] = 1\nY[:,0] = Y_eq[0]\nB[:,0] = B_eq[0]\nD[:,0] = D_eq[0]\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor i in range(S):  \n  for t in range(1, T):\n    for iterations in range(1000): # run the model 1000-times in each period (to make sure the order of equations doesn't matter)\n      # (1) Population dynamics    \n      N[i,t] = N[i,t-1] + B[i,t-1] - D[i,t-1]\n      # (2) Births\n      B[i,t] = (b0[i,t] + b1*Y[i,t])*N[i,t]\n      # (3) Deaths\n      D[i,t] = (d0 - d1*Y[i,t])*N[i,t]  \n      # (4) Real income\n      Y[i,t] = a0[i,t] - a1[i,t]*N[i,t]   \n```\n:::\n\n\n:::\n\n### Plots\n\nFigure 1 displays population and real income dynamics for the baseline scenario. Starting from a below-equilibrium level of population, the population initially grows rapidly (seemingly exponentially) but then approaches a steady state. During the adjustment phase, real income is driven down to its steady state level (which can be interpreted as the subsistence level). Figure 2 displays the corresponding dynamics of births and deaths.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set maximum period for plots\nTmax=20\n\n## Baseline\n#Population and real income\nplot(N[1, 2:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Population and real income, baseline\",ylab = 'N', xlab = 'Time',cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(Y[1, 2:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(Y[1, 2:20]),cex=0.8)\naxis(side = 4, at = pretty(range(Y[1, 2:Tmax])))  \nmtext(\"Y\", side = 4, line = 2)\nlegend(15, 2.3, legend=c(\"N\", \"Y\"),\n        lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.5)\n```\n\n::: {.cell-output-display}\n![](a_malthusian_model_files/figure-html/malthus2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n\n# Births and deaths\nplot(B[1, 2:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\") \ntitle(main=\"Figure 2: Births and deaths, baseline\", xlab = 'Time',cex=0.8,line=2)\nlines(D[1, 2:Tmax],lty=2)\nlegend(\"bottomright\", legend=c(\"B\", \"D\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.5)\n```\n\n::: {.cell-output-display}\n![](a_malthusian_model_files/figure-html/malthus2-2.png){width=672}\n:::\n:::\n\n\nFigure 3 displays population dynamics under the different scenarios described in Table 1. As expected, both preventative and positive checks are effective: a fall in the exogenous component of the birth rate and an increase in the sensitivity of real income slow down population dynamics and lower its steady state value. By contrast, a productivity boost allows for a higher equilibrium level of population.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Population dynamics under different scenarios\nplot(N[1, 2:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(N[4, 2:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 3: Population dynamics under different scenarios\",ylab = 'N', xlab = 'Time',cex=0.8, line=2)\nlines(N[2, 2:(Tmax+1)],lty=2, lwd=2)\nlines(N[3, 2:(Tmax+1)],lty=3, lwd=2)\nlines(N[4, 2:(Tmax+1)],lty=4, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: baseline\",\"2: fall in exog birth rate\", \"3: rise in sensitivity of income\",\n      \"4: productivity boost\"), lty=1:4, cex=0.8, bty = \"n\", y.intersp=0.5)\n```\n\n::: {.cell-output-display}\n![](a_malthusian_model_files/figure-html/malthus3-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n### Plots (here for population and real income only)\n\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmax = 20\n\n## Baseline\n# Population and real income\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(Y[0, 2:Tmax], linestyle='dashed', label='Y', linewidth=0.8, color=\"black\")\nax2.set_ylabel('Y', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.show()  \n```\n:::\n\n\n:::\n\n## Directed graph\n\nAnother perspective on the model's properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node $x_1$ to node $x_2$ indicates a causal impact of $x_1$ on $x_2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 6 variables: N, B, D, Y, b0, a0,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,1,1,0,0,0,\n              1,0,0,1,1,0,\n              1,0,0,1,0,0,\n              1,0,0,0,0,1,\n              0,0,0,0,0,0,\n              0,0,0,0,0,0), 6, 6, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"N\", \"B\", \"D\", \"Y\", expression(b[0]), expression(a[0]))\n\n# Plot directed graph matrix\nplot(dg, main=\"Figure 4: Directed graph of Malthusian model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n```\n\n::: {.cell-output-display}\n![](a_malthusian_model_files/figure-html/malthus4-2.png){width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nimport networkx as nx\n\n#Construct auxiliary Jacobian matrix for 6 variables: N, B, D, Y, b0, a0\nM_mat = np.array([[0,1,1,0,0,0],\n                  [1,0,0,1,1,0],\n                  [1,0,0,1,0,0],\n                  [1,0,0,0,0,1],\n                  [0,0,0,0,0,0],\n                  [0,0,0,0,0,0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"N\", 1: \"B\", 2: \"D\", 3: \"Y\", 4: \"$b_0$\", 5: \"$a_0$\"}\n\n# Plot the graph\npos = nx.spring_layout(G)\nnx.draw_networkx(G, pos, node_size=500, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='->', font_size=12, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure 4: Directed graph of Malthusian model\")\nplt.show()\n```\n:::\n\n\n:::\n\nIn Figure 4, it can be seen that the exogenous birth rate ($b0$) and productivity ($a0$) are exogenous variables that impact births and income, respectively. Births, deaths, employment and income are endogenous and form a closed loop (or cycle) within the system. Births and deaths affect the population size (with simultaneous feedback from population to births and deaths), and the population affects income. Income, in turn, feeds back into population size.\n\n## Analytical discussion\n\nTo find the steady state solution for $N$, substitute @eq-malthus_B - @eq-malthus_Y into @eq-malthus_N and collect terms::\n\n$$\nN_t = N_{t-1}[1+b_0-d_0+a_0(b_1+d_1)] - N_{t-1}^2 [a_1(b_1+d_1)].\n$$ {#eq-malthus_N_reduced}\n\nSubtract $N_{t-1}$ and divide through by $N_{t-1}$: $$\n\\frac{N_t - N_{t-1}}{N_{t-1}} = [b_0-d_0+a_0(b_1+d_1)] - N_{t-1} [a_1(b_1+d_1)].\n$$\n\nSet $\\frac{N_t - N_{t-1}}{N_t{t-1}}=0$ and solve for $N_{t}$ to find the non-trivial steady state:[^a_malthusian_model-2] $$\nN^* = \\frac{b_0-d_0+a_0(b_1+d_1)}{a_1(b_1+d_1)}.\n$$\n\n[^a_malthusian_model-2]: A trivial steady state is at $N^*=0$.\n\nSubstitution of $N^*$ into @eq-malthus_Y and simplifying yields: $$\nY^* = \\frac{d_0-b_0}{b_1+d_1}.\n$$\n\nFinally, to assess the dynamic stability of the model, differentiate @eq-malthus_N_reduced with respect to $N_{t-1}$: $$\n\\frac{\\partial N_t}{\\partial N_{t-1}} = 1+b_0-d_0+a_0(b_1+d_1)-2N_{t-1}[a_1(b_1+d_1)].\n$$\n\nDue to then non-linearity of the model, stability can only be assessed locally around the steady state. To do this, substitute the steady state solution and simplify: $$\n\\frac{\\partial N_t}{\\partial N_{t-1}} = 1-b_0+d_0-a_0(b_1+d_1).\n$$ From this, we can conclude that the steady state is stable iff: $$\n |1-b_0+d_0-a_0(b_1+d_1)| < 1.\n$$\n\nWe can verify these analytical solutions by comparing them with the results from the numerical solution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate analytical equilibrium solutions \nfor (i in 1:S){\nN_eq[i]=(b0[i,T]-d0+a0[i,T]*(b1+d1))/(a1[i,T]*(b1+d1))\nY_eq[i]=(d0-b0[i,T])/(b1+d1)\nB_eq[i]=(b0[i,T] + b1*Y_eq[i])*N_eq[i]\nD_eq[i]=(d0 - d1*Y_eq[i])*N_eq[i]\n}\n\n# Compare with numerical solutions (here for the example of Y, scenario1)\nY_eq[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nY[1,T]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check stability condition for all scenarios\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(abs(1-b0[i,T]+d0-a0[i,T]*(b1+d1)) < 1)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" title=\"Python code\"}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\n# Calculate analytical equilibrium solutions \nfor i in range(S):\n  N_eq[i] = (b0[i, T-1] - d0 + a0[i, T-1] * (b1 + d1)) / (a1[i, T-1] * (b1 + d1))\n  Y_eq[i] = (d0 - b0[i, T-1]) / (b1 + d1)\n  B_eq[i] = (b0[i, T-1] + b1 * Y_eq[i]) * N_eq[i]\n  D_eq[i] = (d0 - d1 * Y_eq[i]) * N_eq[i]\n  \n# Compare with numerical solutions (here for the example of Y, scenario1)\nprint(Y_eq[0])\nprint(Y[0,T-1])\n\n# Check stability condition for all scenarios\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(abs(1 - b0[i, T-1] + d0 - a0[i, T-1] * (b1 + d1)) < 1)\n```\n:::\n\n\n:::\n\n## References\n",
    "supporting": [
      "a_malthusian_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}