[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "",
    "text": "Welcome\nThis platform provides an open source code repository and online script for macroeconomic model simulation. It follows a “do-it-yourself” (DIY) approach, empowering users to numerically simulate key macroeconomic models on their own using the open-source programming languages R and Python. Whether you are a university teacher, student, researcher, or an economics enthusiast, our platform offers resources to deepen your understanding of both macroeconomic modelling and coding.\nThe platform covers an array of macroeconomic models, including canonical textbook models, models from different economic paradigms, and seminal models from the history of economic thought. It bridges a gap between intermediate and advanced level macroeconomics by providing detailed yet accessible treatments of seminal macroeconomic models. Most intermediate macroeconomics textbooks focus on graphical analysis, while advanced level materials are often more mathematical and less accessible. Our platform offers a hands-on and approachable resource for users to build both a solid foundation in modelling and macroeconomic intuition.\nThe platform’s DIY-approach aims to foster reproducibility and open-source principles in macroeconomic research and education by providing learning materials that are freely available and modifiable by everyone. The platform’s content will expand over time through new entries added by the project team.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#project-team",
    "href": "index.html#project-team",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "Project team",
    "text": "Project team\n\n\n\n\n\n\n\n\n\nFranz Prante\n\n\n\n\n\n\n\nKarsten Kohler\n\n\n\n\n\n\n\n\n\n\n\nFranz is a research associate at Chemnitz University of Technology, where he is currently working on the macroeconomic effects of monetary policy and price effects on energy demand. He is also a PhD student at Université Sorbonne Paris Nord.\n\n\nKarsten is an Associate Professor in Economics at Leeds University Business School, where he does research on the interaction between finance and the real economy, especially sources of cyclical dynamics, instability, and rising inequality.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "Contact",
    "text": "Contact\nWe welcome any feedback. If you encounter any issues, find typos or mistakes, or have questions/thoughts on the content, please do get in touch.\n\nIf you are Github user, you can report an issue in our repository\nYou can also email us directly: franz.prante@wiwi.tu.chemnitz.de and k.kohler@leeds.ac.uk",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "License",
    "text": "License\nThe material on this page is licensed under CC BY-NC 4.0, thus feel free to use the material for non-commercial purposes but please give credit.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe are grateful for helpful comments from Adam Aboobaker, Chandni Dwarkasing, Giuseppe Fontana, Alex Guschanski, Eckhard Hein, and Rafael Wildauer on various sections of this website. All errors are ours.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "how_to_use.html",
    "href": "how_to_use.html",
    "title": "1  Getting Started",
    "section": "",
    "text": "Structure of platform\nThe platform starts off with a general introduction the numerical simulation of economic models (Chapter 2). After that, it jumps right into a series of macroeconomic models. These models are grouped into static and dynamic models. In static models, time plays no role and all variables adjust instantaneously. By contrast, dynamic models characterise the adjustment of variables over time.\nThe model entries are largely self-contained and can be read independently of each other. For each model, the chapters provide three main components:\nTo further facilitate the understanding of dynamic models, Chapter 9 of the section on dynamic models begins with a general introduction into the mathematical analysis of dynamic models (this is mostly relevant for the analytical discussions of dynamic models).\nAll simulation codes are written in the open-source programming languages R and Python. R codes are presented in the main text (and images and results in the text are the output of the shown R codes), while the corresponding Python codes are available by clicking on the callout blocks underneath the R codes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#structure-of-platform",
    "href": "how_to_use.html#structure-of-platform",
    "title": "1  Getting Started",
    "section": "",
    "text": "Model descriptions that concisely explain the key ideas, assumptions, and equations of each model. This helps users grasp the underlying concepts and intuition behind the models.\n\nAnnotated code that allows users to numerically simulate the models, examine their results under different scenarios, and produce visualisations to better understand the models’ structure and output. This hands-on approach enables users to gain practical coding skills while exploring different macroeconomic theories.\n\nAnalytical discussions for users who are interested in delving deeper into the mathematical properties of the models.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#access-and-introduction-to-r-and-python",
    "href": "how_to_use.html#access-and-introduction-to-r-and-python",
    "title": "1  Getting Started",
    "section": "Access and introduction to R and Python\n",
    "text": "Access and introduction to R and Python\n\nTo be able to manipulate the codes on this platform on your own machine, you first need to download and install R and RStudio. For Python, there are different options. One of them is to download and install Spyder via the Anaconda Python distribution. Spyder provides an interface for Python (like RStudio for R). If you install it via Anaconda, it will install Python automatically.\nBesides being free, a key advantage of both R and Python is their huge and growing functionality due to new user-written libraries and packages continuously being added. In addition, a large amount of learning material is freely available on the web, e.g. here and here for R and here, and here for Python. However, to get started in can be best to directly delve into some of the codes on this platform and learn by doing. To this end, the following “cheatsheets” that provide a concise overview of key functions are useful:\n\nR Studio Cheatsheet\nBase R Cheatsheet\nmore R cheatsheets here\nPython Basics Cheatsheet\nPython for Data Science Cheatsheet\nPython Cheatsheet for NumPy library\n\nOnce you have installed R or Python, you can play with the codes on this platform yourself by copy and pasting them into the script panel of your local interface (IDE) and hitting CTRL + Enter to execute them. Don’t forget to always comment your code using the “#” symbol and to save your scripts to make sure your future self can seamlessness continue working on it.\nThe codes below covers some basic operations.1 If you are new to R or Python and keen to get started, do the following:\n\ncopy the codes below into the script panel of RStudio or Spyder on your machine\nadjust the working directory to your personal folder\nthen run the code\nmake sure you understand what it does\n\n\n################################### R Basics ###########################\n\n#In the R script you write code and comments\n  #any line starting with # is a comment and it is NOT executed\n\n## First things first: set the working directory to the the folder in which your R files are stored using: setwd(\"C:/\")\n# note that you need to separate folders by slashes /\n\n#Let's define some variables\ns = 0.05\nY = 10\n\n#We can also assign several variables the same value at once\nC = I = R = 2\n\n#For displaying them we simply call the name of the object and execute the relevant line\nY\nC\n\n#We can define new variables using existing ones\nW = Y - R\nW\n\n#R has a vast amount of built in functions, for example\nmax(10,2,100,-3)\nsqrt(9)\nabs(-13)\n\n#you can find out more about these by using the help function, e.g.:?max()\n\n#How can you delete stuff? Use the remove function rm()\n#for individual objects\nrm(Y)\n#if you want to remove everything\nrm(list=ls(all=TRUE))\n\n#You can also assign text (a string) to a variable\ntext1 = 'Reggaeton'\ntext2 = \"Bad Bunny\"\n#note \"text\" is the same as 'text' and a string can contain spaces\n#You use the paste function to combine strings\npaste(text1, text2)\n\n#R uses standard operators like +, -, *\n#for exponents use ^\n3^2\n\n\n########################### if statements and loops ######################\n\n#sometimes we need to introduce if conditions into our code\n#The syntax is\n#if condition { do something }\na = 10\nb = 13\nif (b&gt;a) {\n  print(\"b is bigger\")\n}\n#we can also tell R what to do in case the condition is not fulfilled\nb=10\nif (b&gt;a) {\n  print(\"b is bigger\")\n} else {\n  print(\"b not bigger\")\n}\n\n\n#Next we will look at loops which are a key tool to repeat tasks such as solving\n#a theoretical model again and again to find its equilibrium.\n#The basic structure is:\nfor (i in 1:5){\n  print(i)\n}\n\n#Let's use it to solve a simple Keynesian cross model of the form\n#Y=C+I\n#C=c0+c1Y\n#Define exogenous parameters\nc0=2\nc1=0.8\nI=10\n#set initial values for two endogenous variable\nY=C=1\n#Use a for loop to solve it\nC\nY\nfor (i in 1:100){\n  Y = C+I\n  C = c0+c1*Y\n}\nC\nY\n#solution is Y=(I+c0)/(1-c1)=60\n\n#What is special about this loop is that it uses the values from the previous iteration\n#to define the values of the next, because it starts with assigning a value to Y\n#and then uses that value to assign a new value to C and in the next iteration it\n#uses this new value for C to define a new value for Y etc.\n\n\n########################### Data structures ##########################\n#In most applications we produce outputs which do not consist of a single number.\n#Often we have an entire stream of results, or we want to analyse data and have to store larger amounts of data\n#R has a variety of data structures for this purpose.\n#let's clean up first\nrm(list=ls(all=TRUE))\n\n####Vectors \n#We can create an empty vector and fill it later (with results of our model for example)\nvec1 = vector(length=3)\n#we can define vectors explicitly using the c() function (c for column?)\nvec2 = c(1,2,3)\nvec3 = c(6,7,8)\n#we can also use the sequence operator\nvec4 = 1:10\n#and we can define the step size\nvec5 = seq(1,2,0.1)\nvec5\n#we can call specific entries using square brackets\nvec5[4]\n#if we want to access more elements at once\nvec5[c(4,1)]\n\n####Matrices\n#define a matrix: 3 rows and 2 columns, all elements equal to 0\nmat1 = matrix(0, nrow=3, ncol=2)\nmat1\n#we can also fill it with specific values\nmat2 = matrix(c(1,2,3,4,5,6), nrow = 3, ncol = 2)\nmat2\n#access specific elements (columns,rows)\nmat2[3,1]\n#access entire rows or columns\nmat2[,1]\nmat2[1,]\n#access sub matrices\nmat2[c(1,2),]\n## Combine two column vectors in a matrix\nmat3=cbind(vec1, vec2)\nmat3\n## Combine two row vectors in a matrix\nmat4=rbind(vec1, vec2)\nmat4\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\n################################### Python Basics ###########################\n\n#In the Python script you write code and comments\n#any line starting with # is a comment and it is NOT executed\n\n## First things first: set the working directory to the the folder \n# in which your Python files are stored using: \n# import os\n# os.setcwd(\"C:/yourworkingdirectory\")\n# note that you need to separate folders by slashes /\n\n# Most of what we will do relies on the library NumPy\n# Let's load NumPy and call its commands by the prefix .np\n\n# Load relevant libraries\nimport numpy as np \n\n#Let's define some variables\ns = 0.05\nY = 10\n\n#We can also assign several variables the same value at once\nC = I = R = 2\n\n#For displaying them we simply call the name of the object and \n# execute the relevant line\nY\nC\n\n#We can define new variables using existing ones\nW = Y - R\nW\n\n#Python/Numpy has a vast amount of built in functions, for example\nmax(10, 2, 100, -3)\nnp.sqrt(9)\nabs(-13)\n\n#you can find out more about these by using the help function, \n#e.g.: help(max)\n\n#How can you delete stuff? Use the del function\n#for individual objects\ndel Y, C, I, R\n\n#You can also assign text (a string) to a variable\ntext1 = 'Reggaeton'\ntext2 = \"Bad Bunny\"\nprint(text1 + ' ' + text2)\n\n#Python uses standard operators like +, -, *\n#for exponents use **\n3**2\n\n########################### if statements and loops ######################\n\n#sometimes we need to introduce if conditions into our code\n#The syntax is\n#if condition xxx:\n    #do something    \na = 10\nb = 13\nif b &gt; a:\n    print(\"b is bigger\")\n    \n#we can also define what to do in case the condition is not fulfilled\nb = 10\nif b &gt; a:\n    print(\"b is bigger\")\nelse:\n    print(\"b not bigger\")\n\n#Next we will look at loops which are a key tool to repeat tasks such as solving\n#a theoretical model to find its equilibrium.\n#The basic structure is:\nfor i in range(1, 6):\n    print(i)\n# Note the key role played by indentation!\n\n#Let's use it to solve a simple Keynesian cross model of the form\n#Y=C+I\n#C=c0+c1Y\n\n#Define exogenous parameters and initialise endogenous variables\nc0 = 2\nc1 = 0.8\nI = 10\nY = C = 1\n\n#Use a for loop that iterates the equations 100 times to solve them\nfor i in range(1, 100):\n    Y = C + I\n    C = c0 + c1 * Y\n\nY\n#correct solution is Y=(I+c0)/(1-c1)=60\n\n#The loop uses the values from the previous iteration\n#to calculate the values of the next, because it starts with assigning a value \n#to Y and then uses that value to assign a new value to C, and in the next\n# iteration it uses this new value for C to define a new value for Y etc.\n\n\n########################### Data structures ##########################\n#In most applications we produce outputs which do not consist of a single number.\n#Often we have an entire stream of results, or we want to analyse data and have \n# to store larger amounts of data. \n# Python/Numpy has a variety of data structures for this purpose.\n\n\n### Vectors\n#We can create an vector of size 3 with only zeros and fill it later \n# (with results of our model for example). Importantly, unlike R, Python starts\n# counting the elements in vector at 0 rather than 1\nvec1 = np.zeros((3)) \n#we can define vectors explicitly \nvec2 = np.array([1, 2, 3])\nvec3 = np.array([6, 7, 8])\n#we can also use the sequence operator\nvec4 = np.arange(1, 11)\n#and we can define the step size\nvec5 = np.arange(1, 2, 0.1)\n#we can call specific entries using square brackets -- note how Python starts \n# counting at 0\nvec2[2]\n#if we want to access more elements at once\nvec2[0:3]\n\n### Matrices\n#define a matrix: 3 rows and 2 columns, all elements equal to 0\nmat1 = np.zeros((3, 2))\n#we can also fill it with specific values\nmat2 = np.array([[1, 2], [3, 4], [5, 6]])\n\n#access specific elements (columns,rows)\nmat2[2, 0]\n#access entire rows or columns\nmat2[:, 0]\n\n## Combine two column vectors in a matrix\nmat3 = np.column_stack((vec1, vec2))\n## Combine two row vectors in a matrix\nmat4 = np.row_stack((vec1, vec2))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#simple-exercise",
    "href": "how_to_use.html#simple-exercise",
    "title": "1  Getting Started",
    "section": "Simple exercise",
    "text": "Simple exercise\nIf you further want to practice your coding skills, attempt the following exercises:\n\nWrite a loop which calculates the running sum of \\(x_i=\\frac{1}{i^2}\\) by saving each element \\(\\sum_{i=1}^{j}x_i\\) in a vector (where \\(j=1,2,..,10\\)).\n\nIf your code is correct, you should get the solution:\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n [1] 1.000000 1.250000 1.361111 1.423611 1.463611 1.491389 1.511797 1.527422\n [9] 1.539768 1.549768\n\n\n\n\n\n\nWrite a loop which calculates the running sums of \\(x_i=\\frac{1}{i^2}\\) (as in exercise 1) and in addition also \\(y_i=\\frac{1}{i^3}\\). Combine the results in a matrix.\n\nIf your code is correct, you should get the solution:\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n             x        y\n [1,] 1.000000 1.000000\n [2,] 1.250000 1.125000\n [3,] 1.361111 1.162037\n [4,] 1.423611 1.177662\n [5,] 1.463611 1.185662\n [6,] 1.491389 1.190292\n [7,] 1.511797 1.193207\n [8,] 1.527422 1.195160\n [9,] 1.539768 1.196532\n[10,] 1.549768 1.197532",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#footnotes",
    "href": "how_to_use.html#footnotes",
    "title": "1  Getting Started",
    "section": "",
    "text": "We are grateful to Rafael Wildauer for permission to reproduce a slightly modified version of his learning materials. In addition, some of the material below is taken from here.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html",
    "href": "how_to_simulate.html",
    "title": "2  How to Simulate Economic Models",
    "section": "",
    "text": "Introduction: economic models\nWhy do we build formal economic models? Because they help us think carefully about the causal mechanisms that generate certain economic outcomes (e.g. unemployment). Models are especially useful when the variables of interest are inherently quantitative (e.g. the interest rate and unemployment) and when several of these quantitative variables interact with each other. More specifically, models provide a precise formal representation of a set of interlinked causal mechanisms that are often difficult to analyse informally.\nEvery economic model essentially consist of three things:\nThe solution to the model, its ‘equilibrium’, will pin down values for the endogenous variables of the model for a given set of parameters and exogenous variables. Thus, the endogenous variables, e.g. unemployment, are determined within the system, while exogenous variables are determined outside of the system and often reflect policy variables, such as the central bank interest rate. The equations connect the variables of the system. They typically express:\nEquations may be linear or nonlinear. If a model contains nonlinear relationships between the endogenous variables, it may admit more than one solution (often called multiple equilibria).\nEconomic models can be either static or dynamic. In a static model, time plays no role and all endogenous variables are determined simultaneously. In a dynamic model, time matters and the endogenous variables adjust gradually over time.\nThe endogenous variables are typically interrelated: e.g. \\(x\\) determines \\(y\\), but \\(y\\) also determines \\(x\\). These interrelationships can be:\nUnlike static models, dynamic models describe what happens out of equilibrium.1 Note that dynamic models may contain both simultaneous and recursive relationships.\nWhether the relationships between the variables is simultaneous or recursive has implications for how the model can be solved. In general, simple economic models can often be solved analytically without a computer. If the model contains simultaneous relationships, it needs to be solved as a simultaneous system by solving for the endogenous variables through repeated substitution. This means going from the so-called ‘structural form’, i.e. the full set of equations, to the so-called ‘reduced form’, where the right-hand side of the equations only contains exogenous variables and parameters. If the system is linear, techniques from linear algebra such as matrix inversion or Cramer’s rule can be used (see Chiang and Wainwright (2005), chaps. 4-5). If the system contains recursive relationships, the equilibrium solution can be found by setting \\(x_{t+i}=x_{t-i}=x_{t}\\) for all \\(x\\) and then solving the resulting simultaneous system (more on this Chapter 9).\nHowever, often a complete analytical solution is difficult to come by. Common challenges are:\nIn these cases, numerical solution by means of computer simulation becomes useful. A key advantage is that it allows you to study much more complex models than the analytical approach does. A key disadvantage is that numerical solution requires the choice of a (possibly arbitrary) set of numerical values for the models’ parameters. It is thus less general than analytical solution – a limitation which should be borne in mind. We think that both analytical and numerical approaches are useful. Correspondingly, we supplement the numerical simulations with analytical model solutions where possible.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#introduction-economic-models",
    "href": "how_to_simulate.html#introduction-economic-models",
    "title": "2  How to Simulate Economic Models",
    "section": "",
    "text": "a set of \\(N\\) equations\na set of \\(N\\) endogenous variables\na set of exogenous or fixed coefficients (‘parameters’) and exogenous variables\n\n\n\neconomic (accounting) identities (e.g. that in a closed economy without government, saving is income that is not consumed: \\(S=Y-C\\))\nbudget constraints (e.g. that business investment can be financed out of retained profits and new debt, \\(I=\\Pi+\\Delta D\\))\nbehavioural functions (e.g. that households consume a constant proportion of their income, \\(C=c_1Y\\)), which often contain key parameters of the model (e.g. the marginal propensity to consume \\(c_1\\))\nequilibrium conditions (e.g. that demand must be equal to supply)\n\n\n\n\n\nsimultaneous: \\(x\\) and \\(y\\) determine each other simultaneously (within the same period)\nrecursive: \\(x\\) affects \\(y\\) only in \\(t+1\\) (or vice versa)\n\n\n\n\n\na model has more than 3 dimensions (\\(N&gt;3\\)): then it’s very tedious to compute analytical solutions\na model has nonlinearities that preclude the computation of analytical solutions\na model is dynamic and you want to examine the dynamic adjustment of the endogenous variables (which is tedious to do analytically)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#solving-economic-models-numerically",
    "href": "how_to_simulate.html#solving-economic-models-numerically",
    "title": "2  How to Simulate Economic Models",
    "section": "Solving economic models numerically",
    "text": "Solving economic models numerically\nIf a (dynamic) model exclusively contains recursive relationships, it can be solved iteratively by sequentially updating the endogenous variables from (arbitrarily set) initial conditions. This is easy to do with a computer. By contrast, if interrelationships are simultaneous, solving the system for the endogenous variables as described above is less trivial for a computer (finding the solution for \\(x\\) requires the solution of \\(y\\), but the latter requires in turn the solution for \\(x\\)). One approach is to use linear algebra: cast the system in matrix form (\\(b=Ax\\)) and let the computer find \\(x^*=A^{-1}b\\) through some algorithm (e.g. the Gauss-Seidel method).\nWe will use an approach that is simpler and based on iteration:\n\nchoose a set of numerical parameter values (e.g. \\(c_1=0.8\\))\nchoose (arbitrary but non-zero) initial values for the endogenous variables (e.g. \\(C_0=1)\\)\nthen solve the system of equations many times using a for loop\n\nIn this way, the solution gets approximated successively.\nA limitation of the method of iteration is that it will only converge to the solution of the simultaneous component of a model if the equilibrium is stable (more on stability in Chapter 9). For most static models, stability is required for the model to be economically meaningful. In that sense, if the iterative approach does not yield a solution, this is a sign that the model and/or parameterisation needs to be reconsidered. In dynamic models, stability is a key question that should be addressed in any case. Therefore, this limitation of the method of iteration may not be too restrictive in practice.\nSolving economic models numerically: examples\nA static model\nConsider a two-dimensional simultaneous system represented by a simple Keynesian goods market model:\n\\[\nY= C + I_0\n\\] \\[\nC = c_0 + c_1Y\n\\] In a closed economy without government, aggregate demand is composed of consumption \\(C\\) and investment \\(I\\), with the latter assumed to be exogenous. Goods market equilibrium requires aggregate demand to be equal to aggregate income \\(Y\\). Consumption is assumed to be determined by an autonomous component \\(c_0\\) and a marginal propensity to consume out of income \\(c_1\\).\nSuppose the parameters are given by \\(c_0=3\\) and \\(c_1=0.8\\). You are interested in how a change in investment from \\(I_0=5\\) to \\(I_0=6\\) affects the solution of the system. Through the method of substitution, we can easily derive that \\(Y^*=\\frac{c_0+I_0}{1-c_1}\\). The code below shows how to find this solution via simulation.\n\n### Simulate Keynesian goods market model via iteration\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of parameterisations that will be considered\nS=2\n\n# Set fixed parameter values\nc0=3\nc1=0.8\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_eq=vector(length=S)\nC_eq=vector(length=S)\n\n#Create vector with parameter that will change \nI0=vector(length=S)\nI0[1]=5\nI0[2]=6\n\n# Initialise endogenous variables at arbitrary positive value \nY=C=1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  for (iteration in 1:1000){\n  Y = C + I0[i]\n  C = c0 + c1*Y\n  } # close iterations loop\n  \n#Save results for different parameterisations in vector\nY_eq[i]=Y\nC_eq[i]=C\n} # close parameterisations loop\n\n# Display solutions\nY_eq\n\n[1] 40 45\n\nC_eq\n\n[1] 35 39\n\n# Verify solutions for Y\n(c0+I0[])/(1-c1)\n\n[1] 40 45\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Simulate Keynesian goods market model via iteration\n\n# Load NumPy library\nimport numpy as np\n\n# Set the number of parameterisations that will be considered\nS = 2\n\n# Set fixed parameter values\nc0 = 3\nc1 = 0.8\n\n# Create numpy arrays in which equilibrium solutions from different parameterisations will be stored\nY_eq = np.zeros(S)\nC_eq = np.zeros(S)\n\n# Create a numpy array with the parameter that will change\nI0 = np.zeros(S)\nI0[0] = 5\nI0[1] = 6\n\n# Initialize endogenous variables at an arbitrary positive value\nY = C = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iteration in range(1000):\n        Y = C + I0[i]\n        C = c0 + c1 * Y\n\n    # Save results for different parameterisations in the numpy arrays\n    Y_eq[i] = Y\n    C_eq[i] = C\n\n# Display solutions\nY_eq\nC_eq\n\n# Verify solutions for Y\n(c0+I0)/(1-c1)\n\n\n\n\nLet’s break this code down a little bit:\n\nset the number of scenarios \\(S\\), define parameter values, and create vectors of length \\(S\\) in which the results for the endogenous variables will be stored\ndefine changes in exogenous variables or parameters (i.e. construct different scenarios)\ninitialise the endogenous variables\nwrite down the equations (solved for the endogenous variables such that every endogenous variable of the system appears on the left-hand side of an equation exactly once)\n\nplace these equations inside a for loop\n\nthe loop says: repeat the segment of code insights the curly brackets 1000 times\n\n\nnest the loop that solves the system in an outer loop that loops through different parameterisations (here for \\(I_0\\))\nafter the iterations loop is finished, save the results for the current pameterisation\n\nWhat happens is the following: in the first iteration, \\(Y\\) and \\(C\\) are calculated based on the initial values and the parameter values. In the second iteration, the values are then overwritten based on the results from the first iteration. This process continues 1000 times. In this way, the correct solution is successively approximated. If you have an analytical solution, you can compare it with the numerical one to double-check your results.\nWhen does the method of iteration fail to provide a solution? In the following code, everything is the same with the only difference that the marginal propensity to consume is now larger than unity (\\(c_1=1.2\\)). Now the numerical simulation fails to find the solution. This is because with \\(c_1&gt;0\\), the so-called Keynesian equilibrium condition is violated and the system happens to be unstable. We will discuss in Chapter 9 the issue of stability and how to analyse it formally. At this point, we simply note that the method of iterations requires static models to be stable to yield equilibrium solutions.\n\n### Parameterisation for which method of iteration fails\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of parameterisations that will be considered\nS=2\n\n# Set fixed parameter values\nc0=3\nc1=1.2\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_eq=vector(length=S)\nC_eq=vector(length=S)\n\n#Create vector with parameter that will change \nI0=vector(length=S)\nI0[1]=5\nI0[2]=6\n\n# Initialise endogenous variables at arbitrary positive value \nY=C=1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  for (iteration in 1:1000){\n  Y = C + I0[i]\n  C = c0 + c1*Y\n  } # close iterations loop\n  \n#Save results for different parameterisations in vector\nY_eq[i]=Y\nC_eq[i]=C\n} # close parameterisations loop\n\n# Display solutions\nY_eq\n\n[1]  5.818655e+80 8.832196e+159\n\n# Verify solutions for Y\n(c0+I0[])/(1-c1)\n\n[1] -40 -45\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Parameterisation for which method of iteration fails\nc1 = 1.2  \n\n# Initialize endogenous variables at an arbitrary positive value\nY = C = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iteration in range(1000):\n        Y = C + I0[i]\n        C = c0 + c1 * Y\n\n    # Save results for different parameterisations in the numpy arrays\n    Y_eq[i] = Y\n    C_eq[i] = C\n\n# Display solutions for Y_eq\nY_eq\n\n# Verify solutions for Y\n(c0+I0)/(1-c1)\n\n\n\n\nA dynamic model (in discrete time)\nConsider now a dynamic version of the Keynesian goods market model that was proposed by Paul Samuelson (1939). In this model, investment (\\(I\\)) becomes endogenous and reacts to the change in consumption. Aggregate demand now also contains government spending (\\(G\\)), which is assumed to be exogenous. Consumption (\\(C\\)) responds to changes in income (\\(Y\\)) with a lag:\n\\[\nY_t = C_t + I_t + G_0\n\\] \\[\nI_t = \\beta(C_t - C_{t-1})\n\\] \\[\nC_t=c_1Y_{t-1}.\n\\] This is a dynamic model, in which the endogenous variables adjust gradually over time. However, the model is not purely recursive as investment reacts to consumption in the same period (and output to consumption and investment). By shifting \\(Y_t=C_t + I_t + G_0\\) one period back, substitution into the consumption, and then investment function, the system can be reduced to two equations that are fully recursive:\n\\[\nC_t= c_1(C_{t-1} + I_{t-1} + G_0)\n\\] \\[\nI_t= \\beta[c_1(C_{t-1} + I_{t-1} + G_0) - C_{t-1}]\n\\] We can find the solution for output analytically by setting \\(x_t=x_{t-1}\\) for all variables and then applying the method of substitution. This yields \\(Y^*=\\frac{G_0}{1-c_1}\\). The code below shows how to find this solution through simulation.\n\n### Simulate Samuelson 1939\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of periods for which you want to simulate\nQ=100\n\n# Set number of parameterisations that will be considered\nS=2\n\n# Set period in which shock or shift in an will occur\ns=15\n\n# Set fixed parameter values\nc1=0.8\nbeta=0.6\n\n# Construct (S x Q) matrices in which values for different periods will be stored; initialise at 1\nC=matrix(data=1, nrow=S, ncol=Q)\nI=matrix(data=1, nrow=S, ncol=Q)\n\n#Construct matrices for exogenous variable or parameter that will change over time to capture different scenarios\nG0=matrix(data=5, nrow=S, ncol=Q)\n\n# Set parameter values for different scenarios\nG0[2,s:Q]=6     # scenario: permanent increase in government spending from I0=5 to I0=6 from period s=15 onwards\n\n#Solve this system recursively based on the initialisation\nfor (i in 1:S){\n  for (t in 2:Q){\n    C[i,t] = c1*(C[i,t-1] + I[i,t-1] + G0[i,t])\n    I[i,t] = beta*(c1*(C[i,t-1] + I[i,t-1] + G0[i,t]) - C[i,t-1])\n  } # close time loop\n}   # close scenarios loop\n\n# Calculate output\nY=C+G0+I\n\n# Display solution\nY[,Q]\n\n[1] 25 30\n\n# Verify solutions for Y\n(G0[,Q])/(1-c1)\n\n[1] 25 30\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Simulate Samuelson 1939\n\n# Set the number of periods for which you want to simulate\nQ = 100\n\n# Set the number of parameterisations that will be considered\nS = 2\n\n# Set the period in which a shock or shift in 'an' will occur\ns = 15\n\n# Set fixed parameter values\nc1 = 0.8\nbeta = 0.6\n\n# Construct (S x Q) matrices in which values for different periods will be stored; initialize at 1\nC = np.ones((S, Q))\nI = np.ones((S, Q))\n\n# Construct matrices for exogenous variables or parameters that will change \n# over time to capture different scenarios, initialise at 5\nG0 = np.ones((S, Q))*5 \n\n# Set parameter values for different scenarios\nG0[1, s:Q] = 6  # scenario: permanent increase in government spending from I0=5 to I0=6 from period s=15 onwards\n\n# Solve this system recursively based on the initialization\nfor i in range(S):\n    for t in range(1, Q):\n        C[i, t] = c1 * (C[i, t - 1] + I[i, t - 1] + G0[i, t])\n        I[i, t] = beta * (c1 * (C[i, t - 1] + I[i, t - 1] + G0[i, t]) - \n                          C[i, t - 1])\n\n# Calculate output\nY = C + G0 + I\n\n# Display the solutions at time Q\nY[:, Q - 1]\n\n# Verify solutions for Y\n(G0[:,Q - 1])/(1-c1)\n\n\n\n\nThe code solves the recursive system numerically through iteration. Let’s again break down what the code does:\n\nset the number of periods for which we want to simulate the model (here \\(Q=100\\)), set the number of scenarios \\(S\\) and the period \\(s\\) in which a change in the scenario should occur\nset the parameter values and create \\((S \\times Q)\\) matrices in which the results for the endogenous variables will be stored, such that the columns represent time and the rows represent different scenarios; initialise the endogenous variables\ndefine changes in exogenous variables or parameters (i.e. construct different scenarios)\nwrite down the equations (solved for the endogenous variables such that every endogenous variable of the system appears on the left-hand side of an equation exactly once)\n\nplace these equations inside a for loop that runs from \\(t=2\\) to \\(Q\\)\n\nthe loop says: repeat the segment of code insights the curly brackets, each time with the index number \\(t\\) shifted by \\(+1\\) until \\(t=Q\\)\n\n\n\nnest the loop that solves the system in an outer loop that loops through different parameterisations (here for \\(G_0\\))\n\nNote that due to the exclusive presence of recursive equations, no loop is need that iterates the equations within every period. However, many dynamic models contain both simultaneous and recursive equations. In this case, a third loop inside the time loop is needed that iterates the equations within each period so as to solve the simultaneous equations. Otherwise, the approach to solving dynamic systems is not fundamentally different from the one for static systems.\nAt the end of the simulation run, we can again compare the results from the numerical simulation with the analytical solution. However, what is perhaps more interesting is to trace the dynamic adjustment of the endogenous variables towards equilibrium. The best way to examine this is by plotting the results.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#how-to-plot-the-results-of-a-model",
    "href": "how_to_simulate.html#how-to-plot-the-results-of-a-model",
    "title": "2  How to Simulate Economic Models",
    "section": "How to plot the results of a model",
    "text": "How to plot the results of a model\nWe will consider two main ways to plot model outputs: bar charts for static models and time series charts for dynamic models. Bar charts compare the equilibrium values of \\(Y_t\\) for different parameterisations:\n\n# Bar chart of different equilibrium solutions of Samuelson (1939) model\nbarplot(Y[,Q], ylab=\"Y\", main=\"Output\", names.arg=c(\"Baseline\", \"Increase in G0\"))\n\n\n\n\n\n\n\nNext, we show a basic version of a time series chart that displays the dynamics of \\(Y_t\\):\n\n# Time series chart of output dynamics in Samuelson (1939) model\nplot(Y[1, 1:100],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Output\", cex=0.8)\n\n\n\n\n\n\n\nAs you can see, there are many settings you can fiddle around with to adjust the appearance of the graph to your liking (run ‘?plot’ to find information about the different options.) If we want to plot the dynamics for the two different parameterisations, we can do the following:\n\n# Time series chart of output dynamics for different scenarios in Samuelson (1939) model\nplot(Y[1, 1:100],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\", ylim=range(min(Y[1,], Y[2,]), max(Y[1,], Y[2,]))) \ntitle(main=\"Output under different scenarios\", cex=0.8)\nlines(Y[2, 1:100],lty=2)\nlegend(\"bottomright\", legend=c(\"Baseline\", \"Increase in G0\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nNote that we have adjusted the range of the y-axis to make sure the graph captures the minimum and maximum values from both parameterisations.\nFinally, consider a plot for \\(C_t\\) and \\(I_t\\) with two separate axes:\n\n# Time series chart of Samuelson (1939) model with separate axes for consumption and investment\nplot(C[1, 1:100], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Consumption and Investment\", cex=0.8)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(I[1, 1:100], type=\"l\", col=1, lwd=2, lty=2, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(I[1, 1:100]), cex=0.8)\naxis(side = 4, at=pretty(range(I[1, 1:100])))  \nmtext(\"I\", side = 4, line = 3)\nlegend(\"right\", legend=c(\"C\", \"I\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#### Plots\n\n# Load matplot library\nimport matplotlib.pyplot as plt\n\n# Bar chart of different equilibrium solutions of Samuelson (1939) model\nscenario_labels = [\"Baseline\", \"Increase in G0\"]\nplt.bar(scenario_labels, Y[:, Q - 1])\nplt.xlabel(\"Scenario\")\nplt.ylabel(\"Y\")\nplt.title(\"Output\")\nplt.show()\n\n# Time series chart of output dynamics in Samuelson (1939) model\nplt.plot(range(1, Q), Y[0, 0:Q - 1], color='black', linewidth=2, linestyle='-')\nplt.xlabel(\"Time\")\nplt.ylabel(\"Y\")\nplt.title(\"Output\", fontsize=10)\nplt.show()\n\n# Time series chart of output dynamics for different scenarios in Samuelson \n#(1939) model\nplt.plot(range(1, Q), Y[0, 0:Q - 1], color='black', linewidth=1, linestyle='-')\nplt.plot(range(1, Q), Y[1, 0:Q - 1], color='black', linewidth=1, linestyle='--')\nplt.xlabel(\"Time\")\nplt.ylabel(\"Y\")\nplt.title(\"Output under different scenarios\", fontsize=10)\nplt.legend([\"Baseline\", \"Increase in G0\"], loc='lower right')\nplt.show()\n\n# Time series chart of Samuelson (1939) model with separate axes for consumption \n# and investment\nfig, ax1 = plt.subplots()\nax1.plot(range(1, Q), C[0, 0:Q - 1], color='black', linewidth=2, linestyle='-', \n         label='C')\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(\"C\", color='black')\nax1.tick_params(axis='y', labelcolor='black')\nax2 = ax1.twinx()\nax2.plot(range(1, Q), I[0, 0:Q - 1], color='black', linewidth=2, linestyle='--',\n         label='I')\nax2.set_ylabel(\"I\", color='black')\nax2.tick_params(axis='y', labelcolor='black')\nplt.title(\"Consumption and Investment\", fontsize=10)\nlines, labels = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc='right')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#how-to-create-a-directed-graph-of-a-model",
    "href": "how_to_simulate.html#how-to-create-a-directed-graph-of-a-model",
    "title": "2  How to Simulate Economic Models",
    "section": "How to create a directed graph of a model",
    "text": "How to create a directed graph of a model\nAnother perspective on a model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\nThe directed graph can be derived from the model’s Jacobian matrix.2 Let \\(x\\) be the vector containing the model’s endogenous variables and \\(f(x)\\) the system of equations making up the model. The Jacobian matrix is then given by \\(J=\\frac{\\partial f()}{\\partial x}\\). As we often also want to display exogenous variables in the directed graph, it can be useful to expand the Jacobian matrix by adding rows and columns for those exogenous variables.\nNext, construct an ‘auxiliary’ Jacobian matrix \\(M\\) in which all the non-zero elements of the Jacobian are replaced by ones, whereas zero elements remain unchanged, i.e.\n\\[\nM_{ij} =\n\\begin{cases}\n1 & \\text{if }  J_{ij} \\neq 0, \\\\\n0 & \\text{otherwise.}\n\\end{cases}\n\\]\nFinally, taking the transpose of this `auxiliary’ Jacobian matrix yields the adjacency matrix \\(A=M^T\\), which is a binary matrix whose elements (\\(A_{ji}\\)) indicate whether there is a directed edge from a node \\(x_j\\) to node \\(x_i\\). From the adjacency matrix, the directed graph is constructed.\nThe code below shows this for the example of the Samuelson (1939) model.3\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 4 variables: \n  # endogenous: (1) Y, (2) C, (3) I\n  # exogenous: (4) G0\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\n              #1 2 3 4\nM_mat=matrix(c(0,1,1,1, #1\n               1,0,0,0, #2\n               0,1,0,0, #3\n               0,0,0,0), #4 \n               4, 4, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(G[0]))\n\n# Plot directed graph matrix\nplot(dg, main=\"Directed graph of Samuelson model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Construct auxiliary Jacobian matrix for 4 variables\n  # endogenous: (1) Y, (2) C, (3) I\n  # exogenous: (4) G0\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are\n# unchanged\nM_mat = np.array([[0, 1, 1, 1],\n         [1, 0, 0, 0],\n         [0, 1, 0, 0],\n         [0, 0, 0, 0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"Y\", 1: \"C\", 2: \"I\", 3: \"$G_0$\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=42)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=500, node_color='lightblue', font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.title(\"Directed graph of Samuelson model\", fontsize=12)\nplt.axis('off')\nplt.show()\n\n\n\n\nBroadly speaking, three types of nodes are possible:\n\nnodes from which arrows only point away represent exogenous variables (\\(G_0\\))\nnodes to which arrows point but from which arrows also point away represent endogenous variables that also have a causal impact on other variables (\\(Y\\), \\(C\\), and \\(I\\))\nnodes to arrows only point towards represent endogenous variables that are residuals (not present in this example)\n\nIt can thus be seen that the key exogenous variable in the Samuelson (1939) model is government spending \\(G_0\\), which determines aggregate income, which in turn feeds into consumption. Consumption then feeds into investment, which feeds back into income yielding the multiplier-accelerator effect.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#sec-sim-continuous",
    "href": "how_to_simulate.html#sec-sim-continuous",
    "title": "2  How to Simulate Economic Models",
    "section": "Appendix: How to simulate dynamic model in continuous time",
    "text": "Appendix: How to simulate dynamic model in continuous time\nSometimes, dynamic economic models are written in continuous time where the time increment is assumed to be infinitesimally small. Consider, for example, a continuous-time version of the Keynesian goods market model:\n\\[\n\\dot{Y}= k(C + I_0 - Y)\n\\]\n\\[\nC = c_0 + c_1Y,\n\\] where \\(\\dot{Y}=\\frac{dY}{dt}\\). To simulate this model, we have to approximate the differential equation for \\(\\dot{Y}\\) by a difference equation for \\(Y_t\\) and let the time increment \\(\\Delta t\\) become very small. More specifically, we write:\n\\[\nY(t+\\Delta t)=Y_t + \\dot{Y} \\Delta t =Y_t + [k(C + I_0 - Y)]\\Delta t.\n\\] This approach is also called the Euler forward method. The code below shows to implement that method. We use \\(\\Delta t = 0.01\\). Note that we need to raise the time horizon \\(Q\\) and set the adjustment speed \\(k\\) relatively high to make sure that the system has effectively converged to the equilibrium by \\(Q\\).\n\n### Simulate continuous time version of Keynesian goods market model\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of periods for which you want to simulate\nQ=800\n\n# Set number of parameterisations that will be considered\nS=1\n\n# Set fixed parameter values\nc0=3\nc1=0.8\nk=8\ndelta=0.01\n\n# Construct matrices in which values for different periods will be stored; initialise at 1\nY=matrix(data=1, nrow=S, ncol=Q)\nC=matrix(data=1, nrow=S, ncol=Q)\n\n#Construct matrices for exogenous variable \nI0=matrix(data=5, nrow=S, ncol=Q)\n\n#Solve this system recursively based on the initialisation\n  for (t in 2:Q){\n    for (iterations in 1:1000){\n    Y[1,t] = Y[1,t-1] + delta*(k*(C[1,t-1] + I0[1,t-1] - Y[1,t-1]))\n    C[1,t] = c0 + c1*Y[1,t]\n    } # close within-period loop\n  } # close time loop\n\n\n# Verify solutions for Y\n(c0+I0[1,Q])/(1-c1)\n\n[1] 40\n\nY[1,Q]\n\n[1] 39.9999\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Simulate continuous time version of Keynesian goods market model\n\n# Load NumPy\nimport numpy as np\n\n# Set number of periods for which you want to simulate\nQ = 800\n\n# Set number of parameterizations that will be considered\nS = 1\n\n# Set fixed parameter values\nc0 = 3\nc1 = 0.8\nk = 8\ndelta = 0.01\n\n# Initialize matrices to store values for different periods\nY = np.ones((S, Q))\nC = np.ones((S, Q))\n\n# Initialize the matrix for the exogenous variable\nI0 = np.full((S, Q), 5)\n\n# Solve this system recursively based on the initialization\nfor t in range(1, Q):\n    for iterations in range(1000):\n        Y[0, t] = Y[0, t - 1] + delta * (k * (C[0, t - 1] + I0[0, t - 1] - Y[0, t - 1]))\n        C[0, t] = c0 + c1 * Y[0, t]\n\n# Verify the solution for Y at time Q\n(c0 + I0[0, Q - 1]) / (1 - c1)\n\nY[0,Q - 1]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#references",
    "href": "how_to_simulate.html#references",
    "title": "2  How to Simulate Economic Models",
    "section": "References",
    "text": "References\n\n\n\n\nChiang, Alpha C, and Kevin Wainwright. 2005. Fundamental Methods of Mathematical Economics. 4th ed. New York: McGraw-Hill Education.\n\n\nFennell, Peter G., David J. P. O’Sullivan, Antoine Godin, and Stephen Kinsella. 2015. “Is It Possible to Visualise Any Stock Flow Consistent Model as a Directed Acyclic Graph?” Computational Economics 48 (2): 307–16. https://doi.org/10.1007/s10614-015-9521-8.\n\n\nSamuelson, Paul A. 1939. “Interactions between the Multiplier Analysis and the Principle of Acceleration.” The Review of Economics and Statistics 21 (2): 75–78. https://doi.org/10.2307/1927758.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#footnotes",
    "href": "how_to_simulate.html#footnotes",
    "title": "2  How to Simulate Economic Models",
    "section": "",
    "text": "That raises the question of whether an equilibrium is stable or unstable, which is discussed in Chapter 9.↩︎\nSee Fennell et al. (2015) for a neat exposition.↩︎\nTo create the directed graph, we rely on external libraries which you may have to install first. In R, this can be accomplished with install.packages(\"igraph\") and in Python with pip install networkx. Once that library is installed, you only need to activate it in each session before you use it. In R, you can do this by executing library(igraph) and in Python through import networkx.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html",
    "href": "a_neoclassical_macro_model.html",
    "title": "3  A Neoclassical Macro Model",
    "section": "",
    "text": "Overview\nThis model captures some key features of neoclassical macroeconomics. The model is based on the optimising behaviour of firms and households that interact in perfect markets. Households choose between labour and leisure as well as current and future consumption. They form (rational) expectations about their future income that impact their consumption decisions today. Firms are owned by households and maximise profits using a constant returns to scale technology (with diminishing marginal returns to factors of production). Markets are competitive and clear instantaneously through flexible prices. The most important market is the labour market, in which the equilibrium between firms’ demand and households’ supply of labour is established by a flexible real wage. The level of employment established on the labour market then determines aggregate supply via the production function. Aggregate demand always accommodates to aggregate supply via a flexible real interest rate that establishes an equilibrium between investment and saving (often interpreted as the market for loanable funds). The money supply is exogenous in this model and only impacts the price level but not the real economy – the so-called Classical Dichotomy (or neutrality of money). Government expenditures do influence the real economy but they crowd out private expenditures (through a mechanism called Ricardian Equivalence).\nIn this short- to medium-run version of the model, prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is thus static. However, expectations about future income and government spending will impact current consumption of households that intertemporally maximise utility. The model is adapted from Garín, Lester, and Sims (2021).",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#the-model",
    "href": "a_neoclassical_macro_model.html#the-model",
    "title": "3  A Neoclassical Macro Model",
    "section": "The Model",
    "text": "The Model\n\\[\nY=AK^aN^{1-a}, \\quad a\\in (0,1)\n\\tag{3.1}\\]\n\\[\nw=(1-a)AK^aN^{-a}\n\\tag{3.2}\\]\n\\[\nN= 1-\\frac{b_1}{w}, \\quad b_1&gt;0\n\\tag{3.3}\\]\n\\[\nC=c_1\\left[Y- G +\\frac{Y^f-G^f}{1+r} -c_2\\ln\\left(\\frac{b_1}{w}\\right)\\right]\n\\tag{3.4}\\]\n\\[\nI =\\left(\\frac{aAN^{1-a}}{r}\\right)^{\\frac{1}{1-a}}\n\\tag{3.5}\\]\n\\[\nG= G_0\n\\tag{3.6}\\]\n\\[\nY= C(r) + I(r) + G\n\\tag{3.7}\\]\n\\[\nr_n= r + \\pi^f\n\\tag{3.8}\\]\n\\[\nM_s=M_0\n\\tag{3.9}\\]\n\\[\nM_d=\\frac{b_3(1+r_n)PC}{r_n}\n\\tag{3.10}\\]\n\\[\nM = M_d(P)= M_s\n\\tag{3.11}\\]\nwhere \\(Y\\), \\(K\\), \\(N\\), \\(w\\), \\(C\\), \\(G\\), \\(r\\), \\(I\\), \\(r_n\\), \\(\\pi\\), \\(M_s\\), \\(M_d\\), and \\(P_t\\) are real output, the capital stock, employment, the real wage, consumption, government expenditures, the real interest rate, investment, the nominal interest rate, inflation, the money supply, money demand, and the price level, respectively. The \\(f\\)-superscript denotes (expected) future values. For simplicity, expected future variables will be treated as exogenous.\nBy Equation 3.1, output is determined by a Cobb-Douglass production function with constant returns to scale and diminishing marginal returns to each factor (capital and labour). Equation 3.2 is the labour demand of firms solved for the real wage. Profit maximising firms will hire workers until the real wage is equal to the marginal product of labour \\(\\left(\\frac{\\partial Y}{\\partial N}=(1-a)AK^aN^{-a}\\right)\\).1 Equation 3.3 specifies households’ labour supply, which is positively related to the real wage. By Equation 3.4, consumption is positively related to the real wage, current and (expected) future income,2 and negatively related to the real interest rate. The composite parameters \\(c_1= \\left(\\frac{1}{1+b_2+b_3}\\right)\\) and \\(c_2= b_1(b_2+b_3)\\) stem from the weights in the household’s utility function (see analytical discussion below). The consumption function implies that for a higher real interest rate, households increase their saving (the supply of loanable funds). Furthermore, consumption is negatively related to current and future government expenditures. This is an implication of consumption smoothing: as households know that governments will have to repay its debts in the future through higher taxes, an increase in government expenditures today is perceived as an increase in taxes (regardless of whether the government finances its current expenditures through taxes or debt, a result that is also called ‘Ricardian Equivalence’).3 Equation 3.5 specifies investment as a negative function of the real interest rate and a positive function of productivity. By Equation 3.6, government expenditures are exogenous. Equation 3.7 is the goods market equilibrium condition, which pins down the equilibrium real interest rate through the market for loanable funds. Equation 3.8 specifies the nominal interest rate using the well-known Fisher equation. Equation 3.9 says that the money supply is exogenous. By Equation 3.10, households’ money demand is negatively related to the nominal interest rate and positively related to consumption (capturing the transaction demand for money). Finally, Equation 3.11 is the equilibrium condition for the money market, which pins down the price level.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#simulation",
    "href": "a_neoclassical_macro_model.html#simulation",
    "title": "3  A Neoclassical Macro Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenarios 2 and 3 are a monetary expansion (increase in the exogenous money supply \\(M_0\\)) and fiscal expansion (increase in \\(G_0\\)), respectively. Scenario 4 is an improvement in total factor productivity (\\(A\\)) and scenario 5 a fall in expected future income (\\(Y^f\\)). Finally, scenario 6 is a shift in household preferences towards more leisure (\\(b_1\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(A\\)\n\\(a\\)\n\\(b_{1}\\)\n\\(b_{2}\\)\n\\(b_{3}\\)\n\\(G_{0}\\)\n\\(Y^{f}\\)\n\\(M_{0}\\)\n\\(K\\)\n\\(\\pi_{f}\\)\n\n\n\n1: baseline\n2\n0.3\n0.4\n0.9\n0.6\n1\n1\n5\n5\n0.02\n\n\n2: monetary expansion (\\(M_{0}\\))\n2\n0.3\n0.4\n0.9\n0.6\n1\n1\n6\n5\n0.02\n\n\n3: fiscal expansion (\\(G_{0}\\))\n2\n0.3\n0.4\n0.9\n0.6\n2\n1\n6\n5\n0.02\n\n\n4: productivity boost (\\(A\\))\n2.5\n0.3\n0.4\n0.9\n0.6\n1\n1\n5\n5\n0.02\n\n\n5: lower expected future income (\\(Y^{f}\\))\n2\n0.3\n0.4\n0.9\n0.6\n1\n0.2\n5\n5\n0.02\n\n\n6: increased preference for leisure (\\(b_{1}\\))\n2\n0.3\n0.8\n0.9\n0.6\n1\n1\n5\n5\n0.02\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S) # Income/output\nw_star=vector(length=S) # Real wage\nC_star=vector(length=S) # Consumption\nI_star=vector(length=S) # Investment\nr_star=vector(length=S) # Real interest rate\nrn_star=vector(length=S) # Nominal interest rate\nN_star=vector(length=S) # Employment\nP_star=vector(length=S) # Price level\n\n# Create and parameterise exogenous variables/parameters that will be shifted\nM0=vector(length=S) # money supply\nG0=vector(length=S) # government expenditures\nA=vector(length=S)  # productivity\nYf=vector(length=S) # expected future income\nb1=vector(length=S) # household preference for leisure\nM0[]=5\nG0[]=1\nA[]=2\nYf[]=1\nb1[]=0.4\n\n# Set parameter values for different scenarios\nM0[2]=6   # scenario 2: monetary expansion \nG0[3]=2   # scenario 3: fiscal expansion\nA[4]=2.5  # scenario 4: productivity boost\nYf[5]=0.2 # scenario 5: lower expected future income\nb1[6]=0.8 # scenario 6: increased preference for leisure\n\n#Set constant parameter values\na=0.3  # Capital elasticity of output\nb2=0.9 # discount rate\nb3=0.6 # household preference for money\nK=5    # Exogenous capital stock\npe=0.02 # Expected rate of inflation\nGf=1  # Future government spending\n\n# Initialise endogenous variables at arbitrary positive value\nw = C = I = Y = r = N = P = 1 \n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  \nfor (iterations in 1:1000){\n  \n  #Model equations\n  \n  #(1) Cobb-Douglass production function  \n  Y = A[i]*(K^a)*N^(1-a)\n  \n  #(2) Labour demand \n  w = A[i]*(1-a)*(K^a)*N^(-a) \n  \n  #(3) Labour supply\n  N = 1 - (b1[i])/w\n  \n  #(4) Consumption demand\n  C = (1/(1+b2+b3))*(Y - G0[i] + (Yf[i]-Gf)/(1+r) -b1[i]*(b2+b3)*log(b1[i]/w))\n   \n  #(5) Investment demand, solved for r\n  r=(I^(a-1))*a*A[i]*N^(1-a) \n   \n  #(6) Goods market equilibrium condition, solved for I\n  I = Y - C - G0[i]\n  \n  #(7) Nominal interest rate\n  rn = r + pe\n  \n  #(8) Price level\n  P = (M0[i]*rn)/((1+rn)*b3*C) \n\n}\n  \n#Save results for different parameterisations in vector\nY_star[i]=Y\nw_star[i]=w\nC_star[i]=C\nI_star[i]=I\nr_star[i]=r\nN_star[i]=N\nP_star[i]=P\nrn_star[i]=rn\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions from different parameterizations\nY_star = np.empty(S)  # Income/output\nw_star = np.empty(S)  # Real wage\nC_star = np.empty(S)  # Consumption\nI_star = np.empty(S)  # Investment\nr_star = np.empty(S)  # Real interest rate\nrn_star = np.empty(S)  # Nominal interest rate\nN_star = np.empty(S)  # Employment\nP_star = np.empty(S)  # Price level\n\n# Create and parameterize exogenous variables/parameters that will be shifted\nM0 = np.zeros(S)  # Money supply\nG0 = np.zeros(S)  # Government expenditures\nA = np.zeros(S)   # Productivity\nYf = np.zeros(S)  # Expected future income\nb1 = np.zeros(S)  # Household preference for leisure\n\n# Baseline parameterisation\nM0[:] = 5\nG0[:] = 1\nA[:] = 2\nYf[:] = 1\nb1[:] = 0.4\n\n# Set parameter values for different scenarios\nM0[1] = 6   # Scenario 2: monetary expansion\nG0[2] = 2   # Scenario 3: fiscal expansion\nA[3] = 2.5  # Scenario 4: productivity boost\nYf[4] = 0.2  # Scenario 5: lower expected future income\nb1[5] = 0.8  # Scenario 6: increased preference for leisure\n\n# Set constant parameter values\na = 0.3  # Capital elasticity of output\nb2 = 0.9  # Discount rate\nb3 = 0.6  # Household preference for money\nK = 5  # Exogenous capital stock\npe = 0.02  # Expected rate of inflation\nGf = 1  # Future government spending\n\n# Initialize endogenous variables at arbitrary positive values\nw = C = I = Y = r = N = P = 1 \n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # Model equations\n\n        # (1) Cobb-Douglas production function\n        Y = A[i] * (K**a) * N**(1-a)\n\n        # (2) Labour demand\n        w = A[i] * (1-a) * (K**a) * N**(-a)\n\n        # (3) Labour supply\n        N = 1 - (b1[i]) / w\n\n        # (4) Consumption demand\n        C = (1 / (1 + b2 + b3)) * (Y - G0[i] + (Yf[i] - Gf) / (1 + r) - b1[i] * (b2 + b3) * np.log(b1[i] / w))\n\n        # (5) Investment demand, solved for r\n        r = (I**(a-1)) * a * A[i] * N**(1-a)\n\n        # (6) Goods market equilibrium condition, solved for I\n        I = Y - C - G0[i]\n\n        # (7) Nominal interest rate\n        rn = r + pe\n\n        # (8) Price level\n        P = (M0[i] * rn) / ((1 + rn) * b3 * C)\n\n    # Save results for different parameterizations in the arrays\n    Y_star[i] = Y\n    w_star[i] = w\n    C_star[i] = C\n    I_star[i] = I\n    r_star[i] = r\n    N_star[i] = N\n    P_star[i] = P\n    rn_star[i] = rn\n\n\n\n\nPlots\nFigures Figure 3.1 - Figure 3.3 depicts the model economy’s real activity under different scenarios. Monetary expansions (scenario 2) have no effects on output and employment, capturing the idea of money neutrality (Classical Dichotomy). However, the monetary expansion does raise the price level (see Figure 3.2 ), capturing the key idea of the Quantity Theory of Money that inflation is driven by a growing money supply.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.1: Output\n\n\n\n\n\nbarplot(P_star, ylab=\"P\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.2: Price level\n\n\n\n\nAn increase in government spending (by one unit) in scenario 3 does not raise employment and real output as these are fully determined by the supply side rather than aggregate demand.4 Looking at Figures Figure 3.4 and Figure 3.5, it can be seen that government spending crowds out private spending (consumption and investment). The decrease in consumption is a result of consumption smoothing via the Euler equation: the household anticipates higher taxes in the future and reduces current consumption somewhat to smooth out the impact. The increase in government expenditures also raises demand for loanable funds, which pushes up the real interest rate (see Figure 3.6) and reduces investment (Figure 3.5) and consumption. There is also an inflationary effect linked to the higher real interest rate, which raises the nominal interest rate and reduces the demand for money.\n\nbarplot(N_star, ylab=\"N\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.3: Employment\n\n\n\n\nImprovements to the supply-side are captured by an increase in productivity (scenario 4), which raises real output, employment, and aggregate demand. In contrast to expansionary government policy, the price level falls.\n\nbarplot(C_star, ylab=\"C\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.4: Consumption\n\n\n\n\n\nbarplot(I_star, ylab=\"I\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.5: Investment\n\n\n\n\nA decrease in expected future income (scenario 5) has a small expansionary effect on aggregate output. This is because households will reduce some of their current consumption (see Figure 3.4 ) and supply more labour to smooth their consumption over time. The increase in saving reduces the real interest rate (see Figure 3.6 ) and is compensated by an increase in investment (see Figure 3.5 ).\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.6: Interest rate\n\n\n\n\nFinally, an increase in the preference for leisure (scenario 6) reduces labour supply and thereby output.\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here for output only)\nimport matplotlib.pyplot as plt\n\nscenario_names = [\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\", \n                  \"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"]\n\n# Output\nplt.bar(scenario_names , Y_star)\nplt.ylabel('Y')\nplt.xticks(rotation=45, ha=\"right\")  # Rotate x-axis labels for better readability\nplt.tight_layout()  # Ensure the labels fit within the plot area\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#directed-graph",
    "href": "a_neoclassical_macro_model.html#directed-graph",
    "title": "3  A Neoclassical Macro Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 13 variables: \n# Y w   N   C   I   r   P   rn M0   G0 A Yf Md\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,0,1,0,0,0,0,0,0,0,1,0,0,\n              0,0,1,0,0,0,0,0,0,0,1,0,0,\n              0,1,0,0,0,0,0,0,0,0,0,0,0,\n              1,1,0,0,0,1,0,0,0,1,0,1,0,\n              0,0,1,0,0,1,0,0,0,0,0,0,0,\n              1,0,0,1,1,0,0,0,0,1,0,0,0,\n              0,0,0,0,0,0,0,0,1,0,0,0,1,\n              0,0,0,0,0,1,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,1,0,0,1,1,0,0,0,0,0), 13, 13, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\",\"w\",\"N\",\"C\",\"I\",\"r\",\"P\", expression(r[n]), expression(M[0]),expression(G[0]),\"A\",expression(Y^f), expression(M[d]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 3.7: Directed graph\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Construct the auxiliary Jacobian matrix\nM_mat = np.array([\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0],\n    [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0]\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {\n    0: \"Y\",\n    1: \"w\",\n    2: \"N\",\n    3: \"C\",\n    4: \"I\",\n    5: \"r\",\n    6: \"P\",\n    7: r\"$r_n$\",\n    8: r\"$M_0$\",\n    9: r\"$G_0$\",\n    10: \"A\",\n    11: r\"$Y^f$\",\n    12: r\"$M_d$\"\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=42)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 3.7 , it can be seen that productivity (\\(A\\)), future income (\\(Y^f\\)), the money supply (\\(M_0\\)), and government spending (\\(G_0\\)) are the key exogenous variables of the model. All other variables are endogenous, and many of them form a closed loop (or cycle) within the system. The left part of the graph captures the supply side: the labour market simultaneously pins down the real wage and employment, which together with the exogenously level of productivity determine output. The part in the middle embodies the demand side: aggregate demand (consumption, investment, and government spending) together with a given level of output determine the real interest rate. The right part captures the nominal side of the model given by the money market, which determines the price level. Notably, while the real side of the model feeds into the money market via the nominal interest rate (\\(r_n\\)), there is not causal effect from the money market to the real side reflecting the Classical Dichotomy.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#analytical-discussion-derivation-of-behavioural-functions",
    "href": "a_neoclassical_macro_model.html#analytical-discussion-derivation-of-behavioural-functions",
    "title": "3  A Neoclassical Macro Model",
    "section": "Analytical discussion: derivation of behavioural functions",
    "text": "Analytical discussion: derivation of behavioural functions\nThe firm’s problem: profit maximisation\nThe firm’s profit equation is given by:\n\\[\n\\Pi=Y-w N-r k\n\\tag{3.12}\\]\n\\[\n=A K^a N^{1-a}-w N-r k .\n\\tag{3.13}\\]\nThe firm’s optimisation problem is to maximise profits using employment and capital as choice variables:5\n\\[\n\\max _{N, K} \\Pi=A K^a N^{1-a}-w N-r k .\n\\tag{3.14}\\]\nThe first-order conditions are given by:\n\\[\n(1-a) A K^a N^{-a}-w=0\n\\tag{3.15}\\]\n\\[\na A K^{a-1} N^{1-a}-r=0 .\n\\tag{3.16}\\]\nFrom Equation 3.15, Equation 3.2 for labour demand can be derived. While the capital stock is pre-determined in every period, the firm can adjust the capital stock through investment. We thus use the first-order condition for capital Equation 3.16 to derive Equation 3.5 for investment demand.\nThe government’s budget constraint\nThe government’s current and future budget constraints are given by:\n\\[\nG=T+B\n\\tag{3.17}\\]\n\\[\nG^f=T^f-(1+r) B\n\\tag{3.18}\\] where \\(T\\) is tax revenues and \\(B\\) is government debt.\nA crucial assumption here is that the government must repay its debts in the future (it cannot permanently roll over its debts). The underlying assumption is that the government will eventually ‘die’ and will do so without savings nor debt.\nCombining the two budget constraints to an intertemporal budget constraint yields:\n\\[\nG+\\frac{G^f}{1+r}=T+\\frac{T^f}{1+r}\n\\tag{3.19}\\]\nThus, while the government’s budget need not be balanced in every period, it will be balanced over time (in a present value sense).6\nThe household’s problem: intertemporal utility maximisation and Ricardian Equivalence\nThe household derives utility from current consumption, leisure (\\(1-N\\)), future consumption \\(C^f\\), and from holding real money balances \\(\\left(\\frac{M}{P}\\right)\\). We use the following log utility function that is non-separable in consumption and leisure:7\n\\[\nU=\\ln [C+ b_1 \\ln (1-N)]+b_2 \\ln \\left(C^f\\right)+b_3 \\ln \\left(\\frac{M}{P}\\right), \\quad b_2\\in (0,1); b_1, b_3&gt;0\n\\tag{3.20}\\]\nThe household’s current budget constraint is given by:8\n\\[\nC=Y-T-S-\\frac{M}{P}\n\\tag{3.21}\\]\nThe income that is not consumed can either be saved (\\(S\\)) at nominal interest rate (\\(r_n\\)) or held as money on which no return is earned.\nThe future budget constraint (assuming that households do not save in the future) is given by:\n\\[\nC^f = Y^f - T^f + (1+r_n)\\frac{PS}{P^f} + \\frac{M}{P^f}.\n\\tag{3.22}\\]\nUsing the Fisher equation \\((1+r)=(1+r_n)\\frac{P}{P^f}\\), the future budget constraint can be rewritten as:\n\\[\nC^f = Y^f  - T^f + (1+r)S + \\frac{(1+r)M}{(1+r_n)P}\n\\tag{3.23}\\]\nFinally, the two budget constraints can be combined to yield an intertemporal budget constraint:\n\\[\nC^f = (Y-C-T)(1+r)+Y^f -T^f - (1+r)\\frac{r_nM}{(1+r_n)P}.\n\\tag{3.24}\\]\nSubstituting the government’s intertemporal budget constraint, the household’s intertemporal budget constraint can also be written as:\n\\[\nC^f = (Y-C-G)(1+r)+Y^f -G^f - (1+r)\\frac{r_nM}{(1+r_n)P}\n\\tag{3.25}\\]\nThe fact that current and future tax payments are now replaced by current and future government spending means that it does not matter for the real economy how government spending is financed: the private sector will react to expenditures that are financed out of debt in the same way it reacts to expenditures financed out of taxation. This result is also known as Ricardian Equivalence. Put differently, Ricardian Equivalence means the household behaves as if the government balances its budget in every period.\nWith these ingredients, the household’s optimisation problem can be written as:\n\\[\n\\begin{array}{ll}\n\\max _{C, N, M} & U=\\ln (C+b_1 \\ln (1-N))+b_2 \\ln \\left(C^f\\right)+b_3 \\ln \\left(\\frac{M}{P}\\right), \\\\\n\\text { s.t. } & C^f= (Y-C-G)(1+r)+Y^f -G^f - (1+r)\\frac{r_nM}{(1+r_n)P} .\n\\end{array}\n\\]\nSubstituting the constraint Equation 3.25 for \\(C^f\\) in the utility function, and making use of the identity \\(Y=\\Pi+rK+Nw\\), allows to obtain the following first-order conditions:\n\\[\nC=\\frac{C^f}{b_2(1+r)} - b_1\\ln(1-N)\n\\tag{3.26}\\]\n\\[\n\\left(\\frac{b_1}{1-N}\\right)\\left(\\frac{1}{C+b_1\\ln(1-N)} \\right)=\\frac{b_2(1+r)w}{C^f}\n\\tag{3.27}\\]\n\\[\nM=\\frac{b_3PC^f(1+r_n)}{b_2(1+r)r_n} .\n\\tag{3.28}\\]\nSubstituting Equation 3.26, which is often also called the Euler equation, into Equation 3.27 and Equation 3.28 yields Equation 3.3 for labour supply and Equation 3.10 for money demand, respectively. Finally, using Equation 3.25 and Equation 3.28 in the Euler Equation 3.26 yields the consumption function Equation 3.4.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#references",
    "href": "a_neoclassical_macro_model.html#references",
    "title": "3  A Neoclassical Macro Model",
    "section": "References",
    "text": "References\n\n\n\n\nGarín, Julio, Robert Lester, and Eric Sims. 2021. Intermediate Macroeconomics. Draft Version 3.0.1. https://juliogarin.com/files/textbook/GLS_Intermediate_Macro.pdf.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#footnotes",
    "href": "a_neoclassical_macro_model.html#footnotes",
    "title": "3  A Neoclassical Macro Model",
    "section": "",
    "text": "See the analytical discussion below for a derivation of equations Equation 3.2 -Equation 3.5 and Equation 3.10 from optimising microfoundations.↩︎\nHouseholds are assumed to form rational expectations. In a deterministic setting, this implies perfect foresight so that expected and actual future income coincide.↩︎\nSee the analytical discussion below for more details on Ricardian Equivalence.↩︎\nThis result is partly driven by the use of a non-separable utility function, see analytical discussion below. With a separable utility function, the increase in government spending would increase labour supply and thereby have effects on employment and output.↩︎\nSee Garín, Lester, and Sims (2021, chap. 12) for a more elaborate version where the firm maximises its lifetime value. The resulting investment function is very similar.↩︎\nSee Garín, Lester, and Sims (2021, chap. 13) for a more detailed discussion of the government’s budget constraints.↩︎\nSee Garín, Lester, and Sims (2021), pp.280-289), on the differences between a separable and a non-separable preference specification. Note also that for simplicity, the utility function omits the utility from future leisure.↩︎\nSee Garín, Lester, and Sims (2021, chap. 14) for a more detailed discussion of the household’s budget constraints.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html",
    "href": "an_IS_LM_model.html",
    "title": "4  An IS-LM Model",
    "section": "",
    "text": "Overview\nThe IS-LM model was developed by John R. Hicks (1937) to formalise some key ideas of John Maynard Keynes’ 1936 book The General Theory of Employment, Interest and Money. The model contains two equilibrium relationships: a goods market equilibrium between investment and saving (IS) and a money market equilibrium between money demand and money supply (LM). In the goods market, aggregate supply adjusts to the level of aggregate demand given by the expenditure decisions of households, firms, and the government. Households form their consumption demand based on a constant marginal propensity to consume out of income. Firms take investment decisions based on the rate of interest. Money demand is determined by aggregate income (transactions demand) and the interest rate on bonds (speculative demand). The money supply is assumed to be exogenous and under the control of the central bank. The two markets pin down equilibrium output and the interest rate. The goods market equilibrium may well coincide with involuntary unemployment. Adverse shocks to autonomous investment (‘animal spirits’) or autonomous money demand (‘liquidity preference’) reduce output and raise unemployment. The government can use monetary policy, fiscal spending, and income taxes to stimulate economic activity and achieve full employment.\nIn this short-run model, prices and the capital stock are fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is static. We consider a version with linear functions, adapted from Blanchard and Johnson (2013, chap. 5).",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#the-model",
    "href": "an_IS_LM_model.html#the-model",
    "title": "4  An IS-LM Model",
    "section": "The Model",
    "text": "The Model\n\\[\nY=C+I+G\n\\tag{4.1}\\]\n\\[\nC=c_{0}+c_{1}(Y-T), \\quad c_{1} \\in(0,1)\n\\tag{4.2}\\]\n\\[\nI=i_{0}-i_{1} r, \\quad i_{1}&gt;0\n\\tag{4.3}\\]\n\\[\nG=G_{0}\n\\tag{4.4}\\]\n\\[\nT=T_{0}\n\\tag{4.5}\\]\n\\[\nM_{s}=M_{0}\n\\tag{4.6}\\]\n\\[\nM_{d}=m_{0}+m_{1} Y-m_{2} r, \\quad m_{1}&gt;0\n\\tag{4.7}\\]\n\\[\nM=M_{d}=M_{s}\n\\tag{4.8}\\]\n\\[\nN=a Y, \\quad a&gt;0\n\\tag{4.9}\\]\n\\[\nU=1-\\frac{N}{N^{f}}\n\\tag{4.10}\\]\nwhere \\(Y\\), \\(C\\), \\(I\\), \\(G\\), \\(T\\), \\(r\\), \\(M_{d}\\), \\(M_{s}\\), \\(N\\), \\(U\\) and \\(N^{f}\\) are output, consumption, investment, government spending, taxes, the interest rate on bonds, money demand, money supply, employment, the unemployment rate, and the labour force, respectively. The constant price level has been normalised to unity.\nEquation 4.1 is the goods market equilibrium condition. Aggregate supply \\((Y)\\) accommodates to the level of aggregate demand which is the sum of consumption, investment, and government spending. Equation 4.2 is the consumption function consisting of autonomous consumption demand \\(\\left(c_{0}\\right)\\) and a marginal propensity to consume \\(\\left(c_{1}\\right)\\) out of disposable income \\((Y-T)\\). Investment demand in Equation 4.3 has an autonomous component \\(\\left(i_{0}\\right)\\) capturing Keynesian animal spirits and a component that is negatively related to the rate of interest on bonds. By equations Equation 4.4 and Equation 4.5, government spending and taxation are exogenous. Similarly, the money supply in Equation 4.6 is assumed to be exogenous. By Equation 4.7, households’ money demand is positively related to income (capturing the transaction demand for money) and negatively related to the interest rate on bonds (capturing speculative demand). There is also an autonomous term \\(\\left(m_{0}\\right)\\) capturing Keynesian liquidity preference. Equation 4.9 is a fixed-coefficient production function through which employment is determined. In conjunction with an exogenously given labour force \\(\\left(N^{f}\\right)\\), the level of employment can be used to obtain an unemployment rate in Equation 4.10.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#simulation",
    "href": "an_IS_LM_model.html#simulation",
    "title": "4  An IS-LM Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenarios 2 and 3 model a switch towards pessimistic sentiments: a fall in animal spirits \\(\\left(i_{0}\\right)\\) and an increase in liquidity preference \\(\\left(m_{0}\\right)\\). Scenarios 4 to 6 consider three different government policies to stimulate the economy: a monetary expansion \\(\\left(M_{0}\\right)\\), a tax cut \\(\\left(T_{0}\\right)\\), and a fiscal expansion \\(\\left(G_{0}\\right)\\).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(c_{0}\\)\n\\(c_{1}\\)\n\\(i_{0}\\)\n\\(i_{1}\\)\n\\(m_{0}\\)\n\\(m_{1}\\)\n\\(m_{2}\\)\n\\(M_{0}\\)\n\\(T_{0}\\)\n\\(G_{0}\\)\n\\(a\\)\n\\(N^{f}\\)\n\n\n\n1: baseline\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n5\n1\n1\n1.5\n18\n\n\n2: fall in animal spirits (\\(i_{0}\\))\n2\n0.6\n1\n0.1\n6\n0.2\n0.4\n5\n1\n1\n1.5\n18\n\n\n3: increased liquidity preference (\\(m_{0}\\))\n2\n0.6\n2\n0.1\n7\n0.2\n0.4\n5\n1\n1\n1.5\n18\n\n\n4: monetary expansion (\\(M_{0}\\))\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n6\n1\n1\n1.5\n18\n\n\n5: tax cut (\\(T_{0}\\))\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n5\n0\n1\n1.5\n18\n\n\n6: fiscal expansion (\\(G_{0}\\))\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n5\n1\n2\n1.5\n18\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S) # Income/output\nC_star=vector(length=S) # Consumption\nI_star=vector(length=S) # Investment\nr_star=vector(length=S) # Real interest rate\nN_star=vector(length=S) # Employment\nU_star=vector(length=S) # Unemployment rate\n\n# Set exogenous variables that will be shifted\ni0=vector(length=S) # autonomous investment\nm0=vector(length=S) # Autonomous demand for money\nM0=vector(length=S) # money supply\nG0=vector(length=S) # government spending\nT0=vector(length=S) # taxes\ni0[]=2\nm0[]=6\nM0[]=5   \nG0[]=1   \nT0[]=1\n\n## Construct scenarios\n# scenario 2: fall in animal spirits\ni0[2]=1\n \n#scenario 3: increase in liquidity preference\nm0[3]=7\n\n# scenario 4: monetary expansion \nM0[4]=6\n\n# scenario 5: reduction in tax rate\nT0[5]=0  \n\n# scenario 6: fiscal expansion\nG0[6]=2 \n\n#Set constant parameter values\nc0=2   # Autonomous consumption\nc1=0.6 # Sensitivity of consumption with respect to the income (marginal propensity to consume)\ni1=0.1 # Sensitivity of investment with respect to the interest rate\nm1=0.2 # Sensitivity of money demand with respect to income\nm2=0.4 # Sensitivity of money demand with respect to interest rate\na=1.5  # labour coefficient\nNf=18  # Full employment/labour force\n\n# Initialise endogenous variables at some arbitrary positive value \nY = C = I =r = N = U = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\n\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #Model equations\n    \n    # Goods market equilibrium\n    Y = C + I + G0[i]\n    \n    # Consumption demand\n    C = c0 + c1*(Y-T0[i])\n    \n    # Investment demand\n    I = i0[i] - i1*r\n    \n    # Money market, solved for interest rate\n    r = (m0[i] - M0[i])/m2 + m1*Y/m2\n    \n    # Employment\n    N = a*Y \n    \n    #Unemployment rate\n    U = (1 - N/Nf)\n    \n  }\n  #Save results for different parameterisations in vector\n  Y_star[i]=Y\n  C_star[i]=C\n  I_star[i]=I\n  r_star[i]=r\n  N_star[i]=N\n  U_star[i]=U\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions from different parameterizations\nY_star = np.empty(S)  # Income/output\nC_star = np.empty(S)  # Consumption\nI_star = np.empty(S)  # Investment\nr_star = np.empty(S)  # Real interest rate\nN_star = np.empty(S)  # Employment\nU_star = np.empty(S)  # Unemployment rate\n\n# Set exogenous variables that will be shifted\ni0 = np.zeros(S)  # Autonomous investment\nm0 = np.zeros(S)  # Autonomous demand for money\nM0 = np.zeros(S)  # Money supply\nG0 = np.zeros(S)  # Government spending\nT0 = np.zeros(S)  # Taxes\n\n# Baseline parameterisation\ni0[:] = 2\nm0[:] = 6\nM0[:] = 5\nG0[:] = 1\nT0[:] = 1\n\n# Construct scenarios\n# scenario 2: fall in animal spirits\ni0[1] = 1\n\n# scenario 3: increase in liquidity preference\nm0[2] = 7\n\n# scenario 4: monetary expansion\nM0[3] = 6\n\n# scenario 5: reduction in tax rate\nT0[4] = 0\n\n# scenario 6: fiscal expansion\nG0[5] = 2\n\n# Set constant parameter values\nc0 = 2  # Autonomous consumption\nc1 = 0.6  # Sensitivity of consumption with respect to income (marginal propensity to consume)\ni1 = 0.1  # Sensitivity of investment with respect to the interest rate\nm1 = 0.2  # Sensitivity of money demand with respect to income\nm2 = 0.4  # Sensitivity of money demand with respect to the interest rate\na = 1.5  # labor coefficient\nNf = 18  # Full employment/labor force\n\n# Initialize endogenous variables at some arbitrary positive value\nY = C = I =r = N = U = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # Model equations\n\n        # Goods market equilibrium\n        Y = C + I + G0[i]\n\n        # Consumption demand\n        C = c0 + c1 * (Y - T0[i])\n\n        # Investment demand\n        I = i0[i] - i1 * r\n\n        # Money market, solved for interest rate\n        r = (m0[i] - M0[i]) / m2 + m1 * Y / m2\n\n        # Employment\n        N = a * Y\n\n        # Unemployment rate\n        U = 1 - N / Nf\n\n    # Save results for different parameterizations in the arrays\n    Y_star[i] = Y\n    C_star[i] = C\n    I_star[i] = I\n    r_star[i] = r\n    N_star[i] = N\n    U_star[i] = U\n    \n\n\n\n\nPlots\nFigure 16.1 and Figure 4.2 depict the response of the model’s key endogenous variables, output and the interest rate, to various shifts. A fall in animal spirits (scenario 2) and an increase in liquidity preference (scenario 3) both have contractionary effects. While the fall in animal spirits directly reduces aggregate demand and thereby output (despite a fall in the interest rate), the rise in liquidity preference depresses output through its positive effect on the interest rate. Both scenarios raise the unemployment rate (Figure 4.3). Scenarios 4 to 6 assess three different macroeconomic policy tools to stimulate output. It can be seen in Figure 16.1 that fiscal policy is more effective than monetary policy for the parameterisation in Table 1.1 Direct fiscal stimulus is more effective than tax cuts due to the constant marginal propensity to consume. The effect on output is a multiple of the one-unit stimulus thanks to the multiplier effect. However, it can also be seen that fiscal policy raises the interest rate, which crowds out some of the expansionary effect.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.1: Output\n\n\n\n\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.2: Interest rate\n\n\n\n\n\nbarplot(U_star*100, ylab=\"U (%)\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                              \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.3: Unemployment\n\n\n\n\nFigure 4.4 and Figure 4.5 further show that monetary policy mostly stimulates investment, whereas fiscal policy boost consumption.\n\nbarplot(I_star, ylab=\"I\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.4: Investment\n\n\n\n\n\nbarplot(C_star, ylab=\"C\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.5: Consumption\n\n\n\n\n\nbarplot(N_star, ylab=\"N\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\", \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.6: Employment\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for output)    \nimport matplotlib.pyplot as plt\n\nscenario_names = [\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                  \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"]\n\nplt.bar(scenario_names, Y_star)\nplt.ylabel('Y')\nplt.xticks( scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#directed-graph",
    "href": "an_IS_LM_model.html#directed-graph",
    "title": "4  An IS-LM Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_{1}\\) to node \\(x_{2}\\) indicates a causal impact of \\(x_{1}\\) on \\(x_{2}\\).\n\n# Construct auxiliary Jacobian matrix for 11 variables: Y, C, I, G, T, r, M0, N, i0, m0, Md\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,1,1,1,0,0,0,0,0,0,0,\n              1,0,0,0,1,0,0,0,0,0,0,\n              0,0,0,0,0,1,0,0,1,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,1,0,0,0,1,\n              0,0,0,0,0,0,0,0,0,0,0,\n              1,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              1,0,0,0,0,1,0,0,0,1,0), 11, 11, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(G[0]), expression(T[0]), \"r\", expression(M[0]), \"N\", expression(i[0]), expression(m[0]), expression(M[d]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 4.7: Directed graph of IS-LM model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the auxiliary Jacobian matrix\nM_mat = np.array([\n    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n\n# Define node labels\nnodelabs = {\n    0: \"Y\",\n    1: \"C\",\n    2: \"I\",\n    3: r\"$G_0$\",\n    4: r\"$T_0$\",\n    5: \"r\",\n    6: r\"$M_0$\",\n    7: \"N\",\n    8: r\"$i_0$\",\n    9: r\"$m_0$\",\n    10: r\"$M_d$\"\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#analytical-discussion",
    "href": "an_IS_LM_model.html#analytical-discussion",
    "title": "4  An IS-LM Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo obtain the IS-curve, substitute Equation 4.2 - Equation 4.5 into Equation 4.1 and solve for \\(Y\\):\n\\[\nY=\\left(\\frac{1}{1-c_1}\\right)(c_0 + i_0 + G_0 - i_1r - c_1 T_0).\n\\tag{4.11}\\]\nTo obtain the LM-curve, substitute Equation 4.6 - Equation 4.7 into Equation 4.8 and solve for \\(r\\):\n\\[\nr=\\left(\\frac{1}{m_2}\\right)(m_0 - M_0 + m_1Y).\n\\tag{4.12}\\]\nFinally, to obtain equilibrium solutions for \\(Y\\) and \\(r\\), substitute Equation 4.12 into Equation 4.11 and vice versa:\n\\[\nY^*=\\left[\\frac{m_2}{(1-c_1)m_2+i_1m_1}\\right](c_0 + i_0 + G_0 - c_1 T_0) + \\left[\\frac{i_1}{(1-c_1)m_2+i_1m_1}\\right](M_0-m_0)\n\\]\n\\[\nr^*= \\left[\\frac{1-c_1}{(1-c_1)m_2+i_1m_1}\\right](m_0-M_0)+\\left[\\frac{m_1}{(1-c_1)m_2+i_1m_1}\\right](c_0+i_0+G_0-c_1T_0).\n\\]\nFrom this, the following results can be obtained:\n\nThe equilibrium effects of a change in taxes are smaller than those from a change in government spending (since \\(c_1\\) is smaller than one).\nGovernment spending is more effective than monetary expansion if \\(m_2 &gt; i_1\\) (which is the case for the parameterisation in Table 1.\nThe equilibrium multiplier \\(\\left[\\frac{m_2}{(1-c_1)m_2+i_1m_1}\\right]\\) is smaller than the aggregate demand multiplier \\(\\left(\\frac{1}{1-c_1}\\right)\\) due to the positive effect on the interest rate and the corresponding negative effect investment (\\(i_1m_1\\)). This is the crowding out mechanism.\n\nCalculate equilibrium fiscal multiplier\n\nY_star[6]-Y_star[1] # numerical approach\n\n[1] 2.222222\n\nm2/((1-c1)*m2+i1*m1) # analytical approach\n\n[1] 2.222222\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nY_star[5]-Y_star[0] # numerical approach\n\nm2/((1-c1)*m2+i1*m1) # analytical approach",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#references",
    "href": "an_IS_LM_model.html#references",
    "title": "4  An IS-LM Model",
    "section": "References",
    "text": "References\n\n\n\n\nBlanchard, Olivier, and David R. Johnson. 2013. Macroeconomics, 6th Edition. Pearson.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#footnotes",
    "href": "an_IS_LM_model.html#footnotes",
    "title": "4  An IS-LM Model",
    "section": "",
    "text": "The analytical discussion below shows formally that fiscal policy is more effective than monetary policy if \\(m_{2}&gt;i_{2}\\).↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "",
    "text": "Overview\nThe Neoclassical Synthesis was developed in the 1940s and 1950s by Franco Modigliani, Paul Samuelson and others. It introduced neoclassical components into the Keynesian IS-LM model that had been proposed by John R. Hicks (1937) to formalise some key ideas of John Maynard Keynes’ 1936 book The General Theory of Employment, Interest and Money. The IS-LM model, which is analysed in detail in Chapter 4, contains two equilibrium relationships: a goods market equilibrium between investment and saving (IS) and a money market equilibrium between money demand and money supply (LM). In the goods market, aggregate supply adjusts to the level of aggregate demand given by the expenditure decisions of households, firms, and the government. Money demand is determined by aggregate income and the interest rate on bonds. The money supply is assumed to be exogenous. The two markets pin down equilibrium output and the interest rate.\nThe Neoclassical Synthesis adds a neoclassical labour market with Keynesian frictions to the IS-LM model. Following the discussion in Froyen (2005), chap. 9, we consider a labour market in which firms have perfect information about the real wage, whereas workers need to form expectations about the price level. Price expectations are assumed to be exogenous in the short run. Workers thus suffer from `money illusion’: an increase in the actual price levels reduces the real wage but leaves their labour supply unchanged. This gives rise to an upward-sloping aggregate supply (AS) (or Phillips) curve. By contrast, the aggregate demand (AD) curve is downward-sloping as a higher price level increases the demand for real money balances, which pushes up the interest rate.\nIn this short-run model, prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is static. We consider a version with a Cobb-Douglass production function and otherwise linear behavioural functions, based on the graphical analysis in Froyen (2005), chap. 9.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#the-model",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#the-model",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "The Model",
    "text": "The Model\n\\[\nY=C+I+G_0\n\\tag{5.1}\\]\n\\[\nC=c_0+c_1(Y-T_0), \\quad c_1 \\in (0,1)\n\\tag{5.2}\\]\n\\[\nI= i_0 - i_1r,  \\quad i_1 &gt; 0\n\\tag{5.3}\\]\n\\[\nM_s=M_0\n\\tag{5.4}\\]\n\\[\n\\frac{M_d}{P}=m_0 + m_1Y -m_2r, \\quad m_1, m_2 &gt; 0\n\\tag{5.5}\\]\n\\[\nM_d(r)=M_s\n\\tag{5.6}\\]\n\\[\nw=(1-a)AK^aN^{-a} ,\\quad a\\in (0,1)\n\\tag{5.7}\\]\n\\[\nW=\\frac{P^ebC}{1-\\frac{N}{N^f}},  \\quad b \\in (0,1)\n\\tag{5.8}\\]\n\\[\nP=\\frac{W}{w}\n\\tag{5.9}\\]\n\\[\nN=\\left( \\frac{Y}{AK^{a}}\\right)^{\\frac{1}{1-a}}\n\\tag{5.10}\\]\n\\[\nU=1-\\frac{N}{N^f}\n\\tag{5.11}\\]\nwhere \\(Y\\), \\(C\\), \\(I\\), \\(G_0\\), \\(T_0\\), \\(r\\), \\(M_s\\), \\(M_d\\), \\(w\\), \\(A\\), \\(K\\), \\(N\\), \\(W\\), \\(P^e\\) \\(N^f\\), \\(P\\), and \\(U\\) are output, consumption, investment, (exogenous) government spending, (exogenous) taxes, the real interest rate on bonds, nominal money supply, nominal money demand, the real wage, productivity, the capital stock, employment, the nominal wage, the price level expected by workers, the labour force (or total available time for work), the actual price level, and the unemployment rate, respectively.\nEquation 5.1 is the goods market equilibrium condition. Aggregate supply (\\(Y\\)) accommodates to the level of aggregate demand which is the sum of consumption, investment, and government spending. Equation 5.2 is the consumption function consisting of autonomous consumption demand (\\(c_0\\)) and a marginal propensity to consume (\\(c_1\\)) out of disposable income (\\(Y-T_0\\)). Investment demand in Equation 5.3 has an autonomous component (\\(i_0\\)) capturing Keynesian animal spirits and a component that is negatively related to the rate of interest on bonds. Government spending and taxation are exogenous. Similarly, the nominal money supply (\\(M_0\\)) in Equation 5.4 is assumed to be exogenous. By Equation 5.5, households’ real money demand is positively related to income (capturing the transaction demand for money) and negatively related to the interest rate on bonds (capturing speculative demand). There is also an autonomous term (\\(m_0\\)) capturing Keynesian liquidity preference. Equilibrium in the money market Equation 5.6 yields an equation for the interest rate.\nIn Equation 5.7, the real wage is determined by the marginal product of labour implied by a Cobb-Douglass production function (\\(Y=AK^aN^{1-a}\\)). This means the real wage is always consistent with firms’ demand for labour based on profit-maximisation.1 Equation 5.8 specifies the nominal wage as implied by households’ labour supply curve. Optimising households supply labour based on their work-leisure trade-off (with the parameter \\(b\\) capturing their preference for leisure, \\(1-\\frac{N}{N^f}\\)). Since they don’t have knowledge of the current real wage, they base their decisions on the expected price level \\(P^e\\), which is exogenous in the short run. The actual price level is then given by the ratio of the nominal wage to the real wage Equation 5.9. In other words, firms set prices such that the nominal wage they pay to workers are consistent with their own desired real wage. Equation 5.10 pins down employment as implied by the Cobb-Douglass production function. In conjunction with an exogenously given labour force \\(N^f\\) (or total available labour time), the level of employment can be used to obtain an unemployment rate in Equation 5.11.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#simulation",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#simulation",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenario 2 is a switch towards pessimistic sentiments in the form of a fall in animal spirits (\\(i_0\\)). In scenario 3, productivity (\\(A\\)) increases. Scenario 4 considers a rise in the price level expected by workers (\\(P^e\\)). Scenarios 5 and 6 consider two different government policies to stimulate the economy: a monetary expansion (\\(M_0\\)) and a fiscal expansion (\\(G_0\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(c_0\\)\n\\(c_1\\)\n\\(i_0\\)\n\\(i_1\\)\n\\(A\\)\n\\(P^e\\)\n\\(m_0\\)\n\\(m_1\\)\n\\(m_2\\)\n\\(M_0\\)\n\\(G_0\\)\n\\(T_0\\)\n\\(N^f\\)\n\\(a\\)\n\\(b\\)\n\n\n\n1: baseline\n2\n0.6\n2\n0.1\n2\n1\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n2: fall in animal spirits (\\(i_0\\))\n2\n0.6\n1.5\n0.1\n2\n1\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n3: rise in productivity (\\(A\\))\n2\n0.6\n2\n0.1\n3\n1\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n4: rise in expected price level (\\(P^e\\))\n2\n0.6\n2\n0.1\n2\n1.5\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n5: monetary expansion (\\(M_0\\))\n2\n0.6\n2\n0.1\n2\n1\n6\n0.2\n0.4\n6\n1\n1\n7\n0.3\n0.4\n\n\n6: fiscal expansion (\\(G_0\\))\n2\n0.6\n2\n0.1\n2\n1\n6\n0.2\n0.4\n5\n2\n1\n7\n0.3\n0.4\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S) # Income/output\nC_star=vector(length=S) # Consumption\nI_star=vector(length=S) # Investment\nr_star=vector(length=S) # Real interest rate\nN_star=vector(length=S) # Employment\nU_star=vector(length=S) # Unemployment rate\nP_star=vector(length=S) # Price level\nw_star=vector(length=S) # Real wage\nW_star=vector(length=S) # Nominal wage\n\n# Set exogenous variables that will be shifted\ni0=vector(length=S) # autonomous investment (animal spirits)\nM0=vector(length=S) # money supply\nG0=vector(length=S) # government spending\nP0=vector(length=S) # expected price level\nA=vector(length=S)  # Exogenous productivity\n\n### Construct different scenarios\n# baseline \nA[]=2  \ni0[]=2\nM0[]=5   \nG0[]=1   \nP0[]=1\n\n# scenario 2: fall in animal spirits\ni0[2]=1.5\n\n# scenario 3: increase in productivity\nA[3]=3\n\n# scenario 4: increase in expected price level\nP0[4]=1.5  \n   \n# scenario 5: monetary expansion \nM0[5]=6\n\n# scenario 6: fiscal expansion\nG0[6]=2  \n    \n#Set constant parameter values\nc0=2   # Autonomous consumption\nc1=0.6 # Sensitivity of consumption with respect to the income (marginal propensity to consume)\ni1=0.1 # Sensitivity of investment with respect to the interest rate\nm1=0.2 # Sensitivity of money demand with respect to income\nm2=0.4 # Sensitivity of money demand with respect to interest rate\nNf=5   # Full employment/labour force\nK=4    # Exogenous capital stock\na=0.3  # Capital elasticity of output\nb=0.4  # household preference for leisure\nT0=1   # tax revenues\nm0=6   # liquidity preference\n\n# Initialise endogenous variables at some arbitrary positive value \nY = C = I = r = P = w = N = W = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\n\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #Model equations\n    \n    # Goods market equilibrium\n    Y = C + I + G0[i]\n    \n    # Consumption demand\n    C = c0 + c1*(Y-T0)\n    \n    # Investment demand\n    I = i0[i] - i1*r\n    \n    # Money market, solved for interest rate\n    r = (m0 - (M0[i]/P))/m2 + m1*Y/m2\n    \n    #Unemployment rate\n    U = (1 - N/Nf)\n    \n    #Real wage \n    w = A[i]*(1-a)*(K^a)*N^(-a)\n    \n    #Nominal wage \n    W= (P0[i]*b*C)/(1- (N/Nf))\n    \n    #Price level \n    P = W/w\n    \n    #Employment \n    N = (Y/(A[i]*(K^a)))^(1/(1-a))\n\n}\n  \n  #Save results for different parameterisations in vector\n  Y_star[i]=Y\n  C_star[i]=C\n  I_star[i]=I\n  r_star[i]=r\n  N_star[i]=N\n  U_star[i]=U\n  P_star[i]=P\n  w_star[i]=w\n  W_star[i]=W\n\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions from different parameterizations\nY_star = np.empty(S)  # Income/output\nC_star = np.empty(S)  # Consumption\nI_star = np.empty(S)  # Investment\nr_star = np.empty(S)  # Real interest rate\nN_star = np.empty(S)  # Employment\nU_star = np.empty(S)  # Unemployment rate\nP_star = np.empty(S)  # Price level\nw_star = np.empty(S)  # Real wage\nW_star = np.empty(S)  # Nominal wage\n\n# Set exogenous variables that will be shifted\ni0 = np.zeros(S)  # Autonomous investment (animal spirits)\nM0 = np.zeros(S)  # Money supply\nG0 = np.zeros(S)  # Government spending\nP0 = np.zeros(S)  # Expected price level\nA = np.empty(S)  # Exogenous productivity\n\n# Construct different scenarios\n# baseline\nA[:] = 2\ni0[:] = 2\nM0[:] = 5\nG0[:] = 1\nP0[:] = 1\n\n# scenario 2: fall in animal spirits\ni0[1] = 1.5\n\n# scenario 3: increase in productivity\nA[2] = 3\n\n# scenario 4: increase in expected price level\nP0[3] = 1.5\n\n# scenario 5: monetary expansion\nM0[4] = 6\n\n# scenario 6: fiscal expansion\nG0[5] = 2\n\n# Set constant parameter values\nc0 = 2  # Autonomous consumption\nc1 = 0.6  # Sensitivity of consumption with respect to income (marginal propensity to consume)\ni1 = 0.1  # Sensitivity of investment with respect to the interest rate\nm1 = 0.2  # Sensitivity of money demand with respect to income\nm2 = 0.4  # Sensitivity of money demand with respect to interest rate\nNf = 5  # Full employment/labor force\nK = 4  # Exogenous capital stock\na = 0.3  # Capital elasticity of output\nb = 0.4  # Household preference for leisure\nT0 = 1  # Tax revenues\nm0 = 6  # Liquidity preference\n\n# Initialize endogenous variables at some arbitrary positive value\nY = C = I = r = P = w = N = W = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # Model equations\n\n        # Goods market equilibrium\n        Y = C + I + G0[i]\n\n        # Consumption demand\n        C = c0 + c1 * (Y - T0)\n\n        # Investment demand\n        I = i0[i] - i1 * r\n\n        # Money market, solved for interest rate\n        r = (m0 - (M0[i] / P)) / m2 + m1 * Y / m2\n\n        # Unemployment rate\n        U = 1 - N / Nf\n\n        # Real wage\n        w = A[i] * (1 - a) * (K ** a) * (N ** (-a))\n\n        # Nominal wage\n        W = (P0[i] * b * C) / (1 - (N / Nf))\n\n        # Price level\n        P = W / w\n\n        # Employment\n        N = (Y / (A[i] * (K ** a))) ** (1 / (1 - a))\n\n    # Save results for different parameterizations in the arrays\n    Y_star[i] = Y\n    C_star[i] = C\n    I_star[i] = I\n\n\n\n\nPlots\nFigures Figure 16.1 - Figure 5.5 depict the response of the model’s key endogenous variables to various shifts. A fall in animal spirits (scenario 2) reduces aggregate demand and thereby output and employment (despite a fall in the interest rate). This reduces workers’ nominal wage demands and thus the price level. An increase in productivity (scenario 3) has expansionary effects on output but adverse effects on employment. Higher productivity means that fewer workers need to be hired to produce the same level of output. However, the corresponding reduction in employment also reduces the price level, which lowers the (real) demand for money and thus lowers the interest rate. This has expansionary effects on output.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.1: Output\n\n\n\n\n\nbarplot(P_star, ylab=\"P\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.2: Price level\n\n\n\n\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.3: Interest rate\n\n\n\n\nA rise in the expected price level (scenario 4) raises nominal wages and thereby the actual price level. This raises the interest rate, which exerts a (small) contractionary effect on output and employment. Scenarios 5 and 6 assess two different macroeconomic policy tools to stimulate output. A monetary expansion lowers the interest rate and increases output but also the price level. Similar results arise for a fiscal expansion. The main difference is that the monetary expansion lowers the interest rate, whereas the fiscal expansion increases it. \\\n\nbarplot(U_star*100, ylab=\"U (%)\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                              \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.4: Unemployment rate\n\n\n\n\n\nbarplot(W_star, ylab=\"W\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.5: Nominal wage\n\n\n\n\n\nbarplot(w_star, ylab=\"w\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.6: Real wage\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for output) \nimport matplotlib.pyplot as plt\n   \nscenario_names = [\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                  \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"]\n\nplt.bar(scenario_names, Y_star)\nplt.ylabel('Y')\nplt.xticks(scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#directed-graph",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#directed-graph",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 15 variables: Y, C, I, G, T, r, w, W, P, M0, N, i0, A, P0, Md\n\nM_mat=matrix(c(0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,\n               0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,\n               0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,\n               0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,1,0,0,1,0,0,0,0,0,0), 15, 15, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(G[0]), expression(T[0]), \"r\", \"w\", \"W\", \"P\", expression(M[0]), \"N\", expression(i[0]), \"A\", expression(P[0]), expression(M[d]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 5.7: Directed graph of Neoclassical Synthesis model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the Jacobian matrix\nM_mat = np.array([\n    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n\n# Define node labels\nnodelabs = {\n    0: \"Y\",\n    1: \"C\",\n    2: \"I\",\n    3: r\"$G_0$\",\n    4: r\"$T_0$\",\n    5: \"r\",\n    6: \"w\",\n    7: \"W\",\n    8: \"P\",\n    9: r\"$M_0$\",\n    10: \"N\",\n    11: r\"$i_0$\",\n    12: \"A\",\n    13: r\"$P_0$\",\n    14: r\"$M_d$\",\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 5.7, it can be seen that productivity (\\(A\\)), taxes (\\(T_0\\)), government spending (\\(G_0\\)), animal spirits (\\(i_0\\)), the money supply (\\(M_0\\)), and the expected price level (\\(P_0\\)) are the key exogenous variables of the model. All other variables are endogenous and form a closed loop (or cycle) within the system. The lower-left part of the graph captures the goods market (IS): aggregate demand (consumption, investment, and government spending) determines output. The upper part of the graph contains the labour market, which determines the price level. Finally, the lower-right part of the graph represents the money market (LM), which determines the interest rate. There is a two-way feedback between the goods market and the money market as output impacts the demand for money, and the interest rate affects investment. There is also a feedback from output into the labour market through employment. The labour market feeds into the money market via its effect on prices and thus money demand, which then also feeds into the goods market through the interest rate.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#analytical-discussion",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#analytical-discussion",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nIn the first step, we will reduce the system to three equations: an IS-curve, an LM-curve, and an AS-curve (or Phillips curve). In the second step, the IS-curve and the LM-curve are combined to yield an AD-curve.\nTo obtain the IS-curve, substitute Equation 5.2 -Equation 5.3 into Equation 5.1 and solve for \\(Y\\): \\[\\begin{align}\\label{eq:IS-AS_AD}\\tag{IS}\nY&=\\left(\\frac{1}{1-c_1}\\right)(c_0 + i_0 + G_0 - i_1r - c_1 T_0).\n\\end{align}\\]\nTo obtain the LM-curve, substitute Equation 5.4 - Equation 5.5 into Equation 5.6 and solve for \\(r\\):\n\\[\\begin{align}\\label{eq:LM-AS_AD}\\tag{LM}\nr&=\\left(\\frac{1}{m_2}\\right)(m_0 - \\frac{M_0}{P} + m_1Y).\n\\end{align}\\]\nTo obtain the AS-curve, substitute Equation 5.7, Equation 5.8, Equation 5.10, and Equation 5.2 into Equation 5.9:\n\\[\\begin{align}\\label{eq:AS}\\tag{AS}\nP&=\\frac{b(c_0-c_1T_0)+ P^ebc_1Y}{(1-a)\\left[\\left(AK^aY^{-a}\\right)^{\\frac{1}{1-a}} - \\frac{Y}{N^f}\\right]}.\n\\end{align}\\]\nIt can readily be seen that the AS-curve is upward-sloping in the \\((Y, P)\\)-space (recall that \\(a \\in (0,1)\\)).\nFinally, to obtain the AD-curve, substitute the LM-equation into the IS-equation:\n\\[\\begin{align}\\tag{AD}\nY&=\\left[\\frac{m_2(c_0 + i_0 + G_0 - c_1 T_0) + i_1(\\frac{M_0}{P}-m_0)}{(1-c_1)m_2+i_1m_1}\\right]\n\\end{align}\\]\nIt can readily be seen that the AD-curve is downward-sloping in the \\((Y, P)\\)-space.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#references",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#references",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "References",
    "text": "References\n\n\n\n\nFroyen, Richard T. 2005. Macroeconomics. Theories and Policies. 8th Edition. Pearson Education.\n\n\nHicks, A. R. 1937. “Mr. Keynes and the \"Classics\": A Suggested Interpretation.” Econometrica 5 (2): 147. https://doi.org/10.2307/1907242.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#footnotes",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#footnotes",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "",
    "text": "See the notes on the Classical Model for a formal derivation of the labour demand and supply curves from optimisation. A minor modification is that here we work with a normalisation of the term for leisure in the household’s log-utility function, \\(\\ln(1-\\frac{N}{N^f})\\), to allow \\(N\\) to be larger than unity.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html",
    "title": "\n6  A Post-Keynesian Macro Model with Endogenous Money\n",
    "section": "",
    "text": "Overview\nPost-Keynesian Economics is an economic paradigm that was developed in the 1930s and 1940s by Joan Robinson, Nicholas Kaldor and others.1 The early post-Keynesian economists sought to develop further key ideas of John Maynard Keynes. They were critical of the Neoclassical Synthesis that introduced neoclassical elements into the Keynesian framework. Among many other points, post-Keynesians argued that money is created by commercial banks. Money creation is determined by the demand for credit rather than being under the control of the central bank, and should thus be considered endogenous. Post-Keynesians further assigned a key role to financial factors in the determination of economic activity, but also considered finance as a source of instability. They abandoned the neoclassical approach of deriving labour demand and supply from optimising behaviour and instead assumed oligopolistic market structures. Firms set prices by charging a mark-up on costs and workers set nominal wages based on their bargaining power.\nFontana and Setterfield (2009) present a simple model that could be regarded as a post-Keynesian alternative to the Neoclassical Synthesis. The model highlights the endogenous money creation process. Money is being created when commercial banks make loans to accommodate the demand for credit by creditworthy borrowers. The demand for credit is driven by aggregate demand. The interest rate on loans is determined by the base rate, set by the central bank, on which commercial banks charge a mark-up. Although credit creation is demand-driven, some borrowers will be credit constrained. In times of financial crises, banks tighten credit constraints, which can depress economic activity.\nIn this short-run model, prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is static. We consider a version of the model due to Fontana and Setterfield (2009) with linear functions.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#the-model",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#the-model",
    "title": "\n6  A Post-Keynesian Macro Model with Endogenous Money\n",
    "section": "The Model",
    "text": "The Model\n\\[\nY=ND+cD\n\\tag{6.1}\\]\n\\[\nND=bY, \\quad b \\in (0,1)\n\\tag{6.2}\\]\n\\[\nD= d_0 - d_1r, \\quad d_1 &gt; 0\n\\tag{6.3}\\]\n\\[\ni=i_0 + i_1P, \\quad i_1 &gt; 0\n\\tag{6.4}\\]\n\\[\nr=(1+m)i, \\quad m &gt; 0\n\\tag{6.5}\\]\n\\[\ndL=cD\n\\tag{6.6}\\]\n\\[\ndM=dL\n\\tag{6.7}\\]\n\\[\ndR=kdM, \\quad k \\in (0,1)\n\\tag{6.8}\\]\n\\[\nP=(1+n)aW, \\quad a,n &gt; 0\n\\tag{6.9}\\]\n\\[\nW=W_0 - hU, \\quad h &gt; 0\n\\tag{6.10}\\]\n\\[\nw=\\frac{1}{(1+n)a}\n\\tag{6.11}\\]\n\\[\nN=aY\n\\tag{6.12}\\]\n\\[\nU=1-\\frac{N}{N^f}\n\\tag{6.13}\\]\nwhere \\(Y\\), \\(ND\\), \\(D\\), \\(r\\), \\(i\\), \\(P\\), \\(dL\\), \\(dM\\), \\(dR\\), \\(W\\), \\(w\\), \\(N\\), \\(U\\), and \\(N^f\\) are output, the not debt-financed component of aggregate demand, the desired debt-financed component of aggregate demand, the lending rate, the policy rate, the price level, the change in loans, the change in money (bank deposits), the change in bank reserves, the nominal wage, the real wage, employment, the unemployment rate, and full employment (or total labour supply), respectively.\nEquation 6.1 is the goods market equilibrium condition. Aggregate supply (\\(Y\\)) accommodates to the level of aggregate demand which is the sum of a not debt-financed component (\\(ND\\)) and a (desired) debt-financed component (\\(D\\)). The coefficient \\(c\\) is the proportion of loan applications that are deemed creditworthy and thus captures credit rationing by banks. By Equation 6.2, the not debt-financed component of aggregate demand is a function of current income. In Equation 6.3, the debt-financed component of aggregate demand has an autonomous component (\\(d_0\\))2 and is otherwise negatively related to the lending rate \\(r\\). Equation 6.4 specifies the monetary policy rule, where it is assumed that the central bank raises the policy rate \\(i\\) when the price level increases.^[This specification is somewhat unrealistic given that most modern central banks target a positive rate of inflation. However, it allows for an AS-AD representation of the model, which facilitates the comparison with the Neoclassical Synthesis model (Chapter 5) The lending rate in Equation 6.5 is given by a mark-up \\(m\\) that banks charge on the policy rate (which is the rate at which they can borrow reserves). The change in loans in Equation 6.6 is equal to the creditworthy demand for loans (\\(cD\\)). This captures the demand-driven nature of credit creation. The changes in loans translates one-to-one into a change in money, which are bank deposits in this model (Equation 6.7). This reflects the endogenous money creation process where commercial banks create new deposits when they make new loans. By Equation 6.8, banks obtain new reserves from the central bank to maintain a constant reserve-to-deposit ratio \\(k\\). Thus, the causality in this model runs from debt-financed demand to loans, to deposits, and finally to reserves.\nBy Equation 6.9, the price level is set by firms based on a mark-up (\\(n\\)) on unit labour cost (which are the product of the nominal wage \\(W\\) and the labour coefficient \\(a\\)). Nominal wages are set by workers based on their bargaining power, which is declining in the unemployment rate (Equation 6.13). The real wage in Equation 6.11 is derived from the pricing Equation 6.9, i.e. through their price setting power, firms ultimately determine the real wage. The level of employment in Equation 6.12 is determined residually based on economic activity and a constant-coefficient production function \\((Y=\\frac{N}{a})\\). Finally, the level of employment in conjunction with an exogenously given labour force \\(N^f\\) (or total available labour time) can be used to obtain an unemployment rate in Equation 6.13.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#simulation",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#simulation",
    "title": "\n6  A Post-Keynesian Macro Model with Endogenous Money\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenario 2 is a rise in credit rationing in the form of a fall in \\(c\\). In scenario 3, autonomous credit-financed demand (\\(d_0\\)) increases. Scenarios 4 and 5 consider a rise in the interest rate (or bank) mark-up (\\(m\\)) and in the price (or firm) mark-up (\\(n\\)), respectively. Scenario 6 considers a rise in productivity reflected in a fall of the labour coefficient \\(a\\).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(b\\)\n\\(c\\)\n\\(d_0\\)\n\\(d_1\\)\n\\(i_0\\)\n\\(i1\\)\n\\(m\\)\n\\(k\\)\n\\(n\\)\n\\(W_0\\)\n\\(h\\)\n\\(a\\)\n\\(N^f\\)\n\n\n\n1: baseline\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n2: rise in credit rationing (\\(c\\))\n0.5\n0.4\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n3: rise in autonomous demand (\\(d_0\\))\n0.5\n0.8\n10\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n4: rise in bank mark-up (\\(m\\))\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.3\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n5: rise in firm mark-up (\\(n\\))\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.3\n2\n0.8\n0.8\n12\n\n\n6: rise in productivity (\\(a\\))\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.4\n12\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S)  # income/output\nD_star=vector(length=S)  # (notional) credit-financed aggregate demand\nND_star=vector(length=S) # income-financed aggregate demand\nr_star=vector(length=S)  # lending rate\nN_star=vector(length=S)  # employment\nU_star=vector(length=S)  # unemployment\nP_star=vector(length=S)  # price level\nw_star=vector(length=S)  # real wage\nW_star=vector(length=S)  # nominal wage\ni_star=vector(length=S)  # central bank rate\ndL_star=vector(length=S) # change in loans\ndM_star=vector(length=S) # change in bank deposits \ndR_star=vector(length=S) # change in bank reserves\n\n# Set exogenous variables that will be shifted\nc=vector(length=S) # share of credit demand that is accommodated\nd0=vector(length=S)# autonomous component of debt-financed aggregate demand\nm=vector(length=S) # mark-up on lending rate\nn=vector(length=S) # mark-up on prices\na=vector(length=S) # productivity\n\n# Baseline parameterisation\nc[]=0.8 \nd0[]=5\nm[]=0.15\nn[]=0.15  \na[]=0.8 \n\n## Construct scenarios\n\n# scenario 2: increase in credit rationing\nc[2]=0.4\n\n# scenario 3: increase in autonomous demand\nd0[3]=10\n\n# scenario 4: increase in interest rate mark-up\nm[4]=0.3\n\n# scenario 5: increase in price mark-up\nn[5]=0.3\n\n# scenario 6: increase in productivity\na[6]=0.4\n\n\n#Set constant parameter values\nb=0.5   # propensity to spend out of income\nd1=0.8  # sensitivity of demand with respect to the interest rate\ni0=0.01 # discretionary component of central bank rate\ni1=0.5  # sensitivity of central bank rate with respect to price level\nNf=12   # full employment/labour force\nh=0.8   # sensitivity of nominal wage with respect to unemployment\nk=0.3   # desired reserve ratio\nW0=2    # exogenous component of nominal wage\n\n# Initialise endogenous variables at some arbitrary positive value \nY = D = ND = r = N = U = P = w = W = i = dL = dR = dM = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (j in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #Model equations\n    \n    # (1) Goods market\n    Y = ND + c[j]*D\n    \n    # (2) Not-debt financed component of aggregate demand\n    ND = b*Y\n    \n    # (3) Debt-financed component of aggregate demand\n    D= d0[j] - d1*r\n    \n    # (4) Policy rate\n    i = i0 + i1*P\n    \n    # (5) Lending rate\n    r = (1+m[j])*i\n    \n    # (6) Change in loans\n    dL = c[j]*D\n    \n    # (7) Change in deposits\n    dM = dL\n    \n    # (8) Change in reserves\n    dR = k*dM\n    \n    # (9) Price level\n    P = (1+n[j])*a[j]*W\n    \n    # (10) Nominal wage\n    W = W0 - h*(U)\n    \n    # (11) Real wage\n    w = 1/((1+n[j])*a[j])\n    \n    # (12) Employment\n    N = a[j]*Y\n    \n    # (13) Unemployment rate\n    U = (Nf - N)/Nf\n    \n  }\n\n  #Save results for different parameterisations in vector\n  Y_star[j]=Y\n  D_star[j]=D\n  ND_star[j]=ND\n  r_star[j]=r\n  N_star[j]=N\n  U_star[j]=U\n  P_star[j]=P\n  w_star[j]=w\n  W_star[j]=W\n  i_star[j]=i\n  dL_star[j]=dL\n  dM_star[j]=dM\n  dR_star[j]=dR  \n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load NumPy library\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions\nY_star = np.zeros(S)  # income/output\nD_star = np.zeros(S)  # (notional) credit-financed aggregate demand\nND_star = np.zeros(S)  # income-financed aggregate demand\nr_star = np.zeros(S)  # lending rate\nN_star = np.zeros(S)  # employment\nU_star = np.zeros(S)  # unemployment\nP_star = np.zeros(S)  # price level\nw_star = np.zeros(S)  # real wage\nW_star = np.zeros(S)  # nominal wage\ni_star = np.zeros(S)  # central bank rate\ndL_star = np.zeros(S)  # change in loans\ndM_star = np.zeros(S)  # change in bank deposits\ndR_star = np.zeros(S)  # change in bank reserves\n\n# Set exogenous variables that will be shifted\nc = np.zeros(S)  # share of credit demand that is accommodated\nd0 = np.zeros(S)  # autonomous component of debt-financed aggregate demand\nm = np.zeros(S)  # mark-up on lending rate\nn = np.zeros(S)  # mark-up on prices\na = np.zeros(S)  # productivity\n\n# Baseline parameterisation\nc[:] = 0.8\nd0[:] = 5\nm[:] = 0.15\nn[:] = 0.15\na[:] = 0.8\n\n# Construct scenarios\n# Scenario 2: increase in credit rationing\nc[1] = 0.4\n\n# Scenario 3: increase in autonomous demand\nd0[2] = 10\n\n# Scenario 4: increase in interest rate mark-up\nm[3] = 0.3\n\n# Scenario 5: increase in price mark-up\nn[4] = 0.3\n\n# Scenario 6: increase in productivity\na[5] = 0.4\n\n# Set constant parameter values\nb = 0.5  # propensity to spend out of income\nd1 = 0.8  # sensitivity of demand with respect to the interest rate\ni0 = 0.01  # discretionary component of central bank rate\ni1 = 0.5  # sensitivity of central bank rate with respect to the price level\nNf = 12  # full employment/labour force\nh = 0.8  # sensitivity of nominal wage with respect to unemployment\nk = 0.3  # desired reserve ratio\nW0 = 2  # exogenous component of nominal wage\n\n# Initialize endogenous variables at some arbitrary positive value\nY = D = ND = r = N = U = P = w = W = i = dL = dR = dM = 1\n\n# Iterate through the system\nfor j in range(S):\n    for iteration in range(1000):\n        # Model equations\n        Y = ND + c[j] * D\n        ND = b * Y\n        D = d0[j] - d1 * r\n        i = i0 + i1 * P\n        r = (1 + m[j]) * i\n        dL = c[j] * D\n        dM = dL\n        dR = k * dM\n        P = (1 + n[j]) * a[j] * W\n        W = W0 - h * U\n        w = 1 / ((1 + n[j]) * a[j])\n        N = a[j] * Y\n        U = (Nf - N) / Nf\n\n    # Save results for different parameterizations in the vectors\n    Y_star[j] = Y\n    D_star[j] = D\n    ND_star[j] = ND\n    r_star[j] = r\n    N_star[j] = N\n    U_star[j] = U\n    P_star[j] = P\n    w_star[j] = w\n    W_star[j] = W\n    i_star[j] = i\n    dL_star[j] = dL\n    dM_star[j] = dM\n    dR_star[j] = dR\n\n\n\n\nPlots\nFigures Figure 6.1 - Figure 6.7 depict the response of the model’s key endogenous variables to various shifts.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.1: Output\n\n\n\n\nAn increase in credit rationing (scenario 2) reduces deposit money creation as well as actual (as opposed to desired) aggregate demand. This drags down output and employment. The rise in unemployment reduces workers’ nominal wage demands and thus the price level. The lending rate falls as the central bank reduces the policy rate.\n\nbarplot(P_star, ylab=\"P\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.2: Price level\n\n\n\n\nAn increase in (debt-financed) autonomous demand (scenario 3) has expansionary effects on output and employment. The money stock accommodates through increased loan creation. The increase in workers’ bargaining power leads to higher nominal wages and prices. The central bank reacts by raising the policy rate but this does not completely offset the expansionary effect.\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.3: Lending rate\n\n\n\n\n\nbarplot(dM_star, ylab=\"dM\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                        \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.4: Deposit money creation\n\n\n\n\nIn scenarios 4 and 5, the interest rate (or bank) mark-up and the price (or firm) mark-up increase, respectively. The increase in the bank mark-up raises the lending rate, which has a contractionary effect. The increase in the firm mark-up raises the price level, which has a contractionary effect through the monetary policy response. Notably, the rise in the price mark-up reduces the real wage.\n\nbarplot(U_star*100, ylab=\"U (%)\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                              \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.5: Unemployment rate\n\n\n\n\n\nbarplot(W_star, ylab=\"W\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.6: Nominal wage\n\n\n\n\nFinally, an increase in productivity (scenario 6) reduces the price level, which induces a lower policy rate, leading to a small expansionary effect. However, it increases the unemployment rate as fewer workers are needed to produce the same level of output. This reduces the nominal wage, but raises the real wage.\n\nbarplot(w_star, ylab=\"w\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.7: Real wage\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here for output only)\nimport matplotlib.pyplot as plt\n\nscenario_names = [\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\", \"4:rise bank markup\", \"5:rise firm markup\", \"6:rise product\"]\n\n# Create a bar plot\nplt.bar(scenario_names, Y_star)\nplt.ylabel(\"Y\")\nplt.xticks(rotation=45, ha=\"right\")  # Rotate x-axis labels for better readability\nplt.tight_layout()  # Ensure the labels fit within the plot area\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#directed-graph",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#directed-graph",
    "title": "\n6  A Post-Keynesian Macro Model with Endogenous Money\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph \n# Construct auxiliary Jacobian matrix for 18 variables: \n# r, Y, ND, D, i, P, W, w, N, U, dl, dM, dR, d0, c, m, a, n \n\nM_mat=matrix(c(0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,\n               0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n               0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,\n               0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,\n               0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,\n               0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n               0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n               0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0), 18, 18, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"Y\", \"ND\", \"D\", \"i\", \"P\", \"W\", \"w\", \"N\", \"U\", \"dL\", \"dM\", \"dR\", expression(d[0]), \"c\", \"m\", \"a\", \"n\")\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 6.8: Directed graph of post-Keynesian endogenous money model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Construct auxiliary Jacobian matrix for 18 variables\n#    r  Y ND  D  i  P  W  w  N  U  dL dM dR d0 c  m  a  n\n\nM_mat = np.array([[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0],\n               [0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0],\n               [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],\n               [0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],\n               [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],\n               [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\n               [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],\n               [0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])\n\n    \n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", 1: \"Y\", 2: \"ND\", 3: \"D\", 4: \"i\", 5:\"P\", 6: \"W\", 7: \"w\", \n            8: \"N\", 9: \"U\", 10: \"dL\", 11: \"dM\", 12: \"dR\", 13: \"d0\", 14: \"c\", \n            15: \"m\", 16: \"a\", 17: \"n\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=42)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure Figure 6.8, it can be seen that credit rationing (\\(c\\)), productivity (\\(a\\)), the price mark-up (\\(n\\)), the interest rate mark-up (\\(m\\)), and autonomous demand (\\(d_0\\)), are the key exogenous variables of the model. All other variables are endogenous, and many of them form a closed loop (or cycle) within the system. The lower-right part of the graph captures the goods market: debt- and not debt-financed aggregate demand determine output. The outer right part depicts the endogenous money creation process: creditworthy debt-financed demand determines credit creation, which translates into deposit money creation. Bank reserves are a residual. The lower-left part of the graph represents the labour market. The goods market feeds into the labour market via employment, which determines nominal wages and the price level. The real wage is a residual. The price level feeds into interest rate determination in the upper part of the model, which establishes a causal feedback link from the labour market to the goods market.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#analytical-discussion",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#analytical-discussion",
    "title": "\n6  A Post-Keynesian Macro Model with Endogenous Money\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nLike the Neoclassical Synthesis model, the post-Keynesian macro model can be represented as an AS-AD model. First, we will derive an IS and an interest-rate (IR) curve in the \\((Y, r)\\)-space, the latter representing monetary policy and bank lending instead of the money market (the conventional LM curve). Then we obtain the AS-AD representation of the model in the \\((Y,P)\\)-space. Finally, we obtain equilibrium solutions for \\(Y\\) and \\(P\\).\nTo obtain the IS-curve, substitute Equation 6.2 and Equation 6.3 into Equation 6.1 and solve for \\(Y\\): \\[\\begin{align}\\label{eq:IS}\\tag{IS}\nY&=\\left(\\frac{1}{1-b}\\right)\\Bigl[c(d_0 -d_1r)\\Bigr].\n\\end{align}\\]\nTo obtain the IR-curve, substitute Equation 6.4, Equation 6.9, Equation 6.10, Equation 6.12, and Equation 6.13 into Equation 6.5 : \\[\\begin{align}\\label{eq:IR}\\tag{IR}\nr&=\\left(1+m\\right)\\Bigl[i_0+i_1(1+n)a[W_0-h\\bigl(1-\\frac{aY}{N^f}\\bigr)]\\Bigr].\n\\end{align}\\]\nIt can readily be seen that the IS-curve is downward-sloping and the IR-curve is upward-sloping in the \\((Y, r)\\)-space\nTo obtain the AD-curve, substitute Equation 6.5 and Equation 6.4 into the IS-curve:\n\\[\\begin{align}\\label{eq:AD}\\tag{AD}\nY&=\\left(\\frac{1}{1-b}\\right)\\Bigl[c(d_0 -d_1(1+m)(i_0+i_1P))\\Bigr].\n\\end{align}\\]\nFinally, to obtain the AS-curve, substitute Equation 6.10 and Equation 6.13 into Equation 6.9:\n\\[\\begin{align}\\label{eq:AS}\\tag{AS}\nP&=\\left(1+n\\right)a\\Bigl[W_0-h\\bigl(1-\\frac{aY}{N^f}\\bigr)\\Bigr].\n\\end{align}\\]\nIt can readily be seen that the AD-curve is downward-sloping in the \\((Y, P)\\)-space, whereas the AS-curve is upward-sloping.\nFinally, by substituting the AS and AD curves into each other, we obtain the following equilibrium solutions for output and the price level:\n\\[\\begin{align*}\nY^*&=\\frac{c\\{d_0-d_1(1+m)[i_0+i_1(1+n)a(W_0-h)]\\}}{1-b+cd_1(1+m)i_1(1+n)a^2h(N^f)^{-1}} \\\\\nP^*&=\\frac{(1+n)a[(1-b)(W_0-h)+ha(N^f)^{-1}c(d_0-d_1(1+m)i_0)]}{1-b+cd_1(1+m)i_1(1+n)a^2h(N^f)^{-1}}.\n\\end{align*}\\]\nConfirm analytical solutions numerically\n\n### Confirm equilibrium solution for Y*  (baseline)\n# Analytical solution\n(c[1]*(d0[1] -d1*(1+m[1])*(i0+i1*(1+n[1])*a[1]*(W0-h))))/(1-b +c[1]*d1*(1+m[1])*i1*(1+n[1])*(a[1]^2)*h*(Nf^-1))\n\n[1] 6.922735\n\n# Numerical solution\nY_star[1]\n\n[1] 6.922735\n\n### Confirm equilibrium solution for P*  (baseline)\n# Analytical solution\n((1+n[1])*a[1]*((W0-h)*(1-b)+(Nf^-1)*h*a[1]*c[1]*(d0[1]-d1*(1+m[1])*i0[1])))/(1-b +c[1]*d1*(1+m[1])*i1*(1+n[1])*(a[1]^2)*h*(Nf^-1))\n\n[1] 1.443676\n\n# Numerical solution\nP_star[1]\n\n[1] 1.443676",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#references",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#references",
    "title": "\n6  A Post-Keynesian Macro Model with Endogenous Money\n",
    "section": "References",
    "text": "References\n\n\n\n\nFontana, Giuseppe, and Mark Setterfield. 2009. “A Simple (and Teachable) Macreconomic Model with Endogenous Money.” In Macroeconomic Theory and Macroeconomic Pedagogy, edited by Giuseppe Fontana and Mark Setterfield, 144–68. Basingstoke ; New York: Palgrave Macmillan.\n\n\nHein, Eckhard. 2014. Distribution and Growth After Keynes: A Post-Keynesian Guide. Cheltenham: Edward Elgar.\n\n\nLavoie, Marc. 2006. Introduction to Post-Keynesian Economics. Palgrave Macmillan.\n\n\n———. 2014. Post-Keynesian Economics: New Foundations. Cheltenham; Northampton, MA: Edward Elgar.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#footnotes",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#footnotes",
    "title": "\n6  A Post-Keynesian Macro Model with Endogenous Money\n",
    "section": "",
    "text": "See Lavoie (2006), chap.1 and Exploring Economics for introductions. Lavoie (2014) and Hein (2014) provide more advanced treatments.↩︎\nFor simplicity, it is assumed that all autonomous demand is debt-financed, i.e. there is no spending out of wealth.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html",
    "href": "a_Kaldor-Robinson_model.html",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "",
    "text": "Overview\nIn the 1950s and 1960s in Cambridge UK, Nicholas Kaldor and Joan Robinson developed a theory of growth that aimed to apply John Maynard Keynes’ principle of effective demand to the long run.1 The main Keynesian assumption retained by Kaldor and Robinson was that investment and saving are independent, and that a change in investment may lead to an adjustment in saving. However, unlike Keynes, Kaldor and Robinson assumed a fixed level of capacity utilisation, which they considered a key feature of a long-run equilibrium. As a result, goods market clearing cannot be established via output adjustment. Instead, Kaldor and Robinson assumed price adjustment, which would translate into a change in income distribution. Changes in the distribution of income then affect consumption (and saving), as workers tend to have a higher marginal propensity to consume than capital owners. For example, an increase in investment demand due to improved animal spirits would then lead to excess demand, which raises the price level. For a given level of nominal wages, the rise in the price level lowers real wages, leading to a redistribution of income towards profits. The resulting rise in the profit share increases aggregate saving, thereby leading to an adjustment of saving to investment. Taken together, the Kaldor-Robinson approach highlights the relevance of supply constraints in the long run that can lead to inflationary outcomes of demand shocks.\nWe consider a simple version of the model proposed in Hein (2014), chap. 4.4. This is a model of long-run steady state growth. In the steady state, all endogenous variables grow at the same rate.2 Changes in parameters or exogenous variables lead to an instantaneous adjustment of the model’s variables, so that the model can be analysed like a static one. The key question addressed by this model is a how changes in aggregate demand affects income distribution and the rate of growth.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#the-model",
    "href": "a_Kaldor-Robinson_model.html#the-model",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "The Model",
    "text": "The Model\n\\[\nr=h \\frac{u_n}{v}\n\\tag{7.1}\\]\n\\[\ns=s_\\Pi r,  \\quad  s_\\Pi \\in (0,1)\n\\tag{7.2}\\]\n\\[\nc= \\frac{u_n}{v}-s\n\\tag{7.3}\\]\n\\[\ng=g_0+g_1r, \\quad g_1 &gt; 0\n\\tag{7.4}\\]\n\\[\nh=\\frac{vg_0}{u_n(s_\\Pi-g_1)}\n\\tag{7.5}\\]\nwhere \\(r\\), \\(s\\), \\(c\\), \\(g\\), and \\(h\\) are the profit rate, the saving rate, the consumption rate, the investment rate, and the profit share, respectively.\nEquation 7.1 decomposes the profit rate into the product of the profit share \\(h\\) (total profits over total output), the normal rate of capacity utilisation (\\(u_n\\)), and the inverse of \\(v\\) (the capital-potential output ratio). Let \\(Y\\) be output, \\(K\\) be the capital stock, and \\(Y^P\\) be potential output, then the decomposition can also be written as \\(r=\\frac{\\Pi}{K}=\\frac{\\Pi}{Y}\\frac{Y}{Y^P}\\frac{Y^P}{K}\\). The normal rate of capacity utilisation and the capital-potential output ratio are taken to be exogenous in this model. Note also that the wage share is given by \\(1-h\\). By Equation 7.2, the economy-wide saving rate is given by saving out of profits (\\(s_\\Pi r\\)). It is assumed that workers don’t save, i.e. have a higher marginal propensity to consume than capital owners. Equation 7.3 simply states that consumption is income not saved. According to Equation 7.3, investment is determined by an autonomous component \\(g_0\\) that may capture Keynesian ‘animal spirits’ and by the profit rate. The profit rate may stimulate investment if firms use adaptive expectations and predict higher future profits in response to an increase in the current profit rate. Finally, Equation 7.5 is the goods market equilibrium condition \\(g=s\\) solved for the profit share, reflecting the fact that prices are assumed to clear the goods market which translates into an adjustment of the profit share.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#simulation",
    "href": "a_Kaldor-Robinson_model.html#simulation",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. We will consider three different parameterisations. Besides a baseline scenario (labelled as scenario 1), we will consider an increase in animal spirits (\\(g_0\\)) and an increase in the propensity to save out of profits (\\(s_\\Pi\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(v\\)\n\\(s_\\Pi\\)\n\\(g_0\\)\n\\(g_1\\)\n\\(u_n\\)\n\n\n\n1: baseline\n3\n0.6\n0.02\n0.3\n0.9\n\n\n2: rise in animal spirits (\\(g_0\\))\n3\n0.6\n0.04\n0.3\n0.9\n\n\n3: rise in saving propensity (\\(s_\\Pi\\))\n3\n0.9\n0.02\n0.3\n0.9\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baselines)\nS=3\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nh_star=vector(length=S) # profit share\ng_star=vector(length=S) # growth rate of capital stock\ns_star=vector(length=S) # saving rate\nc_star=vector(length=S) # consumption rate\nr_star=vector(length=S) # profit rate\n\n# Set constant parameter values\nv=3    # capital-to-potential output ratio\ng1=0.3 # sensitivity of investment with respect to profit rate \nun=0.9 # normal rate of capacity utilisation\n\n# Set exogenous variables whose parameterisation changes across regimes \ng0=vector(length=S) # animal spirits\nsp=vector(length=S) # propensity to save out of profits\n\n### Construct different scenarios \n\n# scenario 1: baseline \ng0[]=0.02\nsp[]=0.6\n\n#scenario 2: increase in animal spirits\ng0[2]=0.04\n\n# scenario 3: increase in propensity to save out of profits\nsp[3]=0.9\n\n#Check  stability condition for all scenarios\nfor (i in 1:S){\n  print(sp[i]&gt;g1)\n}\n\n[1] TRUE\n[1] TRUE\n[1] TRUE\n\n# Initialise endogenous variables at some arbitrary positive value \ng = r = s = c = h = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #(1) Profit rate\n    r=(h*un)/v\n    \n    #(2) Saving\n    s = sp[i]*r\n    \n    #(3) Consumption\n    c= un/v - s\n    \n    #(4) Investment\n    g = g0[i]+g1*r\n    \n    #(5) Goods market equilibrium profit share\n    h=(v/un)*(g0[i]/(sp[i]-g1))\n    \n  }\n  \n  #Save results for different parameterisations in vector\n  h_star[i]=h\n  g_star[i]=g\n  r_star[i]=r\n  s_star[i]=s\n  c_star[i]=c\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Clear the environment (not necessary in Python)\n# Set number of scenarios (including baselines)\nS = 3\n\n# Create arrays to store equilibrium solutions for different parameterizations\nh_star = np.empty(S)  # profit share\ng_star = np.empty(S)  # growth rate of capital stock\ns_star = np.empty(S)  # saving rate\nc_star = np.empty(S)  # consumption rate\nr_star = np.empty(S)  # profit rate\n\n# Set constant parameter values\nv = 3    # capital-to-potential output ratio\ng1 = 0.3  # sensitivity of investment with respect to profit rate \nun = 0.9  # normal rate of capacity utilization\n\n# Set exogenous variables whose parameterization changes across regimes\ng0 = np.empty(S)  # animal spirits\nsp = np.empty(S)  # propensity to save out of profits\n\n# Construct different scenarios\n# Scenario 1: baseline\ng0[:] = 0.02\nsp[:] = 0.6\n\n# Scenario 2: increase in animal spirits\ng0[1] = 0.04\n\n# Scenario 3: increase in propensity to save out of profits\nsp[2] = 0.9\n\n# Check stability condition for all scenarios\nfor i in range(S):\n    print(sp[i] &gt; g1)\n\n\n\n# Initialize endogenous variables at some arbitrary positive value\ng = r = s = c = h = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # (1) Profit rate\n        r = (h * un) / v\n\n        # (2) Saving\n        s = sp[i] * r\n\n        # (3) Consumption\n        c = un / v - s\n\n        # (4) Investment\n        g = g0[i] + g1 * r\n\n        # (5) Goods market equilibrium profit share\n        h = (v / un) * (g0[i] / (sp[i] - g1))\n\n    # Save results for different parameterizations in arrays\n    h_star[i] = h\n    g_star[i] = g\n    r_star[i] = r\n    s_star[i] = s\n    c_star[i] = c\n\n\n\n\nPlots\nFigures Figure 7.1 - Figure 7.3 depict the response of the model’s key endogenous variables to changes in aggregate demand. A rise in animal spirits (scenario 2) raises the profit share. This reduces consumption. However, the effect on capital accumulation and thus growth is positive. In that sense, long-run growth is demand-driven, despite the fixed rate of capacity utilisation.\n\nbarplot(h_star, ylab=\"h\", names.arg=c(\"1: baseline\", \"2: rise animal spirits\", \"3:rise savings propensity\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 7.1: Profit share\n\n\n\n\nIn the second scenario, the saving propensity of capital owners increases. This constitutes a reduction in aggregate demand, leading to a fall in the profit share, and a fall in the growth rate. Since \\(g=s\\), the effect reflects the Keynesian ‘paradox of saving’: a rise in the saving propensity leads to a fall in the aggregate saving rate.\n\nbarplot(c_star, ylab=\"c\", names.arg=c(\"1: baseline\", \"2: rise animal spirits\", \"3:rise savings propensity\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 7.2: Rate of consumption\n\n\n\n\n\nbarplot(g_star, ylab=\"g\", names.arg=c(\"1: baseline\", \"2: rise animal spirits\", \"3:rise savings propensity\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 7.3: Rate of growth\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for profit share) \nimport matplotlib.pyplot as plt\n\n# Scenario labels\nscenario_names = [\"1: baseline\", \"2: rise animal spirits\", \"3: rise savings propensity\"]\n\n# Bar plot for h_star\nplt.bar(scenario_names, h_star)\nplt.ylabel('h')\nplt.xticks(scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#directed-graph",
    "href": "a_Kaldor-Robinson_model.html#directed-graph",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph \n# Construct auxiliary Jacobian matrix for 7 variables: \n             # r,h,s,g,g0,sp,un\nM_mat=matrix(c(0,1,0,0,0, 0, 1,\n               0,0,1,1,0, 0, 1,\n               1,0,0,0,0, 1, 0,\n               1,0,0,0,1, 0, 0,\n               0,0,0,0,0, 0, 0,\n               0,0,0,0,0, 0, 0,\n               0,0,0,0,0, 0, 0), 7, 7, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"h\", \"s\", \"g\", expression(g[0]), expression(s[Pi]), expression(u[n]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 7.4: Directed graph of Kaldor-Robinson growth model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the Jacobian matrix\nM_mat = np.array([[0, 1, 0, 0, 0, 0, 1],\n                  [0, 0, 1, 1, 0, 0, 1],\n                  [1, 0, 0, 0, 0, 1, 0],\n                  [1, 0, 0, 0, 1, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", 1: \"h\", 2: \"s\", 3: \"g\", 4: r\"$g_0$\", 5: r\"$s_p$\", 6: r\"$u_n$\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure Figure 7.4, it can be seen that animal spirits (\\(g_0\\)), the propensity to save out of profits (\\(s_\\Pi\\)), and the normal rate of capacity utilisation (\\(u_n\\)) are the key exogenous variable of the model. Saving (\\(s\\)), investment (\\(g\\)), the rate of profit (\\(r\\)), and the profit share (\\(h\\)) are endogenous and form a closed loop (or cycle) within the system.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#analytical-discussion",
    "href": "a_Kaldor-Robinson_model.html#analytical-discussion",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the equilibrium solution for the profit share (Equation 7.5), substitute Equation 7.1, Equation 7.4 and Equation 7.2 and into \\(g=s\\) and solve for \\(h\\).\nThe equilibrium solution for \\(h\\) can then be substituted into Equation 7.1 to find: \\[\\begin{align}\nr^* = \\frac{g_0}{s_\\Pi-g_1}\n\\end{align}\\]\nSimilarly, substituting the equilibrium solution for \\(r\\) into Equation 7.4 yields: \\[\\begin{align}\ng^* = \\frac{s_\\Pi g_0}{s_\\Pi-g_1}.\n\\end{align}\\]\nThe Kaldor-Robinson stability condition requires \\(s_\\Pi-g_1&gt;0\\), i.e. saving needs to react more strongly to the profit rate than investment.\nFurther analytical results can be found in Hein (2014), chap. 4.4.\nCalculate analytical solutions numerically\n\n# Profit rate\nfor (i in 1:S){\n  print((g0[i])/(sp[i]-g1))\n}\n\n[1] 0.06666667\n[1] 0.1333333\n[1] 0.03333333\n\n# Growth rate\nfor (i in 1:S){\n  print((sp[i]*g0[i])/(sp[i]-g1))\n}\n\n[1] 0.04\n[1] 0.08\n[1] 0.03\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Profit rate\nfor i in range(S):\n    print(g0[i] / (sp[i] - g1))\n\n# Growth rate\nfor i in range(S):\n    print((sp[i] * g0[i]) / (sp[i] - g1))",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#references",
    "href": "a_Kaldor-Robinson_model.html#references",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nHein, Eckhard. 2014. Distribution and Growth After Keynes: A Post-Keynesian Guide. Cheltenham: Edward Elgar.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#footnotes",
    "href": "a_Kaldor-Robinson_model.html#footnotes",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "",
    "text": "See Hein (2014), chap. 4 for a detailed treatment.↩︎\nAll variables are normalised by the capital stock and thus rendered stationary.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html",
    "href": "a_post_kaleckian_distribution_and_growth_model.html",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "",
    "text": "Overview\nThe post-Kaleckian growth model was developed by Bhaduri and Marglin (1990) and others to synthesise Marxian and Keynesian ideas about the effects of income distribution on economic growth.1 According to the Marxian view, capital accumulation is driven by profits. By contrast, Michal Kalecki and post-Keynesians such as Nicholas Kaldor argued that a redistribution of income towards profit-earners is likely to reduce consumption, as workers tend to have a higher marginal propensity to consume than capital owners. The post-Kaleckian growth model integrates these two mechanisms in a Keynesian framework in which aggregate demand and growth are demand-determined. It allows for wage-led as well as profit-led demand and growth regimes. In a wage-led regime, a redistribution of income towards workers has expansionary effects on aggregate demand (and possibly growth) as the expansionary effect on consumption outweighs the negative effect on investment. In a profit-led regime, the effect is contradictory as investment falls by more than consumption rises. Whether a regime is wage- or profit-led depends on the relative size of the propensities to consume and the propensity to invest.\nThis is a model of long-run steady state growth. In the steady state, all endogenous variables grow at the same rate.2 Changes in parameters or exogenous variables lead to an instantaneous adjustment of the model’s variables, so that the model can be analysed like a static one. We consider a version of the model with linear functions based on Hein (2014), chap. 7.2.2.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#the-model",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#the-model",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "The Model",
    "text": "The Model\n\\[\nr=h \\frac{u}{v}\n\\tag{8.1}\\]\n\\[\ns=[s_W + (s_\\Pi - s_W)h]\\frac{u}{v}, \\quad 0 \\geq s_W &gt; s_\\Pi \\geq 1\n\\tag{8.2}\\]\n\\[\nc= \\frac{u}{v}-s\n\\tag{8.3}\\]\n\\[\ng=g_0+g_1u+g_2h, \\quad g_i &gt; 0\n\\tag{8.4}\\]\n\\[\nu=v(c+g)\n\\tag{8.5}\\]\nwhere \\(r\\), \\(s\\), \\(c\\), \\(g\\), and \\(u\\) are the profit rate, the saving rate, the consumption rate, the investment rate, and the rate of capacity utilisation, respectively.\nEquation 8.1 decomposes the profit rate into the product of the profit share \\(h\\) (total profits over total output), the rate of capacity utilisation (actual output over potential output), and the inverse of \\(v\\) (the capital-potential output ratio). Let \\(Y\\) be output, \\(K\\) be the capital stock, and \\(Y^P\\) be potential output, the decomposition can also be written as \\(r=\\frac{\\Pi}{K}=\\frac{\\Pi}{Y}\\frac{Y}{Y^P}\\frac{Y^P}{K}\\). The profit share and the capital-potential output ratio are taken to be exogenous in this model. Note also that the wage share is given by \\(1-h\\). By Equation 8.2, the economy-wide saving rate is given by the sum of saving out of wages (\\(s_W(1-h)\\frac{u}{v}\\)) and saving out of profits (\\(s_\\Pi h\\frac{u}{v}\\)). It is assumed that workers have a higher marginal propensity to consume than capital owners (\\(s_W&gt;s_\\Pi\\)). Equation 8.3 simply states that consumption is income not saved. According to Equation 8.3, investment is determined by an autonomous component \\(g_0\\) that may capture Keynesian `animal spirits’, by the rate of capacity utilisation, and by the profit share. While the rate of capacity utilisation is a signal of (future) demand, the profit share may stimulate investment as internal funds are typically the cheapest source of finance. Finally, Equation 8.5 is an equilibrium condition that assumes that the rate of capacity utilisation adjusts to clear the goods market.\nThe key question addressed by this model is a how a change in the profit share affects the rate of capacity utilisation and the rate of growth.3 As shown formally in the analytical discussion below, there is no unambiguous answer to this question as the model encompasses different regimes. Three main regimes can be identified. First, a regime in which both the rate of utilisation and the rate of growth are negatively affected by an increase in the profit share. We will call this a wage-led demand and growth regime (WLD/WLG). Second, a regime in which the rate of utilisation is negatively affected and the rate of growth is positively affected by an increase in the profit share. We will call this a wage-led demand regime and profit-led growth regime (WLD/PLG). Third, a regime in which both the rate of utilisation and the rate of growth are positively affected by an increase in the profit share. We will call this a profit-led demand and growth regime (PLD/PLG).",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#simulation",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#simulation",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. We will consider three different parameterisations that represent the three regimes outlined above. For each of these regimes, there is a baseline scenario and a scenario in which the profit share (\\(h\\)) rises. This allows to assess the effects on the model’s endogenous variables for the different regimes.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(v\\)\n\\(s_W\\)\n\\(s_\\Pi\\)\n\\(g_0\\)\n\\(g_1\\)\n\\(g_2\\)\n\\(h\\)\n\n\n\n1a: baseline WLD/WLG\n3\n0.3\n0.9\n0.02\n0.1\n0.1\n0.2\n\n\n1b: rise in profit share (\\(h\\))\n3\n0.3\n0.9\n0.02\n0.1\n0.1\n0.3\n\n\n2a: baseline WLD/PLG\n3\n0.3\n0.9\n0.02\n0.08\n0.1\n0.2\n\n\n2b: rise in profit share (\\(h\\))\n3\n0.3\n0.9\n0.02\n0.08\n0.1\n0.3\n\n\n3a: baseline PLD/PLG\n3\n0.3\n0.9\n-0.01\n0.1\n0.1\n0.2\n\n\n3b: rise in profit share (\\(h\\))\n3\n0.3\n0.9\n-0.01\n0.1\n0.1\n0.3\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baselines)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nu_star=vector(length=S) # utilisation rate\ng_star=vector(length=S) # growth rate of capital stock\ns_star=vector(length=S) # saving rate\nc_star=vector(length=S) # consumption rate\nr_star=vector(length=S) # profit rate\n\n# Set exogenous variables whose parameterisation changes across regimes \ng0=vector(length=S) # animal spirits\nsw=vector(length=S) # propensity to save out of wages \nh=vector(length=S)  # profit share\ng1=vector(length=S) # sensitivity of investment with respect to utilisation\n\n### Construct different scenarios across 3 regimes: (1) WLD/WLG, (2) WLD/PLG, (3) PLD/PLG \n\n# baseline WLD/WLG\ng0[1]=0.02\ng1[1]=0.1\nh[1]=0.2\n\n# increase in profit share in WLD/WLG regime\ng0[2]=0.02\ng1[2]=0.1\nh[2]=0.3\n\n# baseline WLD/PLG\ng0[3]=0.02\ng1[3]=0.08\nh[3]=0.2\n\n# increase in profit share in WLD/PLG regime\ng0[4]=0.02\ng1[4]=0.08\nh[4]=0.3\n  \n# baseline PLD/PLG\ng0[5]=-0.01\ng1[5]=0.1\nh[5]=0.2\n\n# increase in profit share in PLD/PLG regime\ng0[6]=-0.01\ng1[6]=0.1\nh[6]=0.3\n\n#Set constant parameter values\nv=3    # capital-to-potential output ratio\ng2=0.1 # sensitivity of investment with respect to profit share\nsp=0.9 # propensity to save out of profits\nsw=0.3 # propensity to save out of wages\n\n#Check Keynesian stability condition for all scenarios\nfor (i in 1:S){\nprint(((sw+(sp-sw)*h[i])*(1/v) -g1[i])&gt;0)\n}\n\n[1] TRUE\n[1] TRUE\n[1] TRUE\n[1] TRUE\n[1] TRUE\n[1] TRUE\n\n# Check demand and growth regime for 3 baseline scenarios\nfor (i in c(1,3,5)){\nprint(paste(\"Parameterisation\", i, \"yields:\"))   \nif(g2*(sw/v - g1[i])-g0[i]*(sp-sw)/v&lt;0){\n  print(\"wage-led demand regime\")\n  } else{\n   print(\"profit-led demand regime\")\n  }\nif(g1[i]*(g2*(sw/v - g1[i])-g0[i]*(sp-sw)/v)+g2*(((sw+(sp-sw)*h[i])*v^(-1)-g1[i])^2)&lt;0){\n  print(\"wage-led growth regime\")\n  } else{\n  print(\"profit-led growth regime\")\n  }  \n} \n\n[1] \"Parameterisation 1 yields:\"\n[1] \"wage-led demand regime\"\n[1] \"wage-led growth regime\"\n[1] \"Parameterisation 3 yields:\"\n[1] \"wage-led demand regime\"\n[1] \"profit-led growth regime\"\n[1] \"Parameterisation 5 yields:\"\n[1] \"profit-led demand regime\"\n[1] \"profit-led growth regime\"\n\n# Initialise endogenous variables at some arbitrary positive value \ng=1\nr=1\nc=1\nu=1\ns=1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #(1) Profit rate\n    r = (h[i]*u)/v\n    \n    #(2) Saving\n    s = (sw+(sp-sw)*h[i])*(u/v)\n    \n    #(3) Consumption\n    c= u/v-s\n    \n    #(4) Investment\n    g = g0[i]+g1[i]*u+g2*h[i]\n    \n    #(5) Rate of capacity utilisation\n    u = v*(c+g)\n  }\n  \n  #Save results for different parameterisations in vector\n  u_star[i]=u\n  g_star[i]=g\n  r_star[i]=r\n  s_star[i]=s\n  c_star[i]=c\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of scenarios (including baselines)\nS = 6\n\n# Create arrays to store equilibrium solutions for different parameterizations\nu_star = np.zeros(S)\ng_star = np.zeros(S)\ns_star = np.zeros(S)\nc_star = np.zeros(S)\nr_star = np.zeros(S)\n\n# Set exogenous variables whose parameterization changes across regimes\ng0 = np.zeros(S)\nsw = np.zeros(S)\nh = np.zeros(S)\ng1 = np.zeros(S)\n\n# Construct different scenarios across 3 regimes\n# Regime 1: WLD/WLG\ng0[0] = 0.02\ng1[0] = 0.1\nh[0] = 0.2\n\n# Regime 2: Increase in profit share in WLD/WLG regime\ng0[1] = 0.02\ng1[1] = 0.1\nh[1] = 0.3\n\n# Regime 3: WLD/PLG\ng0[2] = 0.02\ng1[2] = 0.08\nh[2] = 0.2\n\n# Regime 4: Increase in profit share in WLD/PLG regime\ng0[3] = 0.02\ng1[3] = 0.08\nh[3] = 0.3\n\n# Regime 5: PLD/PLG\ng0[4] = -0.01\ng1[4] = 0.1\nh[4] = 0.2\n\n# Regime 6: Increase in profit share in PLD/PLG regime\ng0[5] = -0.01\ng1[5] = 0.1\nh[5] = 0.3\n\n# Set constant parameter values\nv = 3    # capital-to-potential output ratio\ng2 = 0.1 # sensitivity of investment with respect to profit share\nsp = 0.9 # propensity to save out of profits\nsw = 0.3 # propensity to save out of wages\n\n# Check Keynesian stability condition for all scenarios\nfor i in range(S):\n    print(((sw + (sp - sw) * h[i]) * (1 / v) - g1[i]) &gt; 0)\n    \n# Check demand and growth regime for 3 baseline scenarios\nfor i in [0, 2, 4]:\n    print(f\"Parameterization {i+1} yields:\")\n    \n    # Check demand regime\n    if g2 * (sw / v - g1[i]) - g0[i] * (sp - sw) / v &lt; 0:\n        print(\"Wage-led demand regime\")\n    else:\n        print(\"Profit-led demand regime\")\n    \n    # Check growth regime\n    if g1[i] * (g2 * (sw / v - g1[i]) - g0[i] * (sp - sw) / v) + g2 * (((sw + (sp - sw) * h[i]) * v**(-1) - g1[i])**2) &lt; 0:\n        print(\"Wage-led growth regime\")\n    else:\n        print(\"Profit-led growth regime\")\n\n# Initialize endogenous variables at an arbitrary positive value\ng = r = c = u = s = 1\n\n# Solve the system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # (1) Profit rate\n        r = (h[i] * u) / v\n\n        # (2) Saving\n        s = (sw + (sp - sw) * h[i]) * (u / v)\n\n        # (3) Consumption\n        c = u / v - s\n\n        # (4) Investment\n        g = g0[i] + g1[i] * u + g2 * h[i]\n\n        # (5) Rate of capacity utilization\n        u = v * (c + g)\n\n    # Save results for different parameterizations in vectors\n    u_star[i] = u\n    g_star[i] = g\n    r_star[i] = r\n    s_star[i] = s\n    c_star[i] = c\n\n\n\n\nPlots\nFigures Figure 8.1 - Figure 8.4 depict the response of the model’s key endogenous variables to changes in the profit share. In the first case of a wage-led demand and growth regime (WLD/WLG), investment is equally sensitive to a change in the rate of capacity utilisation (\\(g_1\\)) and a change in the profit share (\\(g_2\\)). A rise in the profit share reduces consumption, which reduces the rate of capacity utilisation and the rate of growth. This is despite a positive effect on the profit rate.4\n\nbarplot(u_star, ylab=\"u\", names.arg=c(\"1a:baseline WLD/WLG\", \"1b:rise prof share\", \"2a:baseline WLD/PLG\", \"2b:rise prof share\", \"3a:baseline PLD/PLG\", \"3b: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.1: Rate of capacity utilisation\n\n\n\n\nIn the second case where the demand regime is wage-led but the growth regime is profit-led (WLD/PLG), investment is slightly less sensitive to a change in the rate of capacity utilisation compared to a change in the profit share. The rise in the profit share reduces consumption and the rate of utilisation, but the ultimate effect on investment is positive because investment reacts more strongly to the rise in the profit share than to the fall in demand.\n\nbarplot(g_star, ylab=\"g\", names.arg=c(\"1:baseline WLD/WLG\", \"2:rise prof share\", \"3:baseline WLD/PLG\",\n                                      \"4:rise prof share\", \n                                      \"5:baseline PLD/PLG\", \"6: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.2: Rate of growth\n\n\n\n\nFinally, in the third case where the demand regime and the growth regime are profit-led, investment is again equally sensitive to a change in the rate of capacity utilisation and to a change in the profit share, but now animal spirits are negative. A rise in the profit share now has strong positive effects on investment, which raises the rate of capacity utilisation and consumption.\n\nbarplot(c_star, ylab=\"c\", names.arg=c(\"1:baseline WLD/WLG\", \"2:rise prof share\", \"3:baseline WLD/PLG\",\n                                      \"4:rise prof share\", \n                                      \"5:baseline PLD/PLG\", \"6: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.3: Rate of consumption\n\n\n\n\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:baseline WLD/WLG\", \"2:rise prof share\", \"3:baseline WLD/PLG\",\n                                     \"4:rise prof share\", \n                                     \"5:baseline PLD/PLG\", \"6: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.4: Rate of profit\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for rate of capacity utilisation) \nimport matplotlib.pyplot as plt    \n\n# Scenario labels\nscenario_names = [\"1a: baseline WLD/WLG\", \"1b: rise prof share\", \"2a: baseline WLD/PLG\", \"2b: rise prof share\", \"3a: baseline PLD/PLG\", \"3b: rise prof share\"]\n\n# Bar plot for u_star\nplt.bar(scenario_names, u_star)\nplt.ylabel('u')\nplt.xticks(scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#directed-graph",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#directed-graph",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph \n# Construct auxiliary Jacobian matrix for 6 variables: \n# r, h, u, s, c, g\n\nM_mat=matrix(c(0,1,1,0,0,0,\n               0,0,0,0,0,0,\n               0,0,0,0,1,1,\n               0,1,1,0,0,0,\n               0,0,1,1,0,0,\n               0,1,1,0,0,0), 6, 6, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create and plot directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"h\", \"u\", \"s\", \"c\", \"g\")\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 8.5: Directed graph of post-Kaleckian growth model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the Jacobian matrix\nM_mat = np.array([[0,1,1,0,0,0],\n                  [0,0,0,0,0,0],\n                  [0,0,0,0,1,1],\n                  [0,1,1,0,0,0],\n                  [0,0,1,1,0,0],\n                  [0,1,1,0,0,0],\n                 ])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", 1: \"h\", 2: \"u\", 3: \"s\", 4: \"c\", 5: \"g\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure Figure 8.5, it can be seen that the profit share (\\(h\\)) is the key exogenous variable of the model.5 Consumption (\\(c\\)), saving (\\(s\\)), investment (\\(g\\)), and the rate of utilisation (\\(u\\)) form a closed loop (or cycle) within the system. The profit share affects both saving and investment, which in turn affect consumption and the rate of capacity utilisation. The profit rate is a residual variable (also called a `sink’) in this model.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#analytical-discussion",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#analytical-discussion",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the equilibrium solutions, substitute Equation 8.2 - Equation 8.4 into Equation 8.5 and solve for \\(u\\): \\[\\begin{align}\nu^* = \\frac{g_0+g_2h}{[s_W + (s_\\Pi - s_W)h]v^{-1}-g_1}.\n\\end{align}\\]\nThe equilibrium solution for \\(u\\) can then be substituted into Equation 8.4 to find: \\[\\begin{align}\ng^* = \\frac{(g_0+g_2h)[s_W + (s_\\Pi - s_W)h]v^{-1}}{[s_W + (s_\\Pi - s_W)h]v^{-1}-g_1}.\n\\end{align}\\]\nThe Keynesian stability condition requires \\([s_W + (s_\\Pi - s_W)h]v^{-1}-g_1&gt;0\\), i.e. saving need to react more strongly to income than investment.\nThe equilibrium solution for \\(r\\) can be found by substituting \\(u^*\\) into Equation 8.1: \\[\\begin{align}\nr^* = \\frac{h(g_0+g_2h)}{[s_W + (s_\\Pi - s_W)h]-vg_1}.\n\\end{align}\\]\nTo assess whether the demand regime is wage- or profit-led, take the derivative of \\(u^*\\) with respect to \\(h\\): \\[\\begin{align}\n\\frac{\\partial u^*}{\\partial h} = \\frac{\\frac{s_W}{v}(g_0+g_2 )-(g_0\\frac{s_\\Pi}{v} + g_1g_2)}{[[s_W + (s_\\Pi - s_W)h]v^{-1}-g_1]^2}.\n\\end{align}\\]\nIt can be seen that, e.g., a higher propensity to save out of wages or negative animal spirits make the regime more likely to be profit-led.\nBy the same token, the sign of the derivative of \\(g^*\\) with respect to \\(h\\) determines whether the growth regime is wage- or profit-led: \\[\\begin{align}\n\\frac{\\partial g^*}{\\partial h} = g_1\\frac{\\partial u^*}{\\partial h}+g_2.\n\\end{align}\\]\nIt can be seen that, e.g., a higher sensitivity of investment with respect to the profit share makes the regime more likely to be profit-led.\nFinally, the effect on the profit rate will depend on the sign of the derivative: \\[\\begin{align}\n\\frac{\\partial r^*}{\\partial h} = \\frac{u^*}{v} + \\frac{h}{v}\\frac{\\partial u^*}{\\partial h},\n\\end{align}\\]\nwhich is likely to be positive but can become negative if the demand regime is strongly wage-led.\nCalculate analytical solutions numerically\n\n# Utilisation rate\nfor (i in 1:S){\nprint((g0[i]+g2*h[i])/((sw+(sp-sw)*h[i])/v-g1[i]))\n}\n\n[1] 1\n[1] 0.8333333\n[1] 0.6666667\n[1] 0.625\n[1] 0.25\n[1] 0.3333333\n\n# Growth rate\nfor (i in 1:S){\n  print(((g0[i]+g2*h[i])*(sw+(sp-sw)*h[i])/v)/((sw+(sp-sw)*h[i])/v-g1[i]))\n}\n\n[1] 0.14\n[1] 0.1333333\n[1] 0.09333333\n[1] 0.1\n[1] 0.035\n[1] 0.05333333\n\n# Profit rate\nfor (i in 1:S){\n  print((g0[i]+g2*h[i])*(h[i]/v)/((sw+(sp-sw)*h[i])/v-g1[i]))\n}\n\n[1] 0.06666667\n[1] 0.08333333\n[1] 0.04444444\n[1] 0.0625\n[1] 0.01666667\n[1] 0.03333333\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Utilisation rate\nfor i in range(S):\n    print((g0[i]+g2*h[i])/((sw+(sp-sw)*h[i])/v-g1[i]))\n\n# Growth rate\nfor i in range(S):\n    print(((g0[i]+g2*h[i])*(sw+(sp-sw)*h[i])/v)/((sw+(sp-sw)*h[i])/v-g1[i]))\n    \n# Profit rate\nfor i in range(S):\n    print((g0[i]+g2*h[i])*(h[i]/v)/((sw+(sp-sw)*h[i])/v-g1[i]))",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#references",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#references",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nBhaduri, Amit, and Stephen Marglin. 1990. “Unemployment and the Real Wage: The Economic Basis for Contesting Political Ideologies.” Cambridge Journal of Economics 14 (4): 375–93.\n\n\nHein, Eckhard. 2014. Distribution and Growth After Keynes: A Post-Keynesian Guide. Cheltenham: Edward Elgar.\n\n\nLavoie, Marc. 2014. Post-Keynesian Economics: New Foundations. Cheltenham; Northampton, MA: Edward Elgar.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#footnotes",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#footnotes",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "",
    "text": "See Hein (2014), chap. 7 and Lavoie (2014), chap. 6 for detailed treatments.↩︎\nAll variables are normalised by the capital stock and thus rendered stationary.↩︎\nBhaduri and Marglin (1990) further discuss the effects on the profit rate.↩︎\nIf the negative effect on the rate of capacity utilisation was stronger, the profit rate could fall as well. See the analytical discussion for a formal derivation of the condition under which this may happen.↩︎\nOther important exogenous variables or parameters that may shift but are not depicted here are animal spirits (\\(g_0\\)) or the saving propensities (\\(s_W, s_\\Pi\\)). See Hein (2014), chap. 7.2.2, for a detailed discussion of their effects.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html",
    "href": "intro_stability_analysis.html",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "",
    "text": "Solution of a single first-order linear difference equation\nConsider a first-order linear difference equation:1\n\\[\ny_t = a_0 + a_1y_{t-1}.\n\\]\nOne way to find a solution is through (manual) iteration:\n\\[y_0,\\] \\[y_1 = a_0 + a_1 y_0,\\] \\[y_2 = a_0 + a_1(a_0 + a_1 y_0) = a_0(a_1+1) + a_1^2y_0 ,\\] \\[y_3 = a_0 + a_1[a_0 + a_1(a_0 +a_1y_0)]= a_0(a_1^2+a_1+1) + a_1^3y_0\\] \\[...,\\] \\[y_t = a_0\\sum^{t-1}_{i=0} a_1^i + a_1^ty_0 \\]\nThis is effectively the same approach we have used before to solve economic models via simulation.\nIf \\(a_1\\neq1\\), the term \\(a_0\\sum^{t-1}_{i=0} a_1^i\\) is a convergent geometric series:\n\\[a_0\\sum^{t-1}_{i=0} a_1^i= a_0\\frac{(1-a_1^t)}{1-a_1}.\\]\nThus, the solution thus takes the form:\n\\[\ny_t = \\frac{a_0(1-a_1^t)}{1-a_1} + a_1^ty_0 =\\frac{a_0}{1-a_1} + a_1^t\\left(y_0 - \\frac{a_0}{1-a_1}\\right).\n\\]\nFrom iteration, we thus know that the solution to a difference equation has two parts:\n\\[\ny_t = \\underbrace{\\frac{a_0}{1-a_1}}_{equilibrium \\: y^*} + \\underbrace{a_1^t\\left(y_0 - \\frac{a_0}{1-a_1}\\right)}_{dynamics}.\n\\]\nThe complementary function tells us about the ‘asymptotic stability’ of the equation: does \\(y_t\\) converge to \\(y^*\\) as \\(t \\rightarrow \\infty\\)?\nFor the case of a first-order difference equation, we can distinguish the following cases:\nTo better understand the last two cases, note that if \\(a_1=1\\), a different (more general) approach to finding the particular solution is required: the so-called method of undetermined coefficients. This method consists of substituting a trial solution that contains undetermined coefficients into the difference equation and then attempting to solve for those coefficients. If the trial solution allows to pin down unique values for the coefficients, it constitute a valid particular solution.\nIn the case above where \\(a_1 \\neq 1\\), we could have used the trial solution \\(y_t=y_{t-1}=y^*\\) and then solve for \\(y\\) to obtain \\(\\frac{a_0}{1-a}\\) as the particular solution. In the case where \\(a_1=1\\) and \\(a_0 \\neq 0\\), we can use the trial solution \\(y^*=kt\\), which is a growing equilibrium. This yields \\(y_t = k(t-1) + a_0\\), which solves for \\(k=a_0\\), so that we can conclude \\(y^*=a_0t\\). This explains why we obtain linear growth. If \\(a_1=1\\) and \\(a_0 =0\\), we have \\(y_t=y_{t-1}\\), so that the equilibrium is given by the initial condition \\(y_0\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#solution-of-a-single-first-order-linear-difference-equation",
    "href": "intro_stability_analysis.html#solution-of-a-single-first-order-linear-difference-equation",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "",
    "text": "a term that captures the long-run equilibrium \\(y^*\\) (the so-called particular solution),\na term that captures the dynamics of \\(y_t\\) (the so-called complementary function).\n\n\n\n\n\nif \\(|a_1|&lt;1\\), then the complementary function will converge to zero and \\(y_t\\) will approach the particular solution \\(y^*\\)\nif \\(|a_1|&gt;1\\), then the complementary function will grow exponentially or decay, and \\(y_t\\) will thus never converge to the particular solution \\(y^*\\)\nif \\(a_1=1\\) and \\(a_0 \\neq0\\), then \\(y_t\\) will grow linearly\nif \\(a_1=1\\) and \\(a_0 =0\\), then \\(y_t\\) will not grow or fall forever, but it will also not approach a unique equilibrium",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#solution-of-a-linear-system-of-difference-equations",
    "href": "intro_stability_analysis.html#solution-of-a-linear-system-of-difference-equations",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Solution of a linear system of difference equations",
    "text": "Solution of a linear system of difference equations\nThe solution approach just introduced can be extended to \\(N\\)-dimensional systems of linear difference equations of the form:\n\\[\ny_t=a_0 + Ay_{t-1},  \n\\]\nwhere \\(y_t\\) is a \\(1 \\times N\\) column vector and \\(A\\) an \\(N \\times N\\) square matrix.\nIf the inverse \\((I-A)^{-1}\\) exists, which requires \\(det(I-A) \\neq 0\\), the solution will be of the form:\n\\[\ny_t= \\underbrace{(I-A)^{-1}a_0}_{y^*} + A^t[y_0- \\underbrace{(I-A)^{-1}a_0}_{y^*}].\n\\]\nThe problem with this generic solution is that it is difficult to assess what is going on: the dynamics of any variable in \\(y_t\\) will depend on a lengthy combination of the parameters in \\(A\\) that result from repeated matrix multiplication (\\(A^t=A\\times A\\times A\\times A...\\)). This makes it is impossible to assess whether the system converges to the particular solution. To address this problem, we can use a tool from linear algebra called matrix diagonalisation. Under certain conditions, a matrix \\(A\\) can be decomposed into the product of three matrices in which the matrix in the middle is diagonal. As we will see, this trick has a useful application to our problem.\nA matrix \\(A\\) is diagonalisable if there is a diagonal matrix \\(D\\) and an invertible matrix \\(P\\) such that \\(A=PDP^{-1}\\). A major advantage of this decomposition is the following property: \\(A^n = (PDP^{-1})^n = PD^nP^{-1}\\).2 Thus, the \\(nth\\) power of the matrix \\(A\\), which typically yields very cumbersome expressions, simplifies to \\(PD^nP^{-1}\\), where the \\(nth\\) power of \\(D\\) is simply applied to each individual element on the main diagonal thanks to \\(D\\) being a diagonal matrix. As a result, diagonalisation allows us to write the complementary function in the solution to a system of difference equations as: \\(PD^tP^{-1}y_0\\). We can further define a vector of arbitrary constants \\(c=P^{-1}y_0\\) so that the complementary function becomes \\(PD^tc\\). The solution then takes the form \\(y_t = y^* + PD^tP^{-1}[y_0- y^*] = y^* + PD^tc\\)\nFor the first variable in the system, the solution would be:\n\\[\ny_{1t}=v_{11}c_1\\lambda_1^t+v_{12}c_2\\lambda_2^t + ...+ y_1^*,\n\\]\nwhere \\(v_j\\) are the column vectors of \\(P\\) and \\(\\lambda_i\\) are the elements on the main diagonal of \\(D\\). The \\(v_j\\) are called the eigenvectors of the matrix \\(A\\) and the \\(\\lambda_i\\) are its eigenvalues (more about them in a second). From this representation of the solution, the nature of the dynamics can easily be determined by looking at the eigenvalue \\(\\lambda\\) that is largest in absolute terms. This is also called the ‘dominant eigenvalue’. Only if the dominant eigenvalue is \\(|\\lambda|&lt;1\\) will the system converge to \\(y^*\\). The elements \\(v_{ij}\\) of the eigenvectors act as multipliers on the eigenvalues and can thus switch off certain eigenvalues (if they happen to be zero) or amplify their dynamics both into the positive and negative domain (depending on their algebraic sign).\nHow can the diagonal matrix \\(D\\) be found? Notice that \\(AP=PD\\) can also be written as \\(Av=\\lambda v\\). We can then write \\(v(A-\\lambda I)=0\\). We want to find the solutions of this linear system other than \\(v = 0\\) (we don’t want the eigenvectors to be zero vectors, otherwise the solution to the dynamic system presented above wouldn’t work). This requires the determinant of the matrix \\(A-\\lambda I\\) to become zero, i.e. \\(det(A-\\lambda I)=0\\). Note that then there will be an infinite number of solutions for the eigenvectors.\nLet’s consider an example. Let \\(a_0=0\\) for simplicity, so that the dynamic system is \\(y_t = Ay_{t-1}\\). Let the matrix \\(A\\) be given by: \\[A=\\begin{bmatrix}7 & -15 \\\\ 2 & -4 \\end{bmatrix}.\\]\nThen\n\\[A-\\lambda I =\\begin{bmatrix}7 - \\lambda & -15 \\\\ 2 & -4 - \\lambda \\end{bmatrix}\\]\nand\n\\[det(A-\\lambda I)=(7-\\lambda)(-4-\\lambda)+30=\\lambda^2 - 3\\lambda +2=0.\\]\nThis second-order polynomial solves for \\(\\lambda_1=2\\) and \\(\\lambda_2=1\\), which will be the elements on the diagonal of \\(D\\).\nTo find \\(v_j\\), substitute the \\(\\lambda_i\\) into \\(v_j(A-\\lambda_iI)=0\\). For \\(\\lambda_1=2\\), we get \\(5v_{11}- 15v_{21}=0\\) and \\(2v_{11}- 6v_{21}=0\\), yielding the eigenvector \\(v_1=\\begin{bmatrix} 3 \\\\ 1\\end{bmatrix}\\). However, any scalar multiple of this eigenvector (other than zero) is admissible. It is thus common to normalise the eigenvectors by dividing through one of its elements. Dividing through by the first element yields the normalised eigenvector \\(v_1=\\begin{bmatrix} 1 \\\\ \\frac{1}{3} \\end{bmatrix}\\).\nFor \\(\\lambda_2=1\\), this yields \\(6v_{12}- 15v_{22}=0\\) and \\(2v_{12}-5v_{22}=0\\) from which we can deduce that \\(v_2=\\begin{bmatrix} 5 \\\\ 2\\end{bmatrix}\\). The normalised eigenvector is \\(v_2=\\begin{bmatrix} 1 \\\\ 0.4 \\end{bmatrix}\\).\nOf course, you can also perform these calculations in R or Python:\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n## Find eigenvalues and eigenvectors of matrix\n# Define matrix\nJ=matrix(c(7, -15,\n           2, -4), 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues and eigenvectors\nev=eigen(J)\n(evals = ev$values)\n\n[1] 2 1\n\n(evecs = ev$vector)\n\n          [,1]      [,2]\n[1,] 0.9486833 0.9284767\n[2,] 0.3162278 0.3713907\n\n# Normalise eigenvectors by dividing through by the first element\nevecs_norm=evecs\nfor (i in 1:2){\n  evecs_norm[,i]=evecs[,i]/evecs[1,i]\n}\nevecs_norm\n\n          [,1] [,2]\n[1,] 1.0000000  1.0\n[2,] 0.3333333  0.4\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Define matrix\nJ = np.array([[7, -15],\n              [2, -4]])\n\n# Obtain eigenvalues and eigenvectors\nevals, evecs = np.linalg.eig(J)\n\n# Print eigenvalues and eigenvectors\nprint(evals)\nprint(evecs)\n\n# Initialize an array to store the normalized eigenvectors\nevecs_norm = np.copy(evecs)\n\n# Normalize the eigenvectors\nfor i in range(2):\n    evecs_norm[:, i] = evecs[:, i] / evecs[0, i]\n\n# Print normalized eigenvectors\nprint(evecs_norm)\n\n\n\n\nWe can now use this solution for the eigenvectors and eigenvalues to write the solution of the dynamic system as:\n\\[\n\\begin{bmatrix} y_{1t} \\\\ y_{2t} \\end{bmatrix}= \\begin{bmatrix} 1 & 1 \\\\ \\frac{1}{3} & 0.4 \\end{bmatrix} \\begin{bmatrix} 2 & 0 \\\\ 0 & 1 \\end{bmatrix}^t \\begin{bmatrix} 1 & 1 \\\\ \\frac{1}{3} & 0.4 \\end{bmatrix}^{-1} \\begin{bmatrix} y_{10} \\\\ y_{20} \\end{bmatrix} = \\begin{bmatrix} 1 & 1 \\\\ \\frac{1}{3} & 0.4 \\end{bmatrix} \\begin{bmatrix} 2 & 0 \\\\ 0 & 1 \\end{bmatrix}^t \\begin{bmatrix} c_{1} \\\\ c_{2} \\end{bmatrix}.\n\\]\nMultiplying the matrices out yields:\n\\[\ny_{1t} = c_{1}2^t + c_{2}1^t\n\\]\n\\[\ny_{2t} = \\frac{1}{3}c_{1}2^t + 0.4c_{2}1^t.\n\\]\nBefore comparing these analytical results with those from a numerical simulation, let’s summarise the information we gain from the eigenvalues, eigenvectors, and arbitrary constants about the dynamics of the system:\n\nsince the dominant eigenvalue \\(\\lambda_1=2\\) is larger than one, we know that the system is unstable\nsince both elements in the dominant eigenvector \\(v_1=\\begin{bmatrix} 1 \\\\ \\frac{1}{3} \\end{bmatrix}\\) are non-zero, both variables in the system will be driven by that dominant eigenvalue\nsince both variables will grow or decay at the same rate, their ratio will be constant as \\(t \\rightarrow \\infty\\) and will approach a value that is given by the ratio of the elements in the dominant eigenvector\n\nTo see the last point, observe that in \\(\\frac{y_{2t}}{y_{1t}}=\\frac{\\frac{1}{3}c_{1}2^t + 0.4c_{2}1^t}{c_{1}2^t + c_{2}1^t}\\) the first terms in the numerator and denominator, respectively, quickly dominate the second terms as \\(t \\rightarrow \\infty\\) (you can show this formally using L’Hopital’s rule). Thus, \\(\\frac{y_{2t}}{y_{1t}}\\) will approach \\(\\frac{1}{3}\\) as \\(t \\rightarrow \\infty\\).\nLet us simulate the system and compare the results for, say, \\(t=10\\) with the analytical solution:\n\n# Set number of periods for which you want to simulate\nQ=100\n\n# Construct matrices in which values for different periods will be stored; initialise at 1\ny1=matrix(data=1, nrow=1, ncol=Q)\ny2=matrix(data=1, nrow=1, ncol=Q)\n\n#Solve this system recursively based on the initialisation\n  for (t in 2:Q){\n    y1[,t] = J[1,1]*y1[, t-1] + J[1,2]*y2[, t-1]\n    y2[,t] = J[2,1]*y1[, t-1] + J[2,2]*y2[, t-1]\n} # close time loop\n\n# Plot dynamics of y1\nplot(y1[1, 1:15],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"y1\") \ntitle(main=\"\", cex=0.8)\n\n\n\n\n\n\n# Find arbitrary constants: c=(P^-1)*y0\nlibrary(matlib)\ny0=c(y1[1,1],y2[1,1])  # create vector with initial conditions y0\nc=inv(evecs_norm)%*%y0\nc\n\n     [,1]\n[1,]   -9\n[2,]   10\n\n## Compute solution manually for y2 at t=10 and compare with simulated solution\nt=10\nevecs_norm[2,1]*c[1,1]*evals[1]^t + evecs_norm[2,1]*c[2,1]*evals[2]^t # analytical solution\n\n[1] -3068.667\n\ny2[,t+1] # simulated solution\n\n[1] -3068\n\n# Plot dynamics of y2/y1\ny2_y1=y2/y1\nplot(y2_y1[, 1:50],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"y2/y1\")\ntitle(main=\"\", cex=0.8)\n\n\n\n\n\n\n# Compare y2/y1 with normalised dominant eigenvector\ny2_y1[,Q]\n\n[1] 0.3333333\n\nevecs_norm[2,1]\n\n[1] 0.3333333\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# Set the number of periods for simulation\nQ = 100\n\n# Initialize arrays to store values for different periods\ny1 = np.ones(Q)\ny2 = np.ones(Q)\n\n# Solve the system recursively based on the initialization\nfor t in range(1, Q):\n    y1[t] = J[0, 0] * y1[t - 1] + J[0, 1] * y2[t - 1]\n    y2[t] = J[1, 0] * y1[t - 1] + J[1, 1] * y2[t - 1]\n\n# Plot dynamics of y1\nplt.plot(range(Q), y1, color='b', linewidth=2)\nplt.xlabel('Time')\nplt.ylabel('y1')\nplt.title('Dynamics of y1')\nplt.show()\n\n\n# Define the initial conditions y0\ny0 = np.array([y1[0], y2[0]])\n\n# Calculate the arbitrary constants c using the normalized eigenvectors\nc = np.linalg.inv(evecs_norm).dot(y0)\nc\n\n## Compute solution manually for y2 at t=10 and compare with simulated solution\nt = 10 +1\nevecs_norm[1, 1] * c[0] * evals[0] ** t + evecs_norm[1, 1] * c[1] * evals[1] ** t\ny2[t-1]\n\n\n# Calculate the ratio y2/y1\ny2_y1 = y2 / y1\n\n# Plot dynamics of y2/y1 for the first 50 periods\nplt.plot(y2_y1[:50], color='black', linewidth=2, linestyle='-')\nplt.xlabel('Time')\nplt.ylabel('y2/y1')\nplt.show()\n\n# Compare y2/y1 with normalised dominant eigenvector\ny2_y1[Q-1]\nevecs_norm[1,0]\n\n\n\n\nIt can be seen that the simulated results are equivalent to the results we obtained analytically. The key takeaway is that by deriving information about the eigenvalues (and possibly eigenvectors) of the Jacobian matrix of the system, we are able to deduce knowledge of the dynamic properties of the system even without numerical simulation. However, the more complex the dynamic system, the more difficult this will be, thereby rendering numerical simulation a key tool to supplement formal analysis.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#complex-eigenvalues-and-cycles",
    "href": "intro_stability_analysis.html#complex-eigenvalues-and-cycles",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Complex eigenvalues and cycles",
    "text": "Complex eigenvalues and cycles\nSo far, we have discussed the case where the eigenvalues \\(\\lambda\\) are real numbers. However, what if the polynomial \\(det(A-\\lambda I)=0\\) does not yield real numbers? Recall that in the case of a second-order polynomial \\(\\lambda^2+b\\lambda+c=0\\), the two roots are given by \\(\\lambda_{1,2} = \\frac{-b \\pm \\sqrt{b^2-4c}}{2}\\). If the term under the root \\(\\Delta=b^2-4c\\), also called discriminant, becomes negative, the solution will be a complex number. More specifically, we can write:\n\\[\n\\lambda_{1,2} = \\frac{-b \\pm \\sqrt{b^2-4c}}{2}=\\frac{-b \\pm \\sqrt{4c-b^2}\\sqrt{-1}}{2} =\\frac{-b \\pm \\sqrt{4c-b^2}i}{2},\n\\]\nwhere \\(i=\\sqrt{-1}\\) is the imaginary number. The expression can also be written as:\n\\[\n\\lambda_{1,2} = \\frac{-b}{2} \\pm \\frac{\\sqrt{4c-b^2}}{2}i = h \\pm mi,\n\\]\nwhich is a pair of conjugate complex numbers containing a real part given by \\(h\\) and an imaginary part given by \\(m\\).\nConsider the model by Samuelson (1939) discussed in Chapter 2: \\[\nC_t= c_1(C_{t-1} + I_{t-1} + G_0)\n\\]\n\\[\nI_t= \\beta[c_1(C_{t-1} + I_{t-1} + G_0) - C_{t-1}]\n\\]\nThe Jacobian matrix of this model is given by:\n\\[\nJ=\\begin{bmatrix} c_1 & c_1 \\\\ \\beta(c_1-1) & \\beta c_1 \\end{bmatrix}\n\\]\nThe characteristic polynomial yielding the eigenvalues of the Jacobian is\n\\[\\lambda^2-\\lambda c_1(1+\\beta)+\\beta c_1=0,\\]\nwhere \\(c_1(1+\\beta) =tr(J)\\) and \\(\\beta c_1 = det(J)\\).\nThus we have\n\\[\n\\lambda_{1,2} = \\frac{c_1(1+\\beta) \\pm \\sqrt{[c_1(1+\\beta)]^2-4\\beta c_1}}{2}.\n\\]\nThus, the two eigenvalues will be a pair of complex conjugates if \\([c_1(1+\\beta)]^2-4\\beta c_1 &lt;0\\) or \\(c_1 &lt; \\frac{4\\beta}{(1+\\beta)^2}\\). Suppose we have \\(c_1=0.4\\) and \\(\\beta=2\\). Then the discriminant will be negative and the eigenvalues will be complex:\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set parameter values\nc1=0.4\nbeta=2\n\n# Check if discriminant is negative\n(c1*(1+beta))^2-4*c1*beta\n\n[1] -1.76\n\n## Find eigenvalues and eigenvectors of matrix\n# Define matrix\nJ=matrix(c(c1, c1,\n           beta*(c1-1), beta*c1), \n           2, 2, byrow=TRUE)\n\n# Obtain eigenvalues and eigenvectors\nev=eigen(J)\n(evals = ev$values)\n\n[1] 0.6+0.663325i 0.6-0.663325i\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Set parameter values\nc1 = 0.4\nbeta = 2\n\n# Check if discriminant is negative\n(c1 * (1 + beta))**2 - 4 * c1 * beta\n\n# Define the matrix\nJ = np.array([[c1, c1],\n              [beta * (c1 - 1), beta * c1]])\n\n# Calculate eigenvalues and eigenvectors\nevals, evecs = np.linalg.eig(J)\n\nprint(evals)\nprint(evals)\n\n\n\n\nAnother way of understanding the logic behind complex numbers is through a so-called Argand diagram that plots the real part of the eigenvalue on the horizontal and the imaginary part on the vertical axis. By Pythagoras’ theorem, the distance of the eigenvalue from the origin will then be given by \\(R=\\sqrt{h^2+m^2}\\). The value of \\(R\\) (which is always real-valued and positive) is called the modulus (or absolute value) of the complex eigenvalue and will contain important information about the dynamic stability of economic models that exhibit complex eigenvalues.\n\n### Draw Argand diagram\n\n# Save real and imaginary part of complex eigenvalue\nre=Re(evals[1])\nim=Im(evals[1])\n\n# Plot complex eigenvalue\npar(bty=\"l\")\nplot(re,im, type=\"o\", xlim=c(0, 1), ylim=c(0, 1), lwd=2, xlab=\"h\", ylab=\"m\", main=\"Argand diagram of complex eigenvalue\")\n\n# Plot unit circle\nX=seq(0, 1, by=0.001)\nY = sqrt(1 - X^2) \nlines(X,Y, type=\"l\", lty=\"dotted\")\n\n# Plot a ray from the origin to eigenvalue\nsegments(0,0,re,im, lty='solid')\n\n# Add labels\ntext(0.1, 0.025, expression(theta), cex=1)\ntext(0.1, 0.25, expression(R==sqrt(h^2+m^2)), cex=1)\ntext(re, im+0.05, expression(lambda==h+mi), cex=1)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Draw Argand diagram\n\n# Save real and imaginary part of complex eigenvalue\nre = evals[0].real\nim = evals[0].imag\n\n# Create a figure\nfig, ax = plt.subplots()\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_xlabel('h')\nax.set_ylabel('m')\nax.set_title('Argand diagram of complex eigenvalue')\n\n# Plot complex eigenvalue\nax.plot(re, im, 'o', markersize=8, color='k')\n\n# Plot unit circle\nX = np.linspace(0, 1, 100)\nY= np.sqrt(1-X**2)\nax.plot(X, Y, 'k--')\n\n# Plot a ray from the origin to the eigenvalue\nax.plot([0, re], [0, im], 'k-')\n\n# Add labels\nax.text(0.1, 0.025, r'$\\theta$', fontsize=12)\nax.text(0.001, 0.25, r'$R=\\sqrt{h^2+m^2}$', fontsize=12)\nax.text(re, im - 0.1, r'$\\lambda=h+mi$', fontsize=12)\n\nplt.show()\n\n\n\n\nThe angle \\(\\theta\\) of the line that connects the origin and the complex eigenvalue and the x-axis of the Argand diagram also contains information about the dynamics. To see this, note that the geometry of the complex number represented in the Argand diagram can also be expressed in trigonometric form: \\[\n\\sin\\theta=\\frac{m}{R}\n\\] \\[\n\\cos\\theta=\\frac{h}{R},\n\\]\nwhere \\(\\theta=\\arcsin (\\frac{m}{R}) =\\arccos (\\frac{h}{R})=\\arctan(\\frac{m}{h})\\)\nThus, we can write the complex eigenvalue also as:\n\\[\n\\lambda_{1,2}=R(\\cos\\theta \\pm \\sin\\theta \\times i).\n\\]\nBy De Moivre’s theorem, we have \\((\\cos\\theta \\pm \\sin\\theta \\times i)^t=(\\cos\\theta t \\pm \\sin\\theta t \\times i)\\). Thus, the solution to a dynamic system that exhibits complex eigenvalues will be of the form:\n\\[\ny_{1t}=v_{11}c_1 R_1^t(\\cos\\theta_1 t \\pm \\sin\\theta_1 t \\times i) +...+ y^*_1.\n\\]\nFrom this solution we can again deduce key information about the dynamics of the system based on the (complex) eigenvalues:\n\nstability will depend on the modulus: for \\(R&lt;\\) the system will be stable, for \\(R&gt;1\\) it will be unstable\nfrom the nature of the trigonometric functions \\(\\sin(\\theta t)\\) and \\(\\cos(\\theta t)\\), we know that system will exhibit periodic cyclical dynamics as \\(t\\) increases\nthe length of the cycles will be given by \\(L=\\frac{2\\pi}{\\theta}\\) and the frequency by \\(F=1/L=\\frac{\\theta}{2\\pi}\\)\n\nthe amplitude of the cycles will depend on the elements of the eigenvectors, the initial conditions, and \\(R\\).\n\nLet us simulate the Samuelson model with the parameterisation that yields complex eigenvalues to illustrate these results:\n\n# Calculate modulus\nmod=Mod(evals[1])\nmod\n\n[1] 0.8944272\n\n# Calculate cycle length\nL=(2*pi)/(acos(re/mod))\nL\n\n[1] 7.520433\n\n# Set number of periods for which you want to simulate\nQ=100\n\n# Set number of parameterisations that will be considered\nS=1\n\n# Construct matrices in which values for different periods will be stored; initialise at 1\nC=matrix(data=1, nrow=S, ncol=Q)\nI=matrix(data=1, nrow=S, ncol=Q)\n\n#Construct matrices for exogenous variable\nG0=matrix(data=5, nrow=S, ncol=Q)\n\n#Solve this system recursively based on the initialisation\nfor (t in 2:Q){\n    C[1,t] = c1*(C[1,t-1] + I[1,t-1] + G0[1,t])\n    I[1,t] = beta*(c1*(C[1,t-1] + I[1,t-1] + G0[1,t]) - C[1,t-1])\n  } # close t1me loop\n\n# Calculate output\nY=C+G0+I\n\n# Time series chart of output dynamics in Samuelson (1939) model\nplot(Y[1, 1:30],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Output fluctuations in Samuelson model with complex eigenvalues\", cex=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Calculate modulus\nmod = abs(evals[0])\nprint(mod)\n\n# Calculate cycle length\nimport math\nL = (2 * math.pi) / math.acos(re / mod)\nprint(L)\n\n# Set the number of periods and parameterizations\nQ = 100\nS = 1\n\n# Initialize matrices for consumption, investment, and exogenous government spending\nC = np.ones((S, Q))\nI = np.ones((S, Q))\nG0 = np.full((S, Q), 5)\n\n# Solve the system recursively based on the initialization\nfor t in range(1, Q):\n    C[0, t] = c1 * (C[0, t - 1] + I[0, t - 1] + G0[0, t])\n    I[0, t] = beta * (c1 * (C[0, t - 1] + I[0, t - 1] + G0[0, t]) - C[0, t - 1])\n\n# Calculate output\nY = C + G0 + I\n\n# Plot the time series chart of output dynamics\nplt.plot(Y[0, :30], color='k', linewidth=2, linestyle='-')\nplt.xlabel(\"Time\")\nplt.ylabel(\"Y\")\nplt.title(\"Output fluctuations in Samuelson model with complex eigenvalues\")\nplt.show()\n\n\n\n\nYou can see that the model generates cycles with a length (from peak/trough to peak/trough) of around 7.5 periods. Since the modulus is \\(R&lt;1\\), the system is stable and eventually converges to the equilibrium.\nA general condition for stability of 2D systems with complex eigenvalues can be derived by making use of the fact that \\(R=\\sqrt{h^2+m^2}= \\sqrt{ \\left( \\frac{b}{2} \\right) ^2 + \\left(\\frac{\\sqrt{4c-b^2}}{2}i \\right)^2} = \\sqrt{c}\\), where \\(b=tr(J)\\) and \\(c=det(J)\\). Applied to the modulus of the Samuelson model, this yields \\(R=\\sqrt{det(J)}=\\sqrt{\\beta c_1}\\). Thus, the stability condition is:\n\\[\\beta c_1&lt;1.\\]\nThe following code generates a plot that displays the condition for cycles and the stability condition in the \\((\\beta, c_1)\\)-space:\n\n# Create function for cycle condition: c1 &lt; (4*beta)/(1+beta)^2\ncyc= function (beta) {\n  (4*beta)/(1+beta)^2\n}\n\n# Create function for stability condition: c1 &lt; 1/beta\nstab= function (beta) {\n  1/beta\n}\n\n# Plot the two functions in (beta, c1)-space\ncurve(cyc, from = 0, to = 5, col = 1, xlab=expression(beta), ylab=expression(c[1]) , main=\"\",\n      lwd=1.5, n=10000, ylim=range(0, 1.5))\ncurve(stab, from = 0, to = 5, col = 2, lwd=1.5, n=10000, add = TRUE)\nlegend(\"topright\", legend = c(\"cycle condition\", \"stability condition\"), \n       col = c(1, 2), lwd = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create function for cycle condition using beta as argument\ndef cyc(beta):\n    return (4 * beta) / (1 + beta)**2\n\n# Create function for stability condition using beta as argument\ndef stab(beta):\n    return 1 / beta\n\n# Define the range of beta values\nbeta = np.linspace(0.001, 5, 10000)  # start from 0.001 to avoid division by zero\n\n# Plot the two functions in (beta, c1)-space\nplt.plot(beta, cyc(beta), label=\"cycle condition\", color='black', linewidth=1.5)\nplt.plot(beta, stab(beta), label=\"stability condition\", color='red', linewidth=1.5)\n\n# Set labels and title\nplt.xlabel(r'$\\beta$')\nplt.ylabel(r'$c_1$')\nplt.ylim(0, 2)\nplt.legend(loc=\"upper right\")\n\n# Display the plot\nplt.show()\n\n\n\n\nCombinations of \\(c_1\\) and \\(\\beta\\) below the cycle condition curve yield complex eigenvalues and thus cycles, while combinations below the stability condition curve yield an asymptotically stable equilibrium.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#nonlinear-systems",
    "href": "intro_stability_analysis.html#nonlinear-systems",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Nonlinear systems",
    "text": "Nonlinear systems\nSo far, we have analysed dynamic systems that are linear. However, in the more general case, a dynamic system may be nonlinear and of the form:\n\\[\ny_t=f(y_{t-1}).\n\\]\nAn \\(n\\)-dimensional nonlinear system may have multiple equilibria \\(y^*\\). To analyse the dynamic properties of such a system, we normally conduct a linear approximation in the neighbourhood of one of the equilibria. In that sense, the stability analysis of a nonlinear system has only local as opposed to global validity.\nMathematically, linearisation around an equilibrium point can be done by conducting a first-order Taylor expansion around that equilibrium:\n\\[\ny_t=f^i(y^*) + \\sum_{j=1}^{n}\\frac{\\partial f^i(y^*)}{\\partial y_{jt-1}}(y_{jt-1}-y_j^*),\n\\]\nwhere \\(i=1,2,...,n\\).\nThis yields a linear version of the system that can be written as:\n\\[\ny_{t}=Ay_{t-1}+B,\n\\]\nwhere \\(A_{11}=\\frac{\\partial f^1(y^*)}{y_{1t-1}}\\) and so forth. Thus, \\(A\\) is simply the Jacobian matrix of \\(f(y_{t-1})\\) evaluated at \\(y^*\\).\nIn practice, this means that to analyse the local stability of a nonlinear system, one needs to:\n\nfind the equilibrium solution \\(y^*\\) whose neighbourhood you want to analyse\ncompute the Jacobian matrix of \\(f(y_{t-1})\\)\n\nsubstitute \\(y^*\\) into \\(f(y_{t-1})\\) and analyse the resulting matrix.\n\nAn example for the stability analysis of a simple nonlinear system can be found in Chapter 13.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#key-takeaways",
    "href": "intro_stability_analysis.html#key-takeaways",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Key takeaways",
    "text": "Key takeaways\n\ndynamic models are systems of difference (or differential) equations\nthe stability of a system depends on (a combination of) its coefficients\nmore generally, the system’s dynamic properties (including stability) are encapsulated in the Jacobian matrix\nthe (dominant) eigenvalues of the Jacobian matrix indicate whether a system is\n\nstable (\\(\\lambda &lt; 1\\)) or unstable (\\(\\lambda &gt; 1\\))\nacyclical (\\(\\lambda \\in \\mathbb{R}\\)) or cyclical (\\(\\lambda \\in \\mathbb{C}\\))\n\n\nthe (dominant) eigenvectors mediate the impact of the eigenvalues in the dynamics\nnonlinear systems are analysed locally around one of its equilibria",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#references",
    "href": "intro_stability_analysis.html#references",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "References",
    "text": "References\n\n\n\n\nAnthony, Martin, and Michele Harvey. 2012. Linear Algebra: Concepts and Methods. Cambridge UK: Cambridge University Press.\n\n\nChiang, Alpha C, and Kevin Wainwright. 2005. Fundamental Methods of Mathematical Economics. 4th ed. New York: McGraw-Hill Education.\n\n\nGandolfo, Giancarlo. 2009. Economic Dynamics. Study Edition. 4th Edition. Springer.\n\n\nSamuelson, Paul A. 1939. “Interactions between the Multiplier Analysis and the Principle of Acceleration.” The Review of Economics and Statistics 21 (2): 75–78. https://doi.org/10.2307/1927758.\n\n\nSayama, Hiroki. 2015. Introduction to the Modeling and Analysis of Complex Systems. Open SUNY Textbooks, Milne Library.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#footnotes",
    "href": "intro_stability_analysis.html#footnotes",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "",
    "text": "We will focus here on difference instead of differential equations, i.e. on dynamics in discrete as opposed to continuous time. Most of the continuous-time counterpart is analogous to the material covered here. Sayama (2015) provides a very accessible and applied introduction to dynamic systems with Python code. An introductory treatment of the underlying mathematics is Chiang and Wainwright (2005), chaps. 15-19. Gandolfo (2009) provides a more advanced treatment of the mathematics as well as many economic examples. A great introduction to linear algebra is Anthony and Harvey (2012).↩︎\nThis is because in the product \\((PDP^{-1})(PDP^{-1})(PDP^{-1})...\\), each \\(P\\) cancels a \\(P^{-1}\\), except for the first \\(P\\) and last \\(P^{-1}\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html",
    "href": "a_new_keynesian_3_equation_model.html",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "",
    "text": "Overview\nNew Keynesian dynamic general equilibrium models were developed in the 1990s and 2000s to guide monetary policy.1 They build on real business cycle models with rational expectations but introduce Keynesian frictions such as imperfect competition and nominal rigidities. While the structural forms of these models are typically complex as behavioural functions are derived from the intertemporal optimisation, the reduced-form of the benchmark models can be represented by three main equations: (i) an IS curve, (ii) a Phillips curve, (iii) and an interest rate rule.\nThe IS curve establishes a negative relationship between real income and the real interest rate. For a higher real interest rate, households will save more and thus consume less. The Phillips curve models inflation as a function of the output gap. A positive output gap (an economic expansion) leads to higher inflation. The monetary policy rule specifies how the central bank reacts to deviations of actual inflation from a politically determined inflation target.\nThe simplified version of the 3-equation model we consider here is directly taken from chapter 4 of Carlin and Soskice (2014). This is a short-run model in which prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. In the Carlin-Soskice version, inflation expectations are assumed to be adaptive and the response of aggregate demand to a change in the interest rate is sluggish. This renders the model dynamic.2",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#the-model",
    "href": "a_new_keynesian_3_equation_model.html#the-model",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "The Model",
    "text": "The Model\n\\[\ny_t=A -a_1r_{t-1}\n\\tag{10.1}\\]\n\\[\n\\pi_t=\\pi_{t-1}+a_2(y_t -y_e)\n\\tag{10.2}\\]\n\\[\nr_s=\\frac{(A - y_e)}{a_1}\n\\tag{10.3}\\]\n\\[\nr_t = r_s + a_3(\\pi_t-\\pi^T)\n\\tag{10.4}\\]\nwhere \\(y\\), \\(A\\), \\(r\\), \\(\\pi\\), \\(y_e\\), \\(r_s\\), and \\(\\pi^T\\) are real output, autonomous demand (times the multiplier), the real interest rate, inflation, equilibrium output, the stabilising real interest rate, and the inflation target, respectively.\nEquation 10.1 is the IS curve or goods market equilibrium condition. Aggregate output adjusts to the level of aggregate demand, which is given by autonomous demand (times the multiplier) and a component that is negatively related to the (lagged) real interest rate via households’ saving (\\(a_1&gt;0\\)). Equation 10.2 is the Phillips curve. It is assumed that inflation is driven by adaptive expectations (\\(E[\\pi_{t+1}]=\\pi_{t-1}\\)) and positively related to the output gap \\((y_t-y_e)\\), i.e. \\(a_2&gt;0\\). By Equation 10.3, the stabilising real interest rate is that real interest rate that is consistent with equilibrium output (\\(y_e=A -a_1r_s\\)). Finally, the interest rate rule in Equation 10.4 specifies the real interest rate the central bank needs to set to minimise its loss function (see Section 10.5 below for a derivation). The parameter \\(a_3\\) is a composite one given by \\(a_3 = \\frac{1}{a_1(\\frac{1}{a_2 b} + a_2)} &gt;0\\). Although the central bank only sets the nominal interest rate \\(i = r + E[\\pi_{t+1}]\\) directly, the fact that expected inflation is predetermined in every period allows it to indirectly control the real interest rate.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#simulation",
    "href": "a_new_keynesian_3_equation_model.html#simulation",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. For all parameterisations, the system is initialised at the equilibrium \\((y^*,\\pi^*,r^*)=(y_e,\\pi^T, r_s)\\). Three scenarios will then be considered. In scenario 1, there is an increase in autonomous aggregate demand (\\(A\\)). In scenario 2, the central bank sets a higher inflation target (\\(\\pi^T\\)). Scenario 3 considers a rise in equilibrium output (\\(y_e\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(a_1\\)\n\\(a_2\\)\n\\(b\\)\n\\(A\\)\n\\(\\pi^T\\)\n\\(y_e\\)\n\n\n\n1: rise in aggregate demand (\\(A\\))\n0.3\n0.7\n1\n12\n2\n5\n\n\n2: higher inflation target (\\(\\pi^T\\))\n0.3\n0.7\n1\n10\n2.5\n5\n\n\n3: rise in equilibrium output (\\(y_e\\))\n0.3\n0.7\n1\n10\n2\n7\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=50\n\n# Set number of scenarios\nS=3\n\n# Set period in which shock/shift will occur\ns=5\n\n# Create (S x Q)-matrices that will contain the simulated data\ny=matrix(data=0,nrow=S,ncol=Q) # Income/output\np=matrix(data=0,nrow=S,ncol=Q) # Inflation rate\nr=matrix(data=0,nrow=S,ncol=Q) # Real interest rate\nrs=matrix(data=0,nrow=S,ncol=Q) # Stabilising interest rate\n\n# Set constant parameter values\na1=0.3  # Sensitivity of inflation with respect to output gap \na2=0.7  # Sensitivity of output with respect to interest rate\nb=1     # Sensitivity of central bank to inflation gap\na3=(a1*(1/(b*a2) + a2))^(-1)\n\n# Set parameter values for different scenarios\nA=matrix(data=10,nrow=S,ncol=Q) # autonomous spending\npt=matrix(data=2,nrow=S,ncol=Q) # Inflation target\nye=matrix(data=5,nrow=S,ncol=Q) # Potential output\n\nA[1,s:Q]=12  # scenario 1: AD boost  \npt[2,s:Q]=3  # scenario 2: higher inflation target\nye[3,s:Q]=7  # scenario 3: higher potential output\n\n# Initialise endogenous variables at equilibrium values\ny[,1]=ye[,1]\np[,1]=pt[,1]\nrs[,1]=(A[,1] - ye[,1])/a1 \nr[,1]=rs[,1]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    #(1) IS curve\n    y[i,t] = A[i,t] - a1*r[i,t-1]\n    \n    #(2) Phillips Curve\n    p[i,t] = p[i,t-1] +a2*(y[i,t]-ye[i,t])\n    \n    #(3) Stabilising interest rate\n    rs[i,t] = (A[i,t] - ye[i,t])/a1\n    \n    #(4) Monetary policy rule, solved for r\n    r[i,t] = rs[i,t] + a3*(p[i,t]-pt[i,t])\n  \n  } # close time loop\n}   # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 50\n\n# Set number of scenarios\nS = 3\n\n# Set period in which shock/shift will occur\ns = 5\n\n# Create (S x Q) arrays to store simulated data\ny = np.zeros((S, Q))  # Income/output\np = np.zeros((S, Q))  # Inflation rate\nr = np.zeros((S, Q))  # Real interest rate\nrs = np.zeros((S, Q))  # Stabilizing interest rate\n\n# Set constant parameter values\na1 = 0.3  # Sensitivity of inflation with respect to output gap\na2 = 0.7  # Sensitivity of output with respect to interest rate\nb = 1     # Sensitivity of the central bank to inflation gap\na3 = (a1 * (1 / (b * a2) + a2)) ** (-1)\n\n# Set parameter values for different scenarios\nA = np.full((S, Q), 10)  # Autonomous spending\npt = np.full((S, Q), 2)  # Inflation target\nye = np.full((S, Q), 5)  # Potential output\n\nA[0, s:Q] = 12  # Scenario 1: AD boost\npt[1, s:Q] = 3  # Scenario 2: Higher inflation target\nye[2, s:Q] = 7  # Scenario 3: Higher potential output\n\n# Initialize endogenous variables at equilibrium values\ny[:, 0] = ye[:, 0]\np[:, 0] = pt[:, 0]\nrs[:, 0] = (A[:, 0] - ye[:, 0]) / a1\nr[:, 0] = rs[:, 0]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        # (1) IS curve\n        y[i, t] = A[i, t] - a1 * r[i, t - 1]\n        # (2) Phillips Curve\n        p[i, t] = p[i, t - 1] + a2 * (y[i, t] - ye[i, t])\n        # (3) Stabilizing interest rate\n        rs[i, t] = (A[i, t] - ye[i, t]) / a1\n        # (4) Monetary policy rule, solved for r\n        r[i, t] = rs[i, t] + a3 * (p[i, t] - pt[i, t])\n\n\n\n\nPlots\nFigures 1-3 depict the response of the model’s key endogenous variables to various shifts. A permanent rise in aggregate demand (scenario 1) has an instantaneous expansionary effect on output, but also pushes inflation above the target. This induces the central bank to raise the interest rate, which brings down output below equilibrium in the next period. The central bank then gradually lowers the policy rate towards its new higher equilibrium value, where inflation is again stabilised at its target level.\n\n### Plot results\n\n### Plots\n# Set maximum period for plots\nTmax=15\n\n# Output under different scenarios\nplot(y[1, 1:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", xlim=range(2:(Tmax)), ylab=\"y\", ylim=range(y[1, 1:Tmax],y[3, 1:(Tmax)])) \ntitle(main=\"Figure 1: Output under different scenarios\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(y[2, 1:(Tmax+1)],lty=2, lwd=2)\nlines(y[3, 1:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: aggregate demand boost\", \"2: rise inflation target\", \"3: rise potential output\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Inflation under different scenarios\nplot(p[1, 1:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", xlim=range(2:(Tmax)), ylab=expression(pi), ylim=range(p[1, 2:Tmax],p[3, 2:(Tmax)])) \ntitle(main=\"Figure 2: Inflation under different scenarios\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(p[2, 1:(Tmax+1)],lty=2, lwd=2)\nlines(p[3, 1:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: aggregate demand boost\", \"2: rise inflation target\", \"3: rise potential output\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Policy rate under different scenarios\nplot(r[1, 2:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", xlim=range(1:(Tmax)), ylab=\"r\", ylim=range(r[1, 2:Tmax],r[3, 2:(Tmax)])) \ntitle(main=\"Figure 3: Policy rate under different scenarios\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(r[2, 2:(Tmax+1)],lty=2, lwd=2)\nlines(r[3, 2:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: aggregate demand boost\", \"2: rise inflation target\", \"3: rise potential output\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmax = 15\n\n# Plot output under different scenarios\nplt.figure(figsize=(8, 6))\nplt.plot(y[0, :Tmax + 1], label=\"Scenario 1: aggregate demand boost\",\n         color='k', linestyle='solid', linewidth=2)\nplt.plot(y[1, :Tmax + 1], label=\"Scenario 2: Rise inflation target\",\n         color='k', linestyle='dashed', linewidth=2)\nplt.plot(y[2, :Tmax + 1], label=\"Scenario 3: Rise potential output\",\n         color='k', linestyle='dotted', linewidth=2)\n\nplt.title(\"Output under Different Scenarios\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"y\")\nplt.xlim(1, Tmax)\nplt.ylim(np.min(y), np.max(y))\nplt.legend()\nplt.show()\n\n\n\n\nAn increase in the central bank’s inflation target (scenario 2) gradually raises the inflation rate to a new level. During the adjustment period, the interest rate falls, which temporarily allows for a higher level of output. However, there is no permanent expansionary effect.\nBy contrast, an increase in potential or equilibrium output (scenario 3) allows for a permanently higher level of output and a lower real interest rate.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#directed-graph",
    "href": "a_new_keynesian_3_equation_model.html#directed-graph",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n# Construct auxiliary Jacobian matrix for 7 variables: y, p, r, A, ye, rs, pt\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,0,1,1,0,0,0,\n               1,0,0,0,1,0,0,\n               0,1,0,0,0,1,1,\n               0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,\n               0,0,0,1,1,0,0,\n               0,0,0,0,0,0,0),7,7, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted=NULL)\n\n# Define node labels\nV(dg)$name=c(\"y\", expression(pi), \"r\", \"A\", expression(y[e]),expression(r[s]), expression(pi^T))\n\n# Plot directed graph\nplot(dg, main=\"Figure 4: Directed graph of 3-Equation model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Directed graph\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the Jacobian matrix\nM_mat = np.array([[0, 0, 1, 1, 0, 0, 0],\n                  [1, 0, 0, 0, 1, 0, 0],\n                  [0, 1, 0, 0, 0, 1, 1],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 1, 1, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                 ])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {\n    0: \"y\",\n    1: \"π\",\n    2: \"r\",\n    3: \"A\",\n    4: \"yₑ\",\n    5: \"rₛ\",\n    6: \"πᵀ\"\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 4, it can be seen that aggregate demand (\\(A\\)), equilibrium output (\\(y_e\\)), and the inflation target (\\(\\pi^T\\)) are the key exogenous variables of the model. All other variables are endogenous and form a closed loop (or cycle) within the system. The upper-right side of the graph represents the supply side, given by the equilibrium level of output and its effect on inflation. The upper-left side captures the demand side and its effect on actual output. The key endogenous variables, output, inflation, and the interest rate form the centre of the graph, where they stand in a triangular relationship to each other. Output drives inflation, which in turn impacts the real interest rate. The latter then feeds back into output. Structural changes in the relationship between demand and supply (e.g. excess demand) also impact the system through their effect on the stabilising interest rate (\\(r_s\\)).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#sec-analytical",
    "href": "a_new_keynesian_3_equation_model.html#sec-analytical",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nDerivation of core equations\nIS curve\nThe IS curve in Equation 10.1 is loosely based on the consumption Euler equation introduced in Chapter 3. Suppose there are two periods and the household maximises its utility function \\(U=\\ln(C_t) + \\beta \\ln(C_{t+1})\\) subject to the intertemporal budget constraint \\(C_t+\\frac{C_{t+1}}{1+r}=Y_t + \\frac{Y_{t+1}}{1+r}\\). Substituting the constraint into the objective function and differentiating with respect to \\(C_t\\) yields the first-order condition:\n\\[\nC_t = \\frac{C_{t+1}}{\\beta(1+r)}.\n\\]\nThis consumption Euler equation establishes the negative relationship between the real interest rate and expenditures in Equation 10.1.\nPC curve\nThe Phillips curve Equation 10.2 is derived from wage- and price-setting in imperfect labour markets.3 Consider the following wage- and price-setting functions: \\[\n\\frac{W}{P^E} = B + \\alpha(y_t - y_e) + z_w\n\\] \\[\nP=(1+\\mu)\\frac{W}{\\lambda},\n\\tag{10.5}\\]\ni.e. the nominal wage \\(W\\), adjusted for the expected price level, is increasing in the output gap, a factor \\(B\\) capturing unemployment benefits and the disutility of work as well as a vector \\(z_w\\) of wage-push factors. Prices are set based on a constant mark-up (\\(\\mu\\)) on unit labour cost (\\(\\frac{W}{\\lambda}\\)).\nIn equilibrium, the real wage is given by: \\(w_e = B + z_w\\). In a dynamic setting, wage setters will raise the expected real wage by \\(\\left(\\frac{W_t}{P_{t}^E}\\right) - \\left(\\frac{W_{t-1}}{P_{t-1}}\\right)=\\alpha(y_t - y_e)\\). Together with adaptive expectations for prices \\(\\hat{P_t^E} = \\hat{P}_{t-1}\\) and the approximation \\(\\hat{W_t} - \\hat{P_{t-1}} \\approx \\left(\\frac{W_t}{P_{t}^E}\\right) - \\left(\\frac{W_{t-1}}{P_{t-1}}\\right)\\), this yields the following equation for wage inflation: \\[\n\\hat{W_t} = \\hat{P}_{t-1} +\\alpha(y_t - y_e).\n\\tag{10.6}\\]\nTransforming equation Equation 10.5 into growth rates (\\(\\hat{P}=\\hat{W}\\)) and combining it with the wage-inflation equation Equation 10.6 yields the Phillips curve Equation 10.2.\nMonetary policy rule\nFinally, to derive the interest rate rule, start from the following central bank loss function:4\n\\[\nL=(y_t-y_e)^2 + b(\\pi_t - \\pi^T)^2.\n\\] Substituting the Phillips curve (Equation 10.2) into the loss function, differentiating with respect to \\(y_t\\), and simplifying yields the first-order condition:\n\\[\ny_t-y_e = -a_2b(\\pi-\\pi^T),\n\\]\nwhich can also be regarded as a monetary policy rule. Next, substitute the Phillips curve (Equation 10.2), the IS-curve (Equation 10.1), and the stabilising interest rate (Equation 10.3) into the monetary policy rule and define \\(a_3 = \\frac{1}{a_1(\\frac{1}{a_2b} + a_2)}\\), which yields the interest rate rule (Equation 10.4).\nEquilibrium solutions and stability analysis\nBy definition, in the steady state we have \\(y^*=y_e\\). This implies that \\(r^*=r_s\\). From this, it follows that \\(\\pi^* = \\pi^T\\).\nTo analyse the dynamic stability of the model, we rewrite it as a system of first-order difference equations. To this end, substitute Equation 10.1 into Equation 10.2, which yields: \\[\n\\pi_t = \\pi_{t-1} + a_2(A - a_1r_{t-1}-y_e)\n\\tag{10.7}\\]\nSubstitute this equation into Equation 10.4, which yields: \\[\nr_t= r_{s} + a_3[\\pi_{t-1} + a_2(A - a_1r_{t-1}-y_e) - \\pi^T].\n\\tag{10.8}\\]\nThe Jacobian matrix of the system in Equation 10.1, Equation 10.7, and Equation 10.8 is given by: \\[\nJ=\\begin{bmatrix} 0& 0 &-a_1 \\\\0 & 1 & -a_1 a_2 \\\\ 0 & a_3 & -a_1 a_2 a_3 \\end{bmatrix}.\n\\] The eigenvalues of the Jacobian can be obtained from the characteristic polynomial \\(\\lambda^3 - Tr(J)\\lambda^2 + [Det(J_1) + Det(J_2) + Det(J_3)]\\lambda - Det(J) = 0\\), where \\(Tr(J)\\) and \\(Det(J\\)) are the trace and determinant, respectively, and \\(Det(J_i)\\) refers to the \\(i_{th}\\) principal minor of the matrix. As there is a column in the Jacobian that only contains zeros, it follows that the matrix is singular and will have a zero determinant. In addition, all principal minors turn out to be zero. The characteristic polynomial thus reduces to \\(\\lambda^2[\\lambda - Tr(J)]=0\\). From this, it is immediate that \\(\\lambda_{1,2}=0\\) and \\(\\lambda_{3}=Tr(J)\\), where \\(Tr(J)=1-a_1a_2a_3=\\frac{1}{1+a_2^2b}\\). Stability requires the single real eigenvalue to be smaller than unity (in absolute terms). With \\(\\lambda_3=\\frac{1}{1+a_2^2b}\\), stability thus only requires \\(a_2 \\neq 0\\) and \\(b&gt;0\\), i.e. the output gap needs to impact inflation (otherwise the key channel through which interest rate policy brings inflation back on target is blocked) and the central bank needs to assign a (non-negative) loss to deviations of actual inflation from its target.5\nWe can verify these analytical solutions by comparing them with the results from the numerical solution:\n\n# Construct Jacobian matrix \nJ=matrix(c(0,0,-a1,\n           0,1,-a1*a2,\n           0,a3,-a1*a2*a3), 3, 3, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values &lt;- ev$values)\n\n[1] 0.6711409 0.0000000 0.0000000\n\n# Obtain determinant and trace\ndet(J)       # determinant\n\n[1] 0\n\nsum(diag(J)) # trace\n\n[1] 0.6711409\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Construct Jacobian matrix \nJ = np.array([[0, 0, -a1],\n          [0, 1, -a1 * a2],\n          [0, a3, -a1 * a2 * a3],])\n\n# Calculate eigenvalues\neigenvalues = np.linalg.eigvals(J)\n\n# Print the resulting eigenvalues\nprint(eigenvalues)\n\n# Calculate the determinant and trace of the Jacobian matrix\ndeterminant = np.linalg.det(J)\ntrace = np.trace(J)\nprint(determinant)\nprint(trace)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#references",
    "href": "a_new_keynesian_3_equation_model.html#references",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nCarlin, Wendy, and David Soskice. 2014. Macroeconomics. Instititions, Instability, and the Financial System. Oxford University Press.\n\n\nGalí, Jordi. 2018. “The State of New Keynesian Economics: A Partial Assessment.” Journal of Economic Perspectives 32 (3): 87–112. https://doi.org/10.1257/jep.32.3.87.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#footnotes",
    "href": "a_new_keynesian_3_equation_model.html#footnotes",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "",
    "text": "See Galí (2018) for an overview.↩︎\nNote that this is quite different from conventional New Keynesian dynamic general equilibrium models in which the dynamic element stems from agents with rational expectations that react to serially correlated shocks.↩︎\nSee chapter 2 of Carlin and Soskice (2014) for details.↩︎\nSee chapter 2 of Carlin and Soskice (2014) for details.↩︎\nAs mentioned in footnote 2, this property of the Carlin-Soskice model is very different from conventional New Keynesian models with rational expectations. In these models, variables such as output and inflation are driven by the ‘forward-looking’ behaviour of rational agents, i.e. they depend on expectational terms for their current values rather than lagged values. To ensure what is called ‘determinancy’, these forward-looking variables must adjust fast (or ‘jump’) to bring the economy back onto a path that is consistent with the optimising equilibrium. This requires the number of jump variables to be matched by an equal number of unstable roots (i.e. being outside the unit circle).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html",
    "href": "a_conflict_inflation_model.html",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "",
    "text": "Overview\nThis model is a version of the conflicting-claims approach to inflation that has been developed in the Marxian and post-Keynesian tradition (Rowthorn (1977)).1 The conflict inflation approach argues that inflation is driven by distributional conflict between price-setting firms and wage-setting workers. Each social class aspires a share of real income that is inconsistent with the claims of the other class. Workers gradually adjust nominal wages to reach a real wage target. Firms, by contrast, gradually adjust prices to achieve an implicit real wage target. The (implicit) real wage target of firms may stem from an (explicit) profitability target. Profitability, in turn, depends on the unit cost of firms. With nominal wages being a key component of those unit cost, any attempt by workers to raise real wages through higher nominal wages will eat into firms’ profitability, which will respond by raising prices. Equally, any attempt by firms to raise profitability by setting higher prices will undermine real wages and evoke a response by workers. This interplay between mutually inconsistent claims drives the inflationary process and the equilibrium real wage. Distributional outcomes in this model depend on the distributional targets of workers and firms as well as their ability to adjust wages and prices, which in turn may be affected by their relative bargaining power and labour market institutions.\nWe present a simplified version of the three-sector conflict inflation model in Wildauer et al. (2023) that examines the inflationary and distributional effects of energy price shocks.2 A final output sector uses energy as an intermediate input. Exogenous shocks to the prices of energy inputs can trigger temporary ‘price-wage spirals’, where firms raise prices to defend their profit margins, which in turn induces workers to raise nominal wages, which prolongs the inflationary shocks. While real wages fall, the economy-wide profit share rises.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#the-model",
    "href": "a_conflict_inflation_model.html#the-model",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "The Model",
    "text": "The Model\nThe model is given by the following equations:\n\\[\n\\Omega_t = \\frac{w_t}{p_t}\n\\tag{11.1}\\] \\[\nw_{t}  = w_{t-1}\\left[ 1 + \\phi(\\Omega^W - \\Omega_{t-1}) \\right]\n\\tag{11.2}\\]\n\\[\np_t= p_{t-1} \\left[ 1 + \\psi (r^T - r_{t-1}) \\right]\n\\tag{11.3}\\]\n\\[\np^T_t=(1+\\theta^T)\\left(w_t + \\delta p^E\\right)  \n\\tag{11.4}\\]\n\\[\nr^T=\\frac{\\theta^T}{1+\\theta^T}\n\\tag{11.5}\\]\n\\[\nr_T=1-\\Omega_t - \\delta \\epsilon\n\\tag{11.6}\\] \\[\np^E_t = \\epsilon p_t\n\\tag{11.7}\\]\nwhere \\(\\Omega\\), \\(w\\), \\(p\\), \\(\\Omega^W\\), \\(r^T\\), \\(r\\), \\(p^T\\), and \\(p^E\\) are the real wage, the nominal wage, the price level, workers’ desired real wage, firms’ desired profit margin, the realised profit margin, firms’ desired price level, and the nominal energy price, respectively.\nEquation 11.1 defines the real wage \\(\\Omega\\). Equation 11.2 specifies the dynamics of wage setting. Workers set the growth rate of nominal wages \\(w\\) proportionally to the gap between their target real wage \\(\\Omega^W\\) and the actual real wage \\(\\Omega\\). The target real wage of workers is taken to be exogenous in this version of the model.3 By Equation 11.3, firms set the price inflation rate in a symmetric manner, responding to the deviation of the desired profit margin \\(r^T\\) from the actual profit margin \\(r\\). Equation 11.4 specifies the desired price level of firms, which charge a desired markup \\(\\theta^T\\) on their unit variable cost. Unit costs in this model consist of two components: (i) unit labour cost given by \\(w_t\\) (where we normalise labour productivity to unity for simplicity such that \\(\\frac{Y}{L}=1\\)), and (ii) unit energy cost \\(\\delta p^E\\), where \\(\\delta =\\frac{E}{Y}\\) is the (exogenous) energy intensity and \\(p^E\\) is the nominal energy price. The profit margin is defined as profits over gross output: \\(r=\\frac{\\Pi}{pY}=\\frac{pY-wL-p^E E}{pY}\\). The target profit margin as implied by the desired price level is then \\(r^T = \\frac{p^T - (w_t + \\delta p^E) }{p^T}\\), yielding Equation 11.5. The desired markup \\(\\theta^T\\) is considered exogenous in this version of the model.4 The actual or realised profit margin is given by Equation 11.6, where \\(\\epsilon=\\frac{p^E}{p}\\) is the real energy price. Finally, by Equation 11.7, the real energy price \\(\\epsilon\\) is taken to be exogenous (and subject to shocks), implying that the nominal energy price must grow at the same rate as the price level.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#simulation",
    "href": "a_conflict_inflation_model.html#simulation",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. In scenario 2, the real energy price \\(\\epsilon\\) increases. In scenario 3, the target markup \\(\\theta^T\\) rises. In scenario 4, the target real wage \\(\\Omega^W\\) rises.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(\\phi\\)\n\\(\\psi\\)\n\\(\\delta\\)\n\\(\\epsilon\\)\n\\(\\theta^T\\)\n\\(\\Omega^W\\)\n\n\n\n1: baseline\n1\n1\n1\n0.55\n0.4\n0.2\n\n\n2: rise in real energy price \\((\\epsilon)\\)\n\n1\n1\n1\n0.8\n0.4\n0.2\n\n\n3: rise in target markup \\((\\theta^T)\\)\n\n1\n1\n1\n0.55\n0.6\n0.2\n\n\n4: rise in target real wage \\((\\Omega^W)\\)\n\n1\n1\n1\n0.55\n0.4\n0.3\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n#Set number of periods\nQ = 300\n\n# Set number of scenarios (including baselines)\nS=4\n\n# Set period in which exogenous shift will occur\nq=50\n\n#Create (S x Q) matrices in which equilibrium solutions from different parameterisations will be stored\nomega=matrix(data=0.5, nrow=S, ncol=Q)   # real wage\nw=matrix(data=0.1, nrow=S, ncol=Q)       # nominal wage\np=matrix(data=0.5, nrow=S, ncol=Q)       # price level\nw_hat=matrix(data=0.1, nrow=S, ncol=Q)   # growth rate of nominal wages\np_hat=matrix(data=0.1, nrow=S, ncol=Q)   # growth rate of prices = inflation rate\np_T=matrix(data=0.5, nrow=S, ncol=Q)     # firms' desired price level\nomega_f=matrix(data=0.5, nrow=S, ncol=Q) # firms' desired real wage \np_E=matrix(data=0.5, nrow=S, ncol=Q)   # nominal energy price\nr_T=matrix(data=0.5, nrow=S, ncol=Q)     # target profit margin\nr=matrix(data=0.5, nrow=S, ncol=Q)       # realised profit margin\n\n# Set constant parameter values\nphi=1     # adjustment speed of nominal wages\npsi=1   # adjustment speed of prices\ndelta=1   # energy intensity\n\n# Set and initialise exogenous variables/parameters that will be shifted\nepsilon=matrix(data=0.55, nrow=S, ncol=Q)  # real energy price\ntheta_T=matrix(data=0.4, nrow=S, ncol=Q)       # target markup\nomega_w=matrix(data=0.2, nrow=S, ncol=Q)   # target real wage of workers\n\n# Set parameter values for different scenarios\nepsilon[2,q:Q]=0.8 # scenario 2: rise in real energy price\ntheta_T[3,q:Q]=0.6     # scenario 3: rise in target markup\nomega_w[4,q:Q]=0.3 # scenario 4: rise in target real wage of workers\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n    \n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # iterate the model 1000-times in each period\n    \n    #(1) Real wage\n    omega[i,t] =w[i,t]/p[i,t]\n      \n    #(2) Nominal wage\n    w[i,t] = w[i,t-1]*(1 + phi*(omega_w[i,t-1] - omega[i,t-1]))\n    \n    #(3) Price level\n    p[i,t] = p[i, t-1]*(1 + psi*(r_T[i, t-1] - r[i, t-1]))\n    \n    #(4) Firms' desired real wage\n    omega_f[i,t] = w[i,t]/p_T[i,t]\n    \n    #(5) Firms' desired price level\n    p_T[i,t] = (1 + theta_T[i,t])*(w[i,t] + delta * p_E[i,t])\n    \n    #(6) Nominal energy price\n    p_E[i,t]=epsilon[i,t]*p[i,t]\n    \n    # Target profit margin\n    r_T[i, t-1] = theta_T[i, t]/(1 + theta_T[i, t])\n    \n    # Realised profit margin\n    r[i, t] = 1 - omega[i, t] - epsilon[i,t]*delta\n    \n    # Growth rate of nominal wages\n    w_hat[i,t]= (w[i,t]- w[i,t-1])/w[i,t-1]\n    \n    # Growth rate of prices = inflation rate\n    p_hat[i,t]= (p[i,t]- p[i,t-1])/p[i,t-1]\n\n  } # close iterations loop\n }  # close time loop\n}   # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 300\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which exogenous shift will occur\nq = 50\n\n# Create (S x Q) matrices in which equilibrium solutions from different parameterizations will be stored\nomega = np.full((S, Q), 0.5)  # real wage\nw = np.full((S, Q), 0.1)      # nominal wage\np = np.full((S, Q), 0.5)      # price level\nw_hat = np.full((S, Q), 0.1)  # growth rate of nominal wages\np_hat = np.full((S, Q), 0.1)  # growth rate of prices = inflation rate\np_T = np.full((S, Q), 0.5)    # firms' desired price level\nomega_f = np.full((S, Q), 0.5) # firms' desired real wage \np_E = np.full((S, Q), 0.5)  # nominal energy price\nr_T = np.full((S, Q), 0.5)    # target profit margin\nr = np.full((S, Q), 0.5)      # realised profit margin\n\n# Set constant parameter values\nphi = 1     # adjustment speed of nominal wages\npsi = 1   # adjustment speed of prices\ndelta = 1   # energy intensity\n\n# Set and initialize exogenous variables/parameters that will be shifted\nepsilon = np.full((S, Q), 0.55)  # real energy price\ntheta_T = np.full((S, Q), 0.4)       # target markup\nomega_w = np.full((S, Q), 0.2)   # target real wage of workers\n\n# Set parameter values for different scenarios\nepsilon[1, q:Q] = 0.8  # scenario 2: rise in real energy price\ntheta_T[2, q:Q] = 0.6      # scenario 3: rise in target markup\nomega_w[3, q:Q] = 0.3  # scenario 4: rise in target real wage of workers\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for _ in range(1000):  # iterate the model 1000-times in each period\n            \n            # (1) Real wage\n            omega[i, t] = w[i, t] / p[i, t]\n              \n            # (2) Nominal wage\n            w[i, t] = w[i, t-1] * (1 + phi * (omega_w[i, t-1] - omega[i, t-1]))\n            \n            # (3) Price level\n            p[i, t] = p[i, t-1] * (1 + psi * (r_T[i, t-1] - r[i, t-1]))\n            \n            # (4) Firms' desired real wage\n            omega_f[i, t] = w[i, t] / p_T[i, t]\n            \n            # (5) Firms' desired price level\n            p_T[i, t] = (1 + theta_T[i, t]) * (w[i, t] + delta * p_E[i, t])\n            \n            # (6) Nominal energy price\n            p_E[i, t] = epsilon[i, t] * p[i, t]\n            \n            # Target profit margin\n            r_T[i, t-1] = theta_T[i, t] / (1 + theta_T[i, t])\n            \n            # Realised profit margin\n            r[i, t] = 1 - omega[i, t] - epsilon[i, t] * delta\n            \n            # Growth rate of nominal wages\n            w_hat[i, t] = (w[i, t] - w[i, t-1]) / w[i, t-1]\n            \n            # Growth rate of prices = inflation rate\n            p_hat[i, t] = (p[i, t] - p[i, t-1]) / p[i, t-1]\n            \n\n\n\n\nPlots\nFigure 11.1 displays the dynamics of nominal wages and prices (in levels), both of which exhibit exponential growth. Figure 11.2 plots the corresponding growth rates: the price and wage inflation rates. It can be seen that after an initial adjustment period, both rates converge on the same value, implying a constant real wage (and a constant profit margin).\n\n# Set start and end periods for plots\nTmin =3\nTmax=300\n\n# Prices and wages (baseline)\nplot(p[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"p, w\") \ntitle(main=\"Prices and wages (baseline)\", cex=0.8)\nlines(w[1, Tmin:Tmax],lty=2)\nlegend(\"topleft\", legend=c(\"p\", \"w\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.1: Prices and wages (baseline)\n\n\n\n\n\n# Set start and end periods for plots\nTmin =3\nTmax=60\n\n# Price and wage inflation (in %) (baseline)\nplot(100*p_hat[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"%\", ylim=range(100*p_hat[1, Tmin:Tmax], 100*w_hat[1, Tmin:Tmax])) \ntitle(main=\"Price and wage inflation (baseline)\", cex=0.8)\nlines(100*w_hat[1, Tmin:Tmax],lty=2)\nlegend(\"topright\", legend=c(expression(hat(p)), expression(hat(w))),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.2: Price and wage inflation (baseline)\n\n\n\n\nFigure 11.3 displays the energy price shock (scenario 2), where the real energy price rises permanently.5 As a result, there is a bout in the inflation rate, followed by an increase in the wage inflation rate. This reaction may be characterised as a (temporary) ‘price-wage spiral’ (Wildauer et al. (2023)), where firms react to the cost shock by raising prices to protect their profit margins, which trigger a response by workers to defend their real wages, which prolongs the inflationary shock. However, the inflation rate then embarks on a gradual downward convergence towards a new equilibrium that is higher than the one before the shock. Since the price inflation rate exceeds the wage inflation rate during the adjustment process, the real wage falls in response to the increase in the real energy price.\n\n# Set start and end periods for plots\nTmin =10\nTmax=100\n\n# Inflation and real wage in energy price shock scenario\nplot(100*p_hat[2, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=expression(hat(p))) \ntitle(main=\"Wage and price inflation and real wage, energy price shock (scen. 2)\", cex=0.8)\nlines(100*w_hat[2, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(hat(w)), side = 2, line = 3, at=12)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(omega[2, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=3, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(omega[2, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(omega[2, Tmin:Tmax]))  \nmtext(expression(Omega), side = 4, line = 3)\nlegend(\"topright\", legend=c(expression(hat(p)),expression(hat(w)), expression(Omega)),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.3: Price and wage inflation and real wage (energy price shock)\n\n\n\n\nFigure 11.4 considers the scenario where the target markup of firms rises. The resulting dynamics are very similar to the energy price shock: the inflation rate spikes, triggering a response in nominal wages that is weaker than the increase in inflation. As a result, the real wage falls until a new equilibrium with a higher inflation rate has been reached. In contrast to the energy price shock, both the profit margin and the profit share must increase in this scenario.\n\n# Set start and end periods for plots\nTmin =30\nTmax=80\n\n# Inflation and real wage in scenario 3\nplot(100*p_hat[3, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=expression(hat(p))) \ntitle(main=\"Price and wage inflation and real wage, rise in target markup (scen. 3)\", cex=0.8)\nlines(100*w_hat[3, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(hat(w)), side = 2, line = 3, at=7)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(omega[3, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=3, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(omega[3, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(omega[3, Tmin:Tmax]))  \nmtext(expression(Omega), side = 4, line = 3)\nlegend(\"topright\", legend=c(expression(hat(p)),expression(hat(w)), expression(Omega)),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.4: Increase in target markup\n\n\n\n\nFigure 11.5 displays scenario 4, where the target real wage of workers rises. The wage inflation rate shoots up, which is followed by an increase in price inflation. As nominal wages temporarily grow faster than prices, the real wage increases. By implication, both profit share and margin will fall.\nTaken together, scenarios 3 and 4 illustrate that besides cost shocks, exogeneous changes in the price- and wage-setting behaviour of firm and workers, respectively, will change the equilibrium inflation rate as well as income distribution. Such changes could stem from increases in market power (scenario 3) or fiercer industrial action by workers (scenario 4). An increase of the claim of either party on total real output will result in elevated social conflict, reflected in an increase in the inflation rate. The resulting distributional effect will depend on which party initiates the conflict.\n\n# Inflation and real wage in scenario 4\nplot(100*p_hat[4, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=expression(hat(p)), ylim=range(100*p_hat[4, Tmin:Tmax], 100*w_hat[4, Tmin:Tmax])) \ntitle(main=\"Price and wage inflation real wage, rise in target real wage (scen. 4)\", cex=0.8)\nlines(100*w_hat[4, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(hat(w)), side = 2, line = 3, at=7.5)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(omega[4, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=3, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(omega[4, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(omega[4, Tmin:Tmax]))  \nmtext(expression(Omega), side = 4, line = 3)\nlegend(\"topright\", legend=c(expression(hat(p)),expression(hat(w)), expression(Omega)),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.5: Increase in target real wage of workers\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Plot (here only inflation in scenario 2)            \nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmin = 9   # Zero-based index (equivalent to Tmin=10 in R)\nTmax = 100\n\n# Set up the main plot\nfig, ax1 = plt.subplots()\n\n# Plot inflation rates (price and wage growth rates) on the primary y-axis\nax1.plot(100 * p_hat[1, Tmin:Tmax], label=r'$\\hat{p}$', color=\"black\", linewidth=2, linestyle=\"-\")  # price inflation\nax1.plot(100 * w_hat[1, Tmin:Tmax], label=r'$\\hat{w}$', color=\"black\", linewidth=2, linestyle=\"--\")  # wage inflation\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(r'$\\hat{p}$, $\\hat{w}$')\nax1.set_ylim(0, 30)  # Adjust this limit as needed based on your data\n\n# Add secondary y-axis for real wage\nax2 = ax1.twinx()\nax2.plot(omega[1, Tmin:Tmax], label=r'$\\Omega$', color=\"black\", linewidth=2, linestyle=\":\")  # real wage\nax2.set_ylabel(r'$\\Omega$')\nax2.set_ylim(0, 0.2)  # Set range based on omega values\n\n# Titles and legends\nplt.title(\"Wage and price inflation and real wage, energy price shock (scenario 2)\", fontsize=10)\nax1.legend(loc=\"upper left\", frameon=False, fontsize=8)\nax2.legend(loc=\"upper right\", frameon=False, fontsize=8)\n\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#a-closer-look-at-the-effect-of-energy-price-shocks-on-profits",
    "href": "a_conflict_inflation_model.html#a-closer-look-at-the-effect-of-energy-price-shocks-on-profits",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "A closer look at the effect of energy price shocks on profits",
    "text": "A closer look at the effect of energy price shocks on profits\nThe model can be used to study the effects of an energy price shock on different measures of profitability and income distribution. Table 2 provides an overview of these measures.\nTable 2: Measures of profits\n\n\n\n\n\n\n\n\n\nDefinition\nModel equation\nEffect of energy price shock6 \\((\\uparrow \\epsilon)\\)\n\n\n\n\nProfit margin = profit share of energy sector\n\\[ r^E = \\pi^E = \\frac{\\Pi^E}{p^E E} \\]\n\\[ r^E = \\frac{p^E E - w^E L^E}{p^E E} = 1 - \\frac{\\Omega^E}{\\epsilon} \\]\nPositive\n\n\nProfit margin of final output sector\n\\[ r = \\frac{\\Pi}{pY} \\]\n\\[ r = \\frac{pY - wL - p^E E}{pY} = 1 - \\Omega - \\delta \\epsilon \\]\nNegative\n\n\nProfit share of final output sector\n\\[ \\pi = \\frac{\\Pi}{pVA} \\]\n\\[ \\pi = \\frac{pY - wL - p^E E}{pY - p^E E} = 1 - \\frac{\\Omega}{1 - p^E \\epsilon} \\]\nAmbiguous\n\n\nTotal profit share\n\\[ \\pi^{Total} = \\frac{\\Pi + \\Pi^E}{pY} \\]\n\\[ \\pi^{Total} = \\frac{pY - w^E L^E - wL}{pY} = 1 - \\delta \\Omega^E - \\Omega \\]\nPositive\n\n\n\nNote: \\(\\Pi\\) represents nominal profits, \\(E\\) is the output of the energy sector, which is an input to the final output \\(Y\\). The real wage of the energy sector \\(\\Omega^E = w^E/p\\) is exogenous. Labour productivity in both sectors is normalised to unity: \\(L^E / E = L / Y = 1\\). \\(VA\\) is value added.\nThe profit margin \\(r\\) is defined as the share of profits in gross output. By contrast, the profit share \\(\\pi\\) is defined as the share of profits in value added, i.e. output net of intermediate inputs. For the energy sector, which in this model does not use any intermediate inputs, the profit margin and profit share coincide. With the real wage in the energy sector assumed exogenous, a real energy price increase will unambiguously raise the profits of the energy sector. For the final output sector that uses energy as an input, an energy price shock will lower the profit margin due to the increase in energy cost. However, the effect on the final output sector’s profit share are ambiguous and will depend on the relative ability of workers and firms to defend their income targets in response to the shock. Finally, the total profit share incorporates the profits of the energy input sector and the final output sector (this assumes that the energy sector is domestic). An increase in the real energy price has an unambiguously positive effect on the economy-wide profit share.\nIn Figure 11.6, it can be seen how the energy price shock affects the profit margin and profit share of the final output sector in the simulations. While the profit margin falls due to the increase in energy cost, the profit share rises. This is because for the chosen parameterisation, we have \\(\\psi r^T-\\phi\\Omega^W&gt;0\\), for which \\(\\frac{\\partial \\pi}{\\partial \\epsilon} &gt; 0\\).7 Thus, if the price-setting power of firms and their target profit margins \\(\\psi r^T\\) are sufficiently large relative to wage-setting power and real wage target of workers \\(\\phi\\Omega^W\\), profit shares of domestic non-energy sectors may rise in response to an energy cost shock.\n\n# Calculate final output profit share\npi=(p-w-p_E*delta)/(p-p_E*delta)\n\n# Check if psi*r_T &gt; phi*omega_w, implying that the effect of an energy price increase on the profit share of the final output sector is positive\nprint(psi*r_T[1,1] - phi*omega_w[1,1] &gt;0)\n\n[1] TRUE\n\n# Plot profit margin and profit share in energy price shock scenario\nplot(r[2, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"r,\", ylim=range(r[2, Tmin:Tmax], pi[2, Tmin:Tmax])) \ntitle(main=\"Profit margin vs profit share, energy price shock (scenario 2)\", cex=0.8)\nlines(pi[2, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(pi), side = 2, line = 3, at=0.4)\nlegend(\"right\", legend=c(\"r\", expression(pi)),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.6: Profit margin and profit share (energy price shock)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#directed-graph",
    "href": "a_conflict_inflation_model.html#directed-graph",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 9 variables: \n  # endogenous: (1) Omega, (2) w, (3) p, (4) r^T, (5) r, (6) p_E\n  # exogenous: (7) epsilon, (8) \\theta^T, (9) Omega^W\n\n              #O w p rF r g e mF OW\nM_mat=matrix(c(0,1,1, 0,0,0,0, 0, 0,  # Omega\n               1,0,0, 0,0,0,0, 0, 1,  # w\n               0,0,0, 1,1,0,0, 0, 0,  # p\n               0,0,0, 0,0,0,0, 1, 0,  # rf\n               1,0,0, 0,0,0,1, 0, 0,  # r\n               0,0,1, 0,0,0,1, 0, 0,  # p_E\n               0,0,0, 0,0,0,0, 0, 0,  # epsilon\n               0,0,0, 0,0,0,0, 0, 0,  # \\theta^T\n               0,0,0, 0,0,0,0, 0, 0),  # Omega^W\n               9, 9, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(expression(Omega), \"w\", \"p\", expression(r^T), \"r\",\n             expression(p_E), expression(epsilon), expression(theta^T), expression(Omega^W))\n\n\n# Plot directed graph matrix\nplot(dg, main=\"Directed graph of conflict inflation model\", vertex.size=25, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.4, edge.width=1.1, edge.size=2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Directed graph\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 9 variables\n# endogenous: (1) Omega, (2) w, (3) p, (4) r^T, (5) r, (6) p_E\n# exogenous: (7) epsilon, (8) \\theta^T, (9) Omega^W\nM_mat = np.array([\n    [0, 1, 1, 0, 0, 0, 0, 0, 0],  # Omega\n    [1, 0, 0, 0, 0, 0, 0, 0, 1],  # w\n    [0, 0, 0, 1, 1, 0, 0, 0, 0],  # p\n    [0, 0, 0, 0, 0, 0, 0, 1, 0],  # r^T\n    [1, 0, 0, 0, 0, 0, 1, 0, 0],  # r\n    [0, 0, 1, 0, 0, 0, 1, 0, 0],  # p_E\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],  # epsilon\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],  # \\theta^T\n    [0, 0, 0, 0, 0, 0, 0, 0, 0]   # Omega^W\n])\n\n# Create adjacency matrix by transposing the auxiliary Jacobian matrix\nA_mat = M_mat.T\n\n# Create a directed graph from the adjacency matrix using networkx\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: r'$\\Omega$', 1: \"w\", 2: \"p\", 3: r'$r^T$', 4: \"r\", 5: r'$p^E$',\n            6: r'$\\epsilon$', 7: r'$\\theta^T$', 8: r'$\\Omega^W$'}\n\n# Plot the graph\npos = nx.spring_layout(G, k=0.6)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\n\nplt.title(\"Directed graph of conflict inflation model\", fontsize=12)\nplt.show()\n\n\n\n\nThe key exogenous variables in this version of the conflict inflation model are the real energy price \\(\\epsilon\\), the target markup \\(\\theta^T\\), and the target real wage of workers \\(\\Omega^W\\). The first two exogenous variables feed into the endogenous conflict inflation process via their impact on the realised profit margin \\(r\\) and the desired profit margin \\(r^T\\), respectively. The gap between desired and realised profit margins, in turn, impact price setting, the real wage, and then wage setting. By contrast, the target real wage of workers enters the inflationary process via its direct impact on nominal wages, which then impacts real wages, the realised profit margin, and then price setting. The directed graph thus highlights the joint determination and endogenous interaction of prices, wages, and income distribution.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#analytical-discussion",
    "href": "a_conflict_inflation_model.html#analytical-discussion",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo study the properties of the model, we reduce it to a first-order dynamic system in \\(w_t\\) and \\(p_t\\). To this end, substitute Equation 11.1 into Equation 11.2 to obtain the equation for \\(w_t\\). Next, substitute Equation 11.6, Equation 11.5 and Equation 11.1 into Equation 11.3. This gives the system:\n\\[\nw_{t+1} = w_{t}\\left[1+ \\phi\\left(\\Omega^W - \\frac{w_t}{p_t}\\right)\\right] \\\\\n\\tag{11.8}\\] \\[\np_{t+1} = p_{t} \\left[1+\\psi\\left(\\frac{w_t}{p_t} - \\frac{1}{1+\\theta^T} + \\delta \\epsilon \\right) \\right].\n\\tag{11.9}\\]\nNext, let’s introduce the definitions \\(\\frac{w_{t+1} -w_{t}}{w_{t}} = \\hat{w_t}\\) and \\(\\frac{p_{t+1} -p_{t}}{p_{t}} = \\hat{p_t}\\) for the growth rates of wages and prices, respectively. The equilibrium in this model is given by a real wage and inflation rate \\((\\Omega^*, \\hat{p}^*)\\) for which \\(\\hat{w_t}=\\hat{p_t}\\), i.e. wages and prices grow at the same rate, such that the real wage is constant. Imposing this equilibrium condition using Equation 11.8 and Equation 11.9 yields:\n\\[\\Omega^* = \\frac{\\phi \\Omega^W+ \\psi \\left(\\frac{1}{1+\\theta^T}- \\delta \\epsilon \\right)}{\\phi + \\psi}\n\\tag{11.10}\\]\nand\n\\[\n\\hat{p}^* = \\phi \\psi \\left[\\frac{ \\Omega^W - \\left(\\frac{1}{1+\\theta^T}- \\delta \\epsilon \\right)}{\\phi + \\psi}\\right],\n\\tag{11.11}\\]\nwhere the term \\(\\left(\\frac{1}{1+\\theta^T}- \\delta \\epsilon\\right)\\) can also be interpreted as firms’ implicit real wage target \\(\\Omega^F\\), such that for a positive equilibrium inflation rate \\(\\hat{p}^* &gt;0\\) , we need \\(\\Omega^W &gt; \\Omega^F = \\frac{1}{1+\\theta^T}- \\delta \\epsilon\\). Thus, workers’ and firms’ real wage targets need to be mutually inconsistent for inflation to emerge in equilibrium.\nWith these equilibrium solutions, we can show that increases in \\(\\theta^T\\) and \\(\\epsilon\\) reduce the equilibrium real wage and raise the equilibrium inflation rate, whereas increases in \\(\\Omega^W\\) raise the equilibrium real wage and raise the inflation rate:\n\\[\n\\frac{\\partial \\Omega^*} {\\partial \\theta^T} = -\\frac{\\psi}{(\\psi + \\phi)(1+\\theta^T)^2} &lt; 0,\n\\] \\[\n\\frac{\\partial \\hat{p}^*}{\\partial \\theta^T} = \\frac{\\phi\\psi}{(\\psi + \\phi)(1+\\theta^T)^2} &gt; 0,\n\\]\n\\[\n\\frac{\\partial \\Omega^*}{\\partial \\epsilon} = -\\frac{\\psi \\delta}{\\psi + \\phi} &lt; 0,\n\\] \\[\n\\frac{\\partial \\hat{p}^*}{\\partial \\epsilon} = \\frac{\\psi \\phi \\delta}{\\psi + \\phi} &gt; 0,\n\\]\n\\[\n\\frac{\\partial \\Omega^*} {\\partial \\Omega^W} = \\frac{\\phi}{\\psi + \\phi} &gt; 0,\n\\] \\[\n\\frac{\\partial \\hat{p}^*}{\\partial \\Omega^W} = \\frac{\\phi\\psi}{\\psi + \\phi} &gt; 0.\n\\]\nUsing the result for \\(\\frac{\\partial \\Omega^*}{\\partial \\epsilon}\\), we can easily work out the effects on the different measure of profitability listed in Table 2:\n\\[\n\\frac{\\partial r^E}{\\partial \\epsilon} = \\frac{\\Omega^E}{\\epsilon^2} &gt; 0,\n\\]\n\\[\n\\frac{\\partial r}{\\partial \\epsilon} =  -\\frac{\\delta \\phi}{\\psi + \\phi} &lt; 0,\n\\]\n\\[\n\\frac{\\partial \\pi}{\\partial \\epsilon} =   \\frac{\\delta(\\psi r^T-\\phi\\Omega^W)}{(\\psi + \\phi)(1-\\epsilon\\delta)^2} \\lesseqgtr 0,\n\\]\n\\[\n\\frac{\\partial \\pi^{Total}}{\\partial \\epsilon} =  \\frac{\\delta \\psi }{\\psi + \\phi} &gt; 0.\n\\]\nNext, to analyse dynamics of the model, we write down the Jacobian matrix of the system in Equation 11.8 and Equation 11.9:\n\\[\nJ(w,p)=\\begin{bmatrix}\n            1 + \\hat{w} - \\phi \\Omega & \\phi {\\Omega}^2   \\\\\n            \\psi & 1 + \\hat{p} - \\psi \\Omega   \\\\\n        \\end{bmatrix},\n\\] where we used \\(\\hat{w}=\\phi\\left(\\Omega^W - \\frac{w_t}{p_t}\\right)\\) and \\(\\hat{p}=\\psi\\left(\\frac{w_t}{p_t} - \\frac{1}{1+\\theta^T} + \\delta \\epsilon \\right)\\) to simplify the expressions inside the Jacobian.\nThe stability conditions for two-dimensional systems in discrete time are:\n\\[\n1+tr(J)+det(J)&gt;0,\n\\] \\[\n1-tr(J)+det(J)&gt;0,\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nWe know that this system will be unstable, because prices and wages will grow exponentially in equilibrium. We thus want to derive the condition under which the system becomes unstable and generates conflict inflation.\nImposing \\(\\hat{w_t}=\\hat{p_t}\\), the trace and determinant of the Jacobian matrix in equilibrium are given by:\n\\[\ntr(J)=2(1+\\hat{w}) - \\Omega(\\phi+\\psi),\n\\]\n\\[\\begin{equation}\n\n\\det(J)=1-\\Omega(\\phi+\\psi)+\\hat{w}[2+\\hat{w} - \\Omega(\\phi+\\psi)].\n\n\\end{equation}\n\\]\nLet’s focus on the second stability condition, which is:\n\\[\n1-tr(J)+det(J)= \\hat{w}[\\hat{w} - \\Omega(\\phi+\\psi)]&gt;0.\n\\]\nSubstituting the equilibrium solutions for \\(\\hat{w}^*\\) and \\(\\omega^*\\) into the term insight the square brackets yields:\n\\[\n-\\hat{w}^*\\left(\\frac{\\omega^W\\phi^2+(2\\phi+\\psi)\\psi \\Omega^F}{\\phi+\\psi}\\right)&lt;0.\n\\]\nThe term inside the brackets will be positive for meaningful economic values. The term outside the brackets will be negative if \\(\\hat{w}^*=\\hat{p^*}&gt;0\\), i.e. there is positive inflation, which in turn requires \\(\\Omega^W &gt; \\Omega^F\\), i.e. workers’ real wage target needs to exceed firms’ real wage target.\nWe can confirm these analytical results numerically. First, let’s confirm the solutions for the equilibrium real and the equilibrium inflation rate as well as the ‘instability condition’ that the target real wage of workers needs to exceed the target real wage of firms.\n\n## Check solution for equilibrium real wage\n# Analytical\n(omega_eq= (phi*omega_w[1,1]+psi*(1/(1+theta_T[1,1]) -delta*epsilon[1,1]))/(phi+psi))\n\n[1] 0.1821429\n\n# Numerical\nomega[1,Q]\n\n[1] 0.1821429\n\n## Check solution for equilibrium inflation rate\n# Analytical\nphi*psi*(omega_w[1,1]-(1/(1+theta_T[1,1]) -delta*epsilon[1,1]))/(phi+psi)\n\n[1] 0.01785714\n\n# Numerical\np_hat[1,Q]\n\n[1] 0.01785714\n\n## Check condition for instability: Omega^W &gt; Omega^F\nprint(omega_w[1,1] &gt; 1/(1+theta_T[1,1]) -delta*epsilon[1,1])\n\n[1] TRUE\n\n\nNext, we compute the Jacobian matrix of the simulated model (for the baseline), obtain the eigenvalues, eigenvectors, trace, and determinant. We then check the stability conditions. We find that the second stability condition is indeed violated.\n\n## Check eigenvalues of Jacobian matrix\n# Define matrix\nJ=matrix(c(1+p_hat[1,Q]-phi*omega[1,Q], phi*omega[1,Q]^2,\n           psi, 1+p_hat[1,Q]-psi*omega[1,Q]), \n           2, 2, byrow=TRUE)\n\n# Obtain eigenvalues \nev=eigen(J)\n(evals = ev$values)\n\n[1] 1.0178571 0.6535714\n\nevecs = ev$vectors\n\n# Obtain determinant and trace\ndet=det(J)      # determinant\ntr=sum(diag(J)) # trace\n\n#Check stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] FALSE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n\nFinally, following the approach presented in Chapter 9, we can check whether the ratio of the two unstable state variables \\(w_t\\) and \\(p_t\\), which is the real wage \\(\\Omega\\), approaches a value that is given by the ratios of the elements in the dominant eigenvector. To do this, we first normalise the eigenvectors by dividing through by the second element (which corresponds to the second state variable in our system, \\(p_t\\)). The first element in the normalised eigenvector should then correspond to the equilibrium real wage. This is indeed the case.\n\n# Normalise eigenvectors by dividing through by the second element\nevecs_norm=evecs\nfor (i in 1:2){\n  evecs_norm[,i]=evecs[,i]/evecs[2,i]\n}\n\n# Compare first element of normalised eigenvector with real wage Omega=w/p\nevecs_norm[1,1]\n\n[1] 0.1821429\n\nomega[1,Q] \n\n[1] 0.1821429\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\n### Analytical solutions\n# Analytical solution for equilibrium real wage\nprint((phi * omega_w[0, 0] + psi * (1 / (1 + theta_T[0, 0]) - delta * epsilon[0, 0])) / (phi + psi))\n\n# Numerical solution for equilibrium real wage\nprint(omega[0, Q-1])\n\n# Analytical solution for equilibrium inflation rate\nprint(phi * psi * (omega_w[0, 0] - (1 / (1 + theta_T[0, 0]) - delta * epsilon[0, 0])) / (phi + psi))\n\n# Numerical solution for equilibrium inflation rate\nprint(p_hat[0, Q-1]) \n\n# Check condition for instability: Omega^W &gt; Omega*\nprint( omega_w[0, 0] &gt; (1 / (1 + theta_T[0, 0]) - delta * epsilon[0, 0]))\n\n# Define the Jacobian matrix J\nJ = np.array([\n    [1 + p_hat[0, Q-1] - phi * omega[0, Q-1], phi * omega[0, Q-1]**2],\n    [psi, 1 + p_hat[0, Q-1] - psi * omega[0, Q-1]]\n])\n\n# Obtain eigenvalues and eigenvectors\nev = np.linalg.eig(J)\nevals = ev[0]  # eigenvalues\nevecs = ev[1]  # eigenvectors\nprint(evals)\nprint(evecs)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\nprint(det)\nprint(tr)\n\n# Check stability conditions\nprint(1 + tr + det &gt; 0)\nprint(1 - tr + det &gt; 0)\nprint(1 - det &gt; 0)\n\n# Normalise eigenvectors by dividing through by the second element\nevecs_norm = evecs.copy()  # Make a copy to modify\nfor i in range(2):\n    evecs_norm[:, i] = evecs[:, i] / evecs[1, i]  # Normalize by the second element\n\n# Compare first element of normalized eigenvector with real wage Omega = w/p\nprint(evecs_norm[0, 0])\nprint(omega[0, Q-1])",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#references",
    "href": "a_conflict_inflation_model.html#references",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nBlecker, Robert A., and Mark Setterfield. 2019. Heterodox Macroeconomics. Models of Demand, Distribution and Growth. Edward Elgar.\n\n\nHein, Eckhard. 2023. Macroeconmics After Kalecki and Keynes. Post-Keynesian Foundations. Edward Elgar.\n\n\nLavoie, Marc. 2022. Post-Keynesian Economics. New Foundations. 2nd ed. Edward Elgar.\n\n\nRowthorn, R. E. 1977. “Conflict, inflation and money.” Cambridge Journal of Economics 1 (3). https://doi.org/10.1093/oxfordjournals.cje.a035360.\n\n\nWildauer, Rafael, Karsten Kohler, Adam Aboobaker, and Alexander Guschanski. 2023. “Energy price shocks, conflict inflation, and income distribution in a three-sector model.” Energy Economics 127B. https://doi.org/10.1016/j.eneco.2023.106982.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#footnotes",
    "href": "a_conflict_inflation_model.html#footnotes",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "",
    "text": "With textbook treatments in Blecker and Setterfield (2019), chap. 5, Hein (2023), chap. 5, and Lavoie (2022), chap. 8.↩︎\nWildauer et al. (2023) use this model to study the 2021-23 inflationary episode in the US. Besides an energy sector providing intermediate inputs, they consider a final goods and a final services sector. In addition to the energy price shock, there is a positive demand shift towards goods and a negative supply shock due to lockdowns, creating a rise in the rate of capacity utilisation of the final goods sector. These additional shocks allow the final goods sector to raise its markup. The present simplified version of the model only considers the energy sector and a final output sector, and treats the markup of the final output sector as constant.↩︎\nBlecker and Setterfield (2019), chap. 5 and Lavoie (2022), chap. 8 analyse extensions which endogenise the real wage target of workers.↩︎\nIn Wildauer et al. (2023), the target markup of the final goods sector is endogenous with respect to the rate of capacity utilisation.↩︎\nMore accurately this is an energy price ‘shift’.↩︎\nWe derive the exact effects in the analytical discussion below.↩︎\nSee analytical discussion below.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html",
    "href": "a_sraffian_supermultiplier_model.html",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "",
    "text": "Overview\nThe Sraffian supermultiplier model was proposed by Serrano (1995) to integrate a Sraffian long-run equilibrium into a post-Keynesian growth model.1 The model requires the long-run rate of capacity utilisation to settle on an exogenously given normal rate. This requires investment to fully adjust to any changes in economic activity so as to bring back actual utilisation to the desired normal rate. As a result, investment expenditures (in the long-run) are assumed to be free of any idiosyncratic components such as Keynesian ‘animal spirits’. Long-run growth is then driven by those components of autonomous demand that do not create productive capacity – autonomous consumption in the simplest version of the model. An increase in the growth rate of autonomous consumption will stimulate economic activity and induce firms to adjust their expectations about long-run growth towards the new rate given by autonomous demand growth.\nIncome distribution is exogenous in this model. An increase in the wage share has an expansionary effect on economic activity and growth in the short-run as it increases consumption (investment is assumed to be independent of income distribution). However, this expansionary effect is only temporary as economic activity will eventually settle back on the normal rate of capacity utilisation, and the growth rate towards the rate given by autonomous demand growth. The absence of long-run effects of income distribution on output and growth constitutes a key difference between the Sraffian supermultiplier model and the post-Kaleckian model, in which there is no normal rate of capacity utilisation and no autonomous (non-capacity creating) demand.\nThis is a model of long-run steady state growth. In the steady state, all endogenous variables grow at the same rate.2 The model contains two state variables that determine the model’s dynamics: the ratio of autonomous demand to the capital stock (which changes during adjustment periods where the growth rate has not yet settled on the rate given by autonomous demand growth) and the expected growth rate of the capital stock, which sluggishly adjusts to the rate given by autonomous demand growth. We consider a continuous-time version of the model presented in chapter 6.5.8 of Lavoie (2022) .3",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#the-model",
    "href": "a_sraffian_supermultiplier_model.html#the-model",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "The Model",
    "text": "The Model\nThe following equations describe the model: \\[\nr_t=\\pi u_t\n\\tag{12.1}\\] \\[\ns_t=-z_t + s_r r_t\n\\tag{12.2}\\] \\[\nc_t= u_t-s_t\n\\tag{12.3}\\] \\[\ng_t=g^0_t+g_1(u_t-u_n)\n\\tag{12.4}\\] \\[\nu_t=c_t+g_t\n\\tag{12.5}\\] \\[\n\\dot{g^0_t}=\\mu(g_t-g^0_t)\n\\tag{12.6}\\] \\[\n\\dot{z_t}=z_t(g_z-g_t),\n\\tag{12.7}\\]\nwhere \\(r\\), \\(s\\), \\(c\\), \\(g\\), \\(u\\), \\(g^0\\), and \\(z\\) are the profit rate, the saving rate, the consumption rate, the investment rate, the rate of capacity utilisation, the expected growth rate, and the rate of autonomous demand, respectively. A dot over a variable represents the derivative with respect to time (\\(\\dot{x}=\\frac{d x}{d t}\\)).\nEquation 12.1 decomposes the profit rate (total profits over capital stock) into the product of the profit share \\(\\pi\\) (total profits over total output) and the rate of capacity utilisation (actual output over capital stock).4 Note that the wage share is given by \\(1-\\pi\\). By Equation 12.2, the economy-wide saving rate is given by the negative of the rate of autonomous demand (\\(z\\)), which in this version of the model is autonomous consumption, i.e. dissaving, and saving out of profits (\\(s_r\\)). It is assumed that workers do not save. Equation 12.3 simply states that consumption is income not saved. According to Equation 12.4, investment is determined by an autonomous component \\(g_0\\) that will be specified below and by the deviation of capacity utilisation from its normal rate \\(u_n\\). In other words, firms expand capacity whenever the actual rate of utilisation exceeds the desired normal rate. Equation 12.5 is the goods market equilibrium condition assuming that the rate of capacity utilisation adjusts to clear the goods market in the short run. Equation 12.6 is a key equation in the Sraffian supermultiplier approach, which posits that firms (sluggishly) adjust the expected growth rate to the actual growth rate. Finally, Equation 12.7 is an identity that traces changes in the rate of autonomous demand that stem from (temporary) mismatches between the exogenously given growth rate of autonomous demand (\\(g_z\\)) and the actual growth rate.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#simulation",
    "href": "a_sraffian_supermultiplier_model.html#simulation",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. In scenario 2, the growth rate of autonomous demand \\(g_z\\) increases. In scenario 3, the profit share \\(\\pi\\) rises. In scenario 4, the normal rate of capacity utilisation \\(u_n\\) increases. The model is initialised at the equilibrium of the baseline parameterisation and the various shifts then occur in period 50.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(\\pi\\)\n\\(s_r\\)\n\\(g_1\\)\n\\(u_n\\)\n\\(\\mu\\)\n\\(g_z\\)\n\n\n\n1: baseline\n0.35\n0.8\n0.2\n0.75\n0.08\n0.02\n\n\n2: rise in autonomous demand growth (\\(g_z\\))\n0.35\n0.8\n0.2\n0.75\n0.08\n0.03\n\n\n3: rise in profit share (\\(\\pi\\))\n0.4\n0.8\n0.2\n0.75\n0.08\n0.02\n\n\n4: rise in normal rate of capacity utilisation (\\(u_n\\))\n0.35\n0.8\n0.2\n0.8\n0.08\n0.02\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n#Set number of periods\nQ = 1000\n\n# Set number of scenarios (including baselines)\nS=4\n\n# Set period in which exogenous shift will occur\nq=50\n\n#Create (S x Q) matrices in which equilibrium solutions from different parameterisations will be stored\nu=matrix(data=0,nrow=S,ncol=Q) # rate of capacity utilisation\ng=matrix(data=0,nrow=S,ncol=Q) # growth rate of capital stock\ns=matrix(data=0,nrow=S,ncol=Q) # saving rate\nc=matrix(data=0,nrow=S,ncol=Q) # consumption rate\nr=matrix(data=0,nrow=S,ncol=Q) # profit rate\ng0=matrix(data=0,nrow=S,ncol=Q)# expected growth rate of capital stock\nz=matrix(data=0,nrow=S,ncol=Q) # autonomous demand rate\n\n#Set constant parameter values\ng1=0.2  # Sensitivity of investment with respect to utilisation\nsr=0.8  # propensity to save out of profits\nmu=0.08 # adjustment speed of expected growth rate\nd=0.1   # time increment\n\n# Set and initialise exogenous variables/parameters that will be shifted\npi=matrix(data=0.35,nrow=S,ncol=Q) # profit share\ngz=matrix(data=0.02,nrow=S,ncol=Q) # growth rate of autonomous demand\nun=matrix(data=0.75,nrow=S,ncol=Q)  # normal rate of capacity utilisation\n\n# Set parameter values for different scenarios\ngz[2,q:Q]=0.03 # scenario 2: rise in autonomous demand growth\npi[3,q:Q]=0.4 # scenario 3: rise in profit share\nun[4,q:Q]=0.8 # scenario 4: rise in normal rate of utilisation\n\n# Initialise endogenous variables at equilibrium values\nu[,1]=un[,1]\ng[,1]=gz[,1]\ns[,1]=g[,1]\nc[,1]=un[,1]-s[,1]\ng0[,1]=gz[,1]\nz[,1]=sr*pi[,1]*un[,1]-gz[,1]\nr[,1]=pi[,1]*un[,1]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n    \n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # iterate the model 1000-times in each period\n    \n    #(1) Profit rate\n    r[i,t] =pi[i,t]*u[i,t]\n      \n    #(2) Saving\n    s[i,t] = -z[i,t] + sr*r[i,t]\n    \n    #(3) Consumption\n    c[i,t] = u[i,t] - s[i,t]\n    \n    #(4) Investment\n    g[i,t] = g0[i,t] +g1*(u[i,t] - un[i,t])\n    \n    #(5) Capacity utilisation\n    u[i,t] = c[i,t] + g[i,t]\n    \n    #(6) Dynamic adjustment of expected growth rate of capital stock\n    g0[i,t] = g0[i,t-1] + mu*(g[i,t-1]-g0[i,t-1])*d\n    \n    #(7) Dynamic adjustment of autonomous demand\n    z[i,t] = z[i,t-1] + z[i,t-1]*(gz[i,t-1] - g[i,t-1])*d\n\n  } # close iterations loop\n }  # close time loop\n}   # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 1000\n\n# Set number of scenarios (including baselines)\nS = 4\n\n# Set period in which exogenous shift will occur\nq = 50\n\n# Create (S x Q) matrices for equilibrium solutions\nu = np.zeros((S, Q))  # rate of capacity utilization\ng = np.zeros((S, Q))  # growth rate of capital stock\ns = np.zeros((S, Q))  # saving rate\nc = np.zeros((S, Q))  # consumption rate\nr = np.zeros((S, Q))  # profit rate\ng0 = np.zeros((S, Q))  # expected growth rate of capital stock\nz = np.zeros((S, Q))  # autonomous demand rate\n\n# Set constant parameter values\ng1 = 0.2  # Sensitivity of investment with respect to utilization\nsr = 0.8  # propensity to save out of profits\nmu = 0.08  # adjustment speed of expected growth rate\nd = 0.1   # time increment\n\n# Set and initialize exogenous variables/parameters that will be shifted\npi = np.full((S, Q), 0.35)  # profit share\ngz = np.full((S, Q), 0.02)  # growth rate of autonomous demand\nun = np.full((S, Q), 0.75)  # normal rate of capacity utilization\n\n# Set parameter values for different scenarios\ngz[1, q:] = 0.03  # scenario 2: rise in autonomous demand growth\npi[2, q:] = 0.4   # scenario 3: rise in profit share\nun[3, q:] = 0.8   # scenario 4: rise in normal rate of utilization\n\n# Initialize endogenous variables at equilibrium values\nu[:, 0] = un[:, 0]\ng[:, 0] = gz[:, 0]\ns[:, 0] = g[:, 0]\nc[:, 0] = un[:, 0] - s[:, 0]\ng0[:, 0] = gz[:, 0]\nz[:, 0] = sr * pi[:, 0] * un[:, 0] - gz[:, 0]\nr[:, 0] = pi[:, 0] * un[:, 0]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for iterations in range(1000):  # iterate the model 1000 times in each period\n\n            # (1) Profit rate\n            r[i, t] = pi[i, t] * u[i, t]\n\n            # (2) Saving\n            s[i, t] = -z[i, t] + sr * r[i, t]\n\n            # (3) Consumption\n            c[i, t] = u[i, t] - s[i, t]\n\n            # (4) Investment\n            g[i, t] = g0[i, t] + g1 * (u[i, t] - un[i, t])\n\n            # (5) Capacity utilization\n            u[i, t] = c[i, t] + g[i, t]\n\n            # (6) Dynamic adjustment of expected growth rate of capital stock\n            g0[i, t] = g0[i, t - 1] + mu * (g[i, t - 1] - g0[i, t - 1]) * d\n\n            # (7) Dynamic adjustment of autonomous demand\n            z[i, t] = z[i, t - 1] + z[i, t - 1] * (gz[i, t - 1] - g[i, t - 1]) * d\n\n\n\n\nPlots\nFigures 1-3 depict the response of the three main endogenous variables to changes in the exogenous variables. In the second scenario (solid line), the growth rate of autonomous demand increases from 2% to 3%. As a result, the rate of capacity temporarily increases but then returns to the level given by the normal rate, as the rate of autonomous demand falls due to the increase in the capital stock. By contrast, the growth rate permanently settles to the new rate given by the autonomous rate.\nIn the third scenario (dashed line), the profit share rises, which initially has a contractionary effect on the rate of utilisation and growth. Both variables then briefly overshoot due to the increase in the autonomous demand rate and then return to their previous values.\n\n# Set maximum period for plots\nTmax=700\n\n# Capacity utilisation\nplot(u[2, 2:(Tmax+1)], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'u',xlab = 'Time',ylim=range(max(u[, 2:Tmax]),min(u[, 2:Tmax])),cex.axis=1,cex.lab=0.75)\ntitle(main=\"Figure 1: Rate of capacity utilisation under different scenarios\",cex=0.8 ,line=2)\nlines(u[3, 2:(Tmax+1)],lty=2)\nlines(u[4, 2:(Tmax+1)],lty=3)\nlegend(\"bottomright\", legend=c(\"Rise autom demand\", \"Rise profit share\", \"Rise normal rate\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Growth\nplot(g[2, 2:(Tmax+1)], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'g',xlab = 'Time',ylim=range(max(g[, 2:Tmax]),min(g[, 2:Tmax])),cex.axis=1,cex.lab=0.75)\ntitle(main=\"Figure 2: Growth rate under different scenarios\",cex=0.8 ,line=2)\nlines(g[3, 2:(Tmax+1)],lty=2)\nlines(g[4, 2:(Tmax+1)],lty=3)\nlegend(\"bottomright\", legend=c(\"Rise autom demand\", \"Rise profit share\", \"Rise normal rate\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Autonomous demand rate\nplot(z[2, 2:(Tmax+1)], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'z',xlab = 'Time',ylim=range(max(z[, 2:Tmax]),min(z[, 2:Tmax])),cex.axis=1,cex.lab=0.75)\ntitle(main=\"Figure 3: Rate of autonomous demand under different scenarios\",cex=0.8 ,line=2)\nlines(z[3, 2:(Tmax+1)],lty=2)\nlines(z[4, 2:(Tmax+1)],lty=3)\nlegend(\"right\", legend=c(\"Rise autom demand\", \"Rise profit share\", \"Rise normal rate\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Plots (here for capacity utilisation only)\n\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmax = 700\n\n# Plot capacity utilization\nplt.plot(u[1, 1:Tmax], label='Rise autom demand', linestyle='-', linewidth=2, color='k')\nplt.plot(u[2, 1:Tmax], label='Rise profit share', linestyle='--', linewidth=2, color='k')\nplt.plot(u[3, 1:Tmax], label='Rise normal rate', linestyle='-.', linewidth=2, color='k')\nplt.title('Rate of Capacity Utilization under Different Scenarios')\nplt.xlabel('Time')\nplt.ylabel('u')\nplt.legend(loc='lower right')\nplt.show()\n\n\n\n\nFinally, a rise in the normal rate (dotted line) initially has contractionary effects on utilisation and growth but eventually raises utilisation to a permanently higher level. The growth rate returns to its previous value.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#directed-graph",
    "href": "a_sraffian_supermultiplier_model.html#directed-graph",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n# Construct auxiliary Jacobian matrix for 9 variables: \n# r, c, g, u, g0, z, pi, gz, un\n\nM_mat=matrix(c(0,0,0,1,0,0,1,0,0,\n               1,0,0,1,0,1,0,0,0,\n               0,0,0,1,1,0,0,0,1,\n               0,1,1,0,0,0,0,0,0,\n               0,0,1,0,0,0,0,0,0,\n               0,0,1,0,0,0,0,1,0,\n               0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0), 9, 9, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted=NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"c\", \"g\", \"u\", expression(g^0), \"z\", expression(pi), expression(g[z]), expression(u[n]))\n\n# Plot directed graph\nplot(dg, main=\"Figure 4: Directed graph of Sraffian Supermultiplier Model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Directed graph\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the Jacobian matrix\nM_mat = np.array([[0, 0, 0, 1, 0, 0, 1, 0, 0],\n                  [1, 0, 0, 1, 0, 1, 0, 0, 0],\n                  [0, 0, 0, 1, 1, 0, 0, 0, 1],\n                  [0, 1, 1, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0, 0, 1, 0],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", \n            1: \"c\",\n            2: \"g\",\n            3: \"u\",\n            4: r\"$g^0$\",\n            5: \"z\",\n            6: r\"$\\pi$\",\n            7: r\"$g_z$\",\n            8: r\"$u_n$\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 4, it can be seen that the growth rate of autonomous demand (\\(g_z\\)), the profit share (\\(\\pi\\)), and the normal rate of capacity utilisation (\\(u_n\\)) are the key exogenous variable of the model. The profit rate (\\(r\\)), consumption (\\(c\\)), the autonomous demand rate (\\(z\\)), investment (\\(g\\)), the rate of utilisation (\\(u\\)), an the expected growth rate (\\(g_0\\)) form a closed loop (or cycle) within the system. For example, an increase in the growth rate of autonomous demand increases consumption, which raises the rate of capacity utilisation, growth, and the expected growth rate. In a second-round effect, the increase in the growth rate then feeds back negatively into the autonomous demand rate, which leads to a return of the rate of capacity utilisation to its previous value.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#analytical-discussion",
    "href": "a_sraffian_supermultiplier_model.html#analytical-discussion",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the short-run equilibrium solutions for \\(u\\) and \\(g\\), first substitute Equation 12.1-Equation 12.4 into Equation 12.5 and solve for \\(u\\): \\[\nu^* = \\frac{g_0+z-g_1u_n}{s_r \\pi-g_1}.\n\\] From this, we get: \\[\ng^* = g_0 + g_1(u^* - u_n).\n\\] The long-run equilibrium is given by \\(u^{**}=u_n\\), \\(g^{**}=g_z\\), and (from Equation 12.7) \\(z^{**}=u_n s_r \\pi - g_z\\).\nThe dynamics are governed by Equation 12.6-Equation 12.7. The Jacobian matrix is: \\[\nJ(g^0, z)=\\begin{bmatrix} \\frac{\\mu g_1}{s_r\\pi-g_1}& \\frac{\\mu g_1}{s_r\\pi-g_1} \\\\ -z(\\frac{g_1}{s_r\\pi-g_1} +1)& \\frac{-zg_1}{s_r\\pi-g_1} \\end{bmatrix}.\n\\]\nThe determinant of the Jacobian matrix evaluated at the long-run equilibrium is: \\[\ndet(J^*) = \\frac{(u_n s_r \\pi - g_z)\\mu g_1}{s_r\\pi-g_1} &gt; 0,\n\\]\nwhich is positive provided \\(s_r\\pi-g_1\\), i.e. if the Keynesian stability condition holds.\nThe trace is:\n\\[\ntr(J^*) = \\frac{g_1(\\mu-u_n s_r \\pi + g_z)}{s_r\\pi-g_1}.\n\\]\nStability requires a negative trace, yielding a second stability condition: \\(\\mu&lt;u_n s_r \\pi - g_z\\).\nWe can verify these analytical solutions by comparing them with the results from the numerical solution:\n\n# Construct Jacobian matrix at the equilibrium \n\nJ=matrix(c((mu*g1)/(sr*pi[1,Q]-g1), (mu*g1)/(sr*pi[1,Q]-g1),\n           -z[1,Q]*(sr*pi[1,Q]/(sr*pi[1,Q]-g1)), -z[1,Q]*(g1/(sr*pi[1,Q]-g1))), 2, 2, byrow=TRUE)\nJ\n\n       [,1]   [,2]\n[1,]  0.200  0.200\n[2,] -0.665 -0.475\n\n# Obtain eigenvalues\nev=eigen(J)\n(values &lt;- ev$values)\n\n[1] -0.1375+0.1381801i -0.1375-0.1381801i\n\n# Obtain determinant and trace\ndet(J) # determinant\n\n[1] 0.038\n\nsum(diag(J)) # trace\n\n[1] -0.275\n\n# Check stability conditions for all scenarios\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(sr*pi[i,1]&gt;g1) # Keynesian stability condition\nprint(mu&lt;sr*un[i,1]*pi[i,1]-gz[i,1])\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Construct Jacobian matrix\nJ = np.array([\n    [(mu * g1) / (sr * pi[0, Q-1] - g1), (mu * g1) / (sr * pi[0, Q-1] - g1)],\n    [-z[0, Q-1] * (sr * pi[0, Q-1] / (sr * pi[0, Q-1] - g1)), -z[0, Q-1] * (g1 / (sr * pi[0, Q-1] - g1))]\n])\nprint(J)\n\n# Obtain eigenvalues, determinant, and trace\n\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\ndeterminant_J = np.linalg.det(J)\nprint(determinant_J)\n\ntrace_J = np.trace(J)\nprint(trace_J)\n\n# Check stability conditions for all scenarios\nfor i in range(1, S + 1):\n    print(f\"Scenario {i}:\")\n    print(sr * pi[i - 1, 0] &gt; g1)  # Keynesian stability condition\n    print(mu &lt; sr * un[i - 1, 0] * pi[i - 1, 0] - gz[i - 1, 0])",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#references",
    "href": "a_sraffian_supermultiplier_model.html#references",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nBlecker, Robert A., and Mark Setterfield. 2019. Heterodox Macroeconomics. Models of Demand, Distribution and Growth. Edward Elgar.\n\n\nDutt, Amitava Krishna. 2018. “Some Observations on Models of Growth and Distribution with Autonomous Demand Growth.” Metroeconomica 70 (2): 288–301. https://doi.org/10.1111/meca.12234.\n\n\nLavoie, Marc. 2022. Post-Keynesian Economics. New Foundations. 2nd ed. Edward Elgar.\n\n\nSerrano, Franklin. 1995. “Long Period Effective Demand and the Sraffian Supermultiplier.” Contributions to Political Economy 14 (1): 67–90. https://doi.org/10.1093/oxfordjournals.cpe.a035642.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#footnotes",
    "href": "a_sraffian_supermultiplier_model.html#footnotes",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "",
    "text": "See chapter 7 in Blecker and Setterfield (2019), Dutt (2018), and chapter 6 in Lavoie (2022) for useful introductions. Note that contrary to what the name may suggest, this is a one-sector model.↩︎\nAll variables are normalised by the capital stock and thus rendered stationary.↩︎\nSection 2.5 explains how continuous time models can be solved numerically.↩︎\nFor simplicity, it is assumed that the capital-potential output ratio is equal to unity. This implies that the ratio of actual output to potential output is equal to the ratio of actual output to the capital stock, so that the latter can be taken as a measure of the rate of capacity utilisation.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html",
    "href": "a_malthusian_model.html",
    "title": "13  A Malthusian Model",
    "section": "",
    "text": "Overview\nThis model captures some key feature of Thomas Malthus’ theory of population dynamics as developed in his 1798 book An Essay on the Principle of Population. The theory revolves around the interaction between living standards and population growth.1 It assumes that birth rates increase with rising living standards, while death rates decline. Economic growth thus spurs population growth. However, due to supply constraints in agricultural production, population growth drives up food prices and thereby undermines real income, bringing population growth to a halt. The model is adapted from Karl Whelan’s lecture notes.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#the-model",
    "href": "a_malthusian_model.html#the-model",
    "title": "13  A Malthusian Model",
    "section": "The Model",
    "text": "The Model\nThe following equations describe the model:\n\\[\nN_t = N_{t-1} + B_{t-1} - D_{t-1}\n\\tag{13.1}\\]\n\\[\n\\frac{B_{t}}{N_t} = b_0 + b_1Y_t\n\\tag{13.2}\\]\n\\[\n\\frac{D_{t}}{N_t} = d_0 - d_1Y_t\n\\tag{13.3}\\]\n\\[\nY_t = a_0-a_1N_t\n\\tag{13.4}\\]\nwhere \\(N_t\\), \\(B_t\\), \\(D_t\\), and \\(Y_t\\) represent population, number of births, number of deaths, and real income, respectively.\nEquation 13.1 describes population dynamics as driven by births and deaths. Equation 13.2 and Equation 13.3 the Malthusian hypothesis that birth rates are positively and death rates negatively related to income. Equation 13.4 makes real income a negative function of the population, which captures the idea of supply constraints in agriculture.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#simulation",
    "href": "a_malthusian_model.html#simulation",
    "title": "13  A Malthusian Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable reports the parameterisation and initial values used in the simulation. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenario 2 models what Malthus called preventative checks: a fall in the exogenous component of the birth rate (\\(b_0\\)) due to an increased use of contraception, changes in marriage norms etc. Scenario 3 models`positive checks’: a rise in the sensitivity of real income with respect to the population (\\(a_1\\)), capturing factors such as increased food scarcity. Scenario 4 considers a rise in the exogenous component of real income (\\(a_0\\)), which could be interpreted as a productivity boost due to the invention of better fertilisers. All scenarios initialise the population below its steady state value at \\(N_0=1\\) and the other variables at their steady state values.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(b_0\\)\n\\(b_1\\)\n\\(d_0\\)\n\\(d_1\\)\n\\(a_0\\)\n\\(a_1\\)\n\n\n\n1: baseline\n0.5\n0.5\n2.5\n0.5\n2.5\n0.05\n\n\n2: fall in exog birth rate (\\(b_0\\))\n0.4\n0.5\n2.5\n0.5\n2.5\n0.05\n\n\n3: rise in sensitivity of income (\\(a_1\\))\n0.5\n0.5\n2.5\n0.5\n2.5\n0.07\n\n\n4: productivity boost (\\(a_0\\))\n0.5\n0.5\n2.5\n0.5\n2.6\n0.05\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nT=100\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=5\n\n# Create (S x T)-matrices that will contain the simulated data\nN=matrix(data=0,nrow=S,ncol=T) # population\nY=matrix(data=0,nrow=S,ncol=T) # real income\nB=matrix(data=0,nrow=S,ncol=T) # births\nD=matrix(data=0,nrow=S,ncol=T) # deaths\nN_eq=vector(length=S)          # equilibrium population\nY_eq=vector(length=S)          # equilibrium real income\nB_eq=vector(length=S)          # equilibrium births\nD_eq=vector(length=S)          # equilibrium deaths\n\n# Set baseline parameter values\nb0=matrix(data=0.5,nrow=S,ncol=T) # Exogenous birth rate\nb1=0.5 # Sensitivity of births with respect to real income\nd0=2.5 # Exogenous death rate\nd1=0.5 # Sensitivity of deaths with respect to real income\na0=matrix(data=2.5,nrow=S,ncol=T) # Exogenous component of real income \na1=matrix(data=0.05,nrow=S,ncol=T) #Sensitivity of the real income with respect to population\n\n# Set parameter values for different scenarios\nb0[2,s:T]=0.4  # scenario 2: reduction in birth rate\na1[3,s:T]=0.07 # scenario 3: increase in sensitivity of real income with respect to population\na0[4,s:T]=2.6  # scenario 4: improvement in productivity\n\n# Initialise \nN[,1]=1\nY[,1]=1\nB[,1]=1\nD[,1]=1\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor (i in 1:S){  \n\n  for (t in 2:T){\n \n    for (iterations in 1:1000){ # run the model 1000-times in each period \n       \n      # (1) Population dynamics    \n      N[i,t] = N[i,t-1] + B[i,t-1] - D[i,t-1]\n      \n      # (2) Births\n      B[i,t] = (b0[i,t] + b1*Y[i,t])*N[i,t]\n      \n      # (3) Deaths\n      D[i,t] = (d0 - d1*Y[i,t])*N[i,t]  \n      \n      # (4) Real income\n      Y[i,t] = a0[i,t] - a1[i,t]*N[i,t]   \n      \n    }  # close iterations loop \n  }    # close time loop\n}      # close scenario loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport numpy as np\n\n# Set number of periods\nT = 100\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 5\n\n# Create (S x T)-matrices that will contain the simulated data\nN = np.zeros((S, T))  # population\nY = np.zeros((S, T))  # real income\nB = np.zeros((S, T))  # births\nD = np.zeros((S, T))  # deaths\nN_eq = np.zeros((S))  # equilibrium population\nY_eq = np.zeros((S))  # equilibrium real income\nB_eq = np.zeros((S))  # equilibrium births\nD_eq = np.zeros((S))  # equilibrium deaths\n\n# Set baseline parameter values\nb0 = np.zeros((S, T)) + 0.5  # Exogenous birth rate\nb1 = 0.5  # Sensitivity of births with respect to real income\nd0 = 2.5  # Exogenous death rate\nd1 = 0.5  # Sensitivity of deaths with respect to real income\na0 = np.zeros((S, T)) + 2.5  # Exogenous component of real income\na1 = np.zeros((S, T)) + 0.05  # Sensitivity of the real income with respect to population\n\n# Set parameter values for different scenarios\nb0[1, s:T] = 0.4  # scenario 2: reduction in birth rate\na1[2, s:T] = 0.07  # scenario 3: increase in sensitivity of real income with respect to population\na0[3, s:T] = 2.6  # scenario 4: improvement in productivity\n\n# Initialise \nN[:,0] = 1\nY[:,0] = Y_eq[0]\nB[:,0] = B_eq[0]\nD[:,0] = D_eq[0]\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor i in range(S):  \n  for t in range(1, T):\n    for iterations in range(1000): # run the model 1000-times in each period (to make sure the order of equations doesn't matter)\n      # (1) Population dynamics    \n      N[i,t] = N[i,t-1] + B[i,t-1] - D[i,t-1]\n      # (2) Births\n      B[i,t] = (b0[i,t] + b1*Y[i,t])*N[i,t]\n      # (3) Deaths\n      D[i,t] = (d0 - d1*Y[i,t])*N[i,t]  \n      # (4) Real income\n      Y[i,t] = a0[i,t] - a1[i,t]*N[i,t]   \n\n\n\n\nPlots\nFigure 1 displays population and real income dynamics for the baseline scenario. Starting from a below-equilibrium level of population, the population initially grows rapidly (seemingly exponentially) but then approaches a steady state. During the adjustment phase, real income is driven down to its steady state level (which can be interpreted as the subsistence level). Figure 2 displays the corresponding dynamics of births and deaths.\n\n# Set maximum period for plots\nTmax=20\n\n## Baseline\n#Population and real income\nplot(N[1, 2:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Population and real income, baseline\",ylab = 'N', xlab = 'Time',cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(Y[1, 2:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(Y[1, 2:20]),cex=0.8)\naxis(side = 4, at = pretty(range(Y[1, 2:Tmax])))  \nmtext(\"Y\", side = 4, line = 2)\nlegend(15, 2.3, legend=c(\"N\", \"Y\"),\n        lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.5)\n\n\n\n\n\n\n\n# Births and deaths\nplot(B[1, 2:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\") \ntitle(main=\"Figure 2: Births and deaths, baseline\", xlab = 'Time',cex=0.8,line=2)\nlines(D[1, 2:Tmax],lty=2)\nlegend(\"bottomright\", legend=c(\"B\", \"D\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.5)\n\n\n\n\n\n\n\nFigure 3 displays population dynamics under the different scenarios described in Table 1. As expected, both preventative and positive checks are effective: a fall in the exogenous component of the birth rate and an increase in the sensitivity of real income slow down population dynamics and lower its steady state value. By contrast, a productivity boost allows for a higher equilibrium level of population.\n\n## Population dynamics under different scenarios\nplot(N[1, 2:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(N[4, 2:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 3: Population dynamics under different scenarios\",ylab = 'N', xlab = 'Time',cex=0.8, line=2)\nlines(N[2, 2:(Tmax+1)],lty=2, lwd=2)\nlines(N[3, 2:(Tmax+1)],lty=3, lwd=2)\nlines(N[4, 2:(Tmax+1)],lty=4, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: baseline\",\"2: fall in exog birth rate\", \"3: rise in sensitivity of income\",\n      \"4: productivity boost\"), lty=1:4, cex=0.8, bty = \"n\", y.intersp=0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Plots (here for population and real income only)\n\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmax = 20\n\n## Baseline\n# Population and real income\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(Y[0, 2:Tmax], linestyle='dashed', label='Y', linewidth=0.8, color=\"black\")\nax2.set_ylabel('Y', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#directed-graph",
    "href": "a_malthusian_model.html#directed-graph",
    "title": "13  A Malthusian Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 6 variables: N, B, D, Y, b0, a0,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,1,1,0,0,0,\n              1,0,0,1,1,0,\n              1,0,0,1,0,0,\n              1,0,0,0,0,1,\n              0,0,0,0,0,0,\n              0,0,0,0,0,0), 6, 6, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"N\", \"B\", \"D\", \"Y\", expression(b[0]), expression(a[0]))\n\n# Plot directed graph matrix\nplot(dg, main=\"Figure 4: Directed graph of Malthusian model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\nimport networkx as nx\n\n#Construct auxiliary Jacobian matrix for 6 variables: N, B, D, Y, b0, a0\nM_mat = np.array([[0,1,1,0,0,0],\n                  [1,0,0,1,1,0],\n                  [1,0,0,1,0,0],\n                  [1,0,0,0,0,1],\n                  [0,0,0,0,0,0],\n                  [0,0,0,0,0,0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"N\", 1: \"B\", 2: \"D\", 3: \"Y\", 4: \"$b_0$\", 5: \"$a_0$\"}\n\n# Plot the graph\npos = nx.spring_layout(G)\nnx.draw_networkx(G, pos, node_size=500, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=12, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure 4: Directed graph of Malthusian model\")\nplt.show()\n\n\n\n\nIn Figure 4, it can be seen that the exogenous birth rate (\\(b0\\)) and productivity (\\(a0\\)) are exogenous variables that impact births and income, respectively. Births, deaths, employment and income are endogenous and form a closed loop (or cycle) within the system. Births and deaths affect the population size (with simultaneous feedback from population to births and deaths), and the population affects income. Income, in turn, feeds back into population size.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#analytical-discussion",
    "href": "a_malthusian_model.html#analytical-discussion",
    "title": "13  A Malthusian Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the steady state solution for \\(N\\), substitute Equation 13.2 - Equation 13.4 into Equation 13.1 and collect terms::\n\\[\nN_t = N_{t-1}[1+b_0-d_0+a_0(b_1+d_1)] - N_{t-1}^2 [a_1(b_1+d_1)].\n\\tag{13.5}\\]\nSubtract \\(N_{t-1}\\) and divide through by \\(N_{t-1}\\): \\[\n\\frac{N_t - N_{t-1}}{N_{t-1}} = [b_0-d_0+a_0(b_1+d_1)] - N_{t-1} [a_1(b_1+d_1)].\n\\]\nSet \\(\\frac{N_t - N_{t-1}}{N_t{t-1}}=0\\) and solve for \\(N_{t}\\) to find the non-trivial steady state:2 \\[\nN^* = \\frac{b_0-d_0+a_0(b_1+d_1)}{a_1(b_1+d_1)}.\n\\]\nSubstitution of \\(N^*\\) into Equation 13.4 and simplifying yields: \\[\nY^* = \\frac{d_0-b_0}{b_1+d_1}.\n\\]\nFinally, to assess the dynamic stability of the model, differentiate Equation 13.5 with respect to \\(N_{t-1}\\): \\[\n\\frac{\\partial N_t}{\\partial N_{t-1}} = 1+b_0-d_0+a_0(b_1+d_1)-2N_{t-1}[a_1(b_1+d_1)].\n\\]\nDue to then non-linearity of the model, stability can only be assessed locally around the steady state. To do this, substitute the steady state solution and simplify: \\[\n\\frac{\\partial N_t}{\\partial N_{t-1}} = 1-b_0+d_0-a_0(b_1+d_1).\n\\] From this, we can conclude that the steady state is stable iff: \\[\n|1-b_0+d_0-a_0(b_1+d_1)| &lt; 1.\n\\]\nWe can verify these analytical solutions by comparing them with the results from the numerical solution:\n\n# Calculate analytical equilibrium solutions \nfor (i in 1:S){\nN_eq[i]=(b0[i,T]-d0+a0[i,T]*(b1+d1))/(a1[i,T]*(b1+d1))\nY_eq[i]=(d0-b0[i,T])/(b1+d1)\nB_eq[i]=(b0[i,T] + b1*Y_eq[i])*N_eq[i]\nD_eq[i]=(d0 - d1*Y_eq[i])*N_eq[i]\n}\n\n# Compare with numerical solutions (here for the example of Y, scenario1)\nY_eq[1]\n\n[1] 2\n\nY[1,T]\n\n[1] 2\n\n# Check stability condition for all scenarios\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(abs(1-b0[i,T]+d0-a0[i,T]*(b1+d1)) &lt; 1)\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\n# Calculate analytical equilibrium solutions \nfor i in range(S):\n  N_eq[i] = (b0[i, T-1] - d0 + a0[i, T-1] * (b1 + d1)) / (a1[i, T-1] * (b1 + d1))\n  Y_eq[i] = (d0 - b0[i, T-1]) / (b1 + d1)\n  B_eq[i] = (b0[i, T-1] + b1 * Y_eq[i]) * N_eq[i]\n  D_eq[i] = (d0 - d1 * Y_eq[i]) * N_eq[i]\n  \n# Compare with numerical solutions (here for the example of Y, scenario1)\nprint(Y_eq[0])\nprint(Y[0,T-1])\n\n# Check stability condition for all scenarios\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(abs(1 - b0[i, T-1] + d0 - a0[i, T-1] * (b1 + d1)) &lt; 1)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#references",
    "href": "a_malthusian_model.html#references",
    "title": "13  A Malthusian Model",
    "section": "References",
    "text": "References\n\n\n\n\nFoley, Duncan K. 2006. Adam’s Fallacy. A Guide to Economic Theology. Cambridge, MA / London: Harvard University Press.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#footnotes",
    "href": "a_malthusian_model.html#footnotes",
    "title": "13  A Malthusian Model",
    "section": "",
    "text": "See chapter 2 of Foley (2006) for an excellent introduction.↩︎\nA trivial steady state is at \\(N^*=0\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html",
    "href": "a_ricardian_one_sector_model.html",
    "title": "14  A Ricardian One-Sector Model",
    "section": "",
    "text": "Overview\nThis model captures some key feature of David Ricardo’s theory of growth and distribution as developed in his 1817 book On the Principles of Political Economy and Taxation. The model revolves around the determination of real wages, rents, and profits, and how profitability in turn drives capital accumulation.1 It assumes a corn economy with a single good (corn) that serves both as an investment and consumption good.2 Corn production is subject to diminishing marginal returns. Real wages are driven down to a subsistence level and rent is a differential surplus landowners gain based on the fertility of their land relative to the marginal plot of land (the plot of land where fertility is lowest and no rent is earned). Profits are a residual. As employment increases and more land is utilised, marginal productivity falls and differential rents increase. As a result, profits are driven down and capital accumulation comes to a halt. A stationary state is reached. Landowners are the main beneficiaries of this process. The model is adapted from Pasinetti (1960).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#the-model",
    "href": "a_ricardian_one_sector_model.html#the-model",
    "title": "14  A Ricardian One-Sector Model",
    "section": "The Model",
    "text": "The Model\nThe following equations describe the model:\n\\[\nY_t=AN_t^a\n\\tag{14.1}\\]\n\\[\nW_t=K_t\n\\tag{14.2}\\]\n\\[\nw_t =W_t/N_t\n\\tag{14.3}\\]\n\\[\nMPL_t =\\frac{\\partial Y_t}{\\partial N_t} =aAN_t^{a-1}\n\\tag{14.4}\\]\n\\[\nR_t = Y_t - N_tMPL_t\n\\tag{14.5}\\]\n\\[\nP_t = Y_t - R_t - N_tw_t\n\\tag{14.6}\\]\n\\[\nK_t = K_{t-1} + \\beta P_{t-1}\n\\tag{14.7}\\]\n\\[\nN_t = N_{t-1} + \\gamma (w_{t-1} - w^S)\n\\tag{14.8}\\]\nwhere \\(Y_t\\), \\(A\\), \\(N_t\\), \\(W_t\\), \\(K_t\\),\\(w_t\\), \\(Y_t\\), \\(MPL_t\\), \\(R_t\\), \\(P_t\\), and \\(w^S\\) are real output (measured in units of corn), productivity, employment, the real wage bill (or wage fund), the capital stock, the real wage rate, the marginal product of labour, rents, profits, and the subsistence wage, respectively.\nEquation 14.1 is the production function with \\(\\alpha \\in (0,1)\\), i.e. exhibiting diminishing marginal returns to labour.3 By Equation 14.2, the wage fund is defined as the capital stock of this model (reflecting the fact that the production of corn only involves labour). Equation 14.3 defines the real wage rate. Equation 14.3 specifies the marginal product of labour. Equation 14.5 captures the determination of (differential) rents as a negative function of the marginal product of labour.4 Thus, the lower the productivity on the marginal land, the higher the rents. In Equation 14.6, profits are determined residually. Capital accumulation in Equation 14.7 is driven by the reinvestment of profits (with \\(\\beta\\) determining the proportion of profits that are reinvested). Finally, Equation 14.8 specifies population dynamics, whereby the population increases whenever the actual real wage is above the subsistence wage, echoing the Malthusian population mechanism.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#simulation",
    "href": "a_ricardian_one_sector_model.html#simulation",
    "title": "14  A Ricardian One-Sector Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation and initial values used in the simulation. In line with the Classical tradition, it will be assumed that all profits are reinvested, i.e. \\(\\beta=1\\). Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenarios 2 and 3 model two different forms of technological change: an increase in the productivity parameter \\(A\\) and an increase in the elasticity of output with respect to labour (\\(a\\)). Scenario 4 considers a higher subsistence wage (\\(w^S\\)). In all scenarios the population/employment is initialised below its equilibrium value.\nTable 1: Parameterisation\n\n\nScenario\n\\(A\\)\n\\(a\\)\n\\(w^S\\)\n\n\n\n1: baseline\n2\n0.7\n0.5\n\n\n2: productivity boost I (\\(A\\))\n3\n0.7\n0.5\n\n\n3: productivity boost II (\\(a\\))\n2\n0.75\n0.5\n\n\n4: higher subsistence wage (\\(w^S\\))\n2\n0.7\n0.7\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=500\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=20\n\n# Create (S x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=S,ncol=Q) # Income/output\nR=matrix(data=1,nrow=S,ncol=Q) # Rent\nP=matrix(data=1,nrow=S,ncol=Q) # Profits\nN=matrix(data=1,nrow=S,ncol=Q) # employment\nw=matrix(data=1,nrow=S,ncol=Q) # real wage\nK=matrix(data=1,nrow=S,ncol=Q) # capital stock\nMPL=matrix(data=1,nrow=S,ncol=Q) # marginal product of labour\nW=matrix(data=1,nrow=S,ncol=Q) # wage bill\nN_eq=vector(length=S)          # equilibrium population\nK_eq=vector(length=S)          # equilibrium capital\n\n# Set baseline parameter values\nA=matrix(data=2,nrow=S,ncol=Q) # productivity\na=matrix(data=0.7,nrow=S,ncol=Q) # labour elasticity of output\nbeta=1 # Sensitivity of investment with respect to profits\ngamma=5 # adjustment speed of population\nwS=matrix(data=0.5,nrow=S,ncol=Q) # subsistence wage rate\n\n# Set parameter values for different scenarios\nA[2,s:Q]=3 # scenario 2: productivity boost I\na[3,s:Q]=0.75 # scenario 3: productivity boost II\nwS[4,s:Q]=0.6 # scenario 4: increase in subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN[,1]=1\nK[,1]=1   \nY[,1]=A[,1]*N[,1]^(a[,1])\nMPL[,1]=a[,1]*A[,1]*(N[,1]^(a[,1]-1))\nw[,1]=wS[,1]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # run the model 1000-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = A[i,t]*N[i,t]^(a[i,t])\n    \n    #(2) Wage bill\n    W[i,t] = K[i,t] \n    \n    #(3) Real wage rate\n    w[i,t] = W[i,t]/N[i,t] \n     \n    #(4) Marginal product of labour\n    MPL[i,t] = a[i,t]*A[i,t]*(N[i,t]^(a[i,t]-1))\n\n    #(5) Rents\n    R[i,t] = Y[i,t] - N[i,t]*MPL[i,t]\n    \n    #(6) Profits\n    P[i,t] = Y[i,t]- R[i,t] - N[i,t]*w[i,t]\n    \n    # (7) Capital accumulation\n    K[i,t] = K[i,t-1] + beta*P[i,t-1]\n    \n    #(8) Employment/population dynamics  \n    N[i,t] = N[i,t-1] + gamma*(w[i,t-1] - wS[i,t-1])\n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 500\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 20\n\n# Create (S x Q)-matrices that will contain the simulated data\nY = np.ones((S, Q))  # Income/output\nR = np.ones((S, Q))  # Rent\nP = np.ones((S, Q))  # Profits\nN = np.ones((S, Q))  # employment\nw = np.ones((S, Q))  # real wage\nK = np.ones((S, Q))  # capital stock\nMPL = np.ones((S, Q))  # marginal product of labour\nW = np.ones((S, Q))  # wage bill\n\n# Set baseline parameter values\nA = np.ones((S, Q)) * 2  # productivity\na = np.ones((S, Q)) * 0.7  # labour elasticity of output\nbeta = 1  # Sensitivity of investment with respect to profits\ngamma = 5  # adjustment speed of population\nwS = np.ones((S, Q)) * 0.5  # subsistence wage rate\n\n# Set parameter values for different scenarios\nA[1, s:Q] = 3  # scenario 2: productivity boost I\na[2, s:Q] = 0.75  # scenario 3: productivity boost II\nwS[3, s:Q] = 0.6  # scenario 4: increase in subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN[:, 0] = 1\nK[:, 0] = 1\nY[:, 0] = A[:, 0] * N[:, 0]**(a[:, 0])\nMPL[:, 0] = a[:, 0] * A[:, 0] * (N[:, 0]**(a[:, 0] - 1))\nw[:, 0] = wS[:, 0]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for iterations in range(1000):  # run the model 1000 times in each period\n            # Model equations\n            # (1) Output\n            Y[i, t] = A[i, t] * N[i, t]**(a[i, t])\n            # (2) Wage bill\n            W[i, t] = K[i, t]\n            # (3) Real wage rate\n            w[i, t] = W[i, t] / N[i, t]\n            # (4) Marginal product of labour\n            MPL[i, t] = a[i, t] * A[i, t] * (N[i, t]**(a[i, t] - 1))\n            # (5) Rents\n            R[i, t] = Y[i, t] - N[i, t] * MPL[i, t]\n            # (6) Profits\n            P[i, t] = Y[i, t] - R[i, t] - N[i, t] * w[i, t]\n            # (7) Capital accumulation\n            K[i, t] = K[i, t - 1] + beta * P[i, t - 1]\n            # (8) Employment/population dynamics\n            N[i, t] = N[i, t - 1] + gamma * (w[i, t - 1] - wS[i, t - 1])\n\n\n\n\nPlots\nFigure 1 displays employment, capital accumulation, and income for the baseline scenario. Starting from a below-equilibrium level of population, the economy grows in terms of output, capital, and employment but then approaches what Ricardo famously called a ‘stationary state’. Figure 2 shows that during the adjustment phase, the MPL declines reflecting diminishing marginal returns in the production of corn. This captures the idea that a growing economy will have to utilise less fertile lands. The real wage is initially below the MPL, allowing for profits. Over time, the MPL and actual real wage converge to the exogenously given subsistence wage. Figure 3 shows that profits initially increase but are then squeezed to zero as differential rents increase.\n\n# Set start and end periods for plots\nTmax=280\nTmin =10\n\n## Baseline\n#Employment, capital accumulation, and income\nplot(N[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Employment, capital accumulation, and income\",ylab = 'N', xlab = 'Time', cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(Y[1, 2:(Tmax+1)]),cex.axis=1,cex.lab=0.75)\nlines(Y[1, Tmin:(Tmax+1)],lty=3, lwd=2)\naxis(side = 4, at = pretty(range(Y[1, 2:(Tmax+1)])))  \nmtext(\"K, Y\", side = 4, line = 2)\nlegend(\"bottomright\", legend=c(\"N\", \"K\", \"Y\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Real wage, subsistence wage, and MPL\nplot(w[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(wS[1, Tmin:Tmax],w[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 2: Real wage, marginal product of labour, and subsistence wage\", xlab = 'Time',cex=0.8,line=2)\nlines(MPL[1, Tmin:Tmax],lty=2)\nlines(wS[1, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"w\", \"MPL\", \"wS\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Profits and Rents\nplot(P[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(P[1, Tmin:Tmax])) \ntitle(main=\"Figure 3: Profits and rents\", xlab = 'Time',cex=0.8,line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(R[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=2, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"P\", \n     ylim=range(R[1, 3:Tmax]), axes=FALSE) \naxis(side = 4, at = pretty(range(R[1, Tmin:(Tmax+1)])))  \nmtext(\"R\", side = 4, line = 2)\nlegend(\"right\", legend=c(\"P\", \"R\"), lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nFigure 4 displays capital accumulation under the different scenarios described in Table 1. As expected, both forms of technical change boost both the speed of capital accumulation and the equilibrium level of capital. An increase in the subsistence wage reduces the pace of capital accumulation and leads to a lower equilibrium level of capital.\n\n## Different scenarios\n# Capital accumulation\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(K[1, 2:Tmax], K[2, Tmin:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 4: Capital accumulation under different scenarios\",ylab = 'K', xlab = 'Time',cex=0.8, line=2)\nlines(K[2, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(K[3, Tmin:(Tmax+1)],lty=3, lwd=2)\nlines(K[4, Tmin:(Tmax+1)],lty=4, lwd=2)\nlegend(\"topleft\", legend=c(\"1: baseline\",\"2: product. boost I\", \"3: product. boost II\", \"4: higher subs. wage\"), lty=1:4, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Plots (here for employment, capital accumulation, and income only)\n\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 280\nTmin = 10\n\n# Baseline\n# Employment, capital accumulation, and income\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\n\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(K[0, 2:Tmax], linestyle='dashed', label='K', linewidth=0.8, color=\"black\")\nax2.plot(Y[0, 2:Tmax], linestyle='dotted', label='Y', linewidth=0.8, color=\"black\")\nax2.set_ylabel('Y, K', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.title(\"Figure 1: Employment, capital accumulation, and income\")\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#directed-graph",
    "href": "a_ricardian_one_sector_model.html#directed-graph",
    "title": "14  A Ricardian One-Sector Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 10 variables: Y W w MPL R P K N A wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\nM_mat=matrix(c(0,0,0,0,0,0,0,1,1,0,\n               0,0,0,0,0,0,1,0,0,0,\n               0,1,0,0,1,0,0,1,0,0,\n               0,0,0,0,0,0,0,1,1,0,\n               1,0,0,1,0,0,0,1,0,0,\n               1,0,1,0,1,0,0,1,0,0,\n               0,0,0,0,0,1,0,0,0,0,\n               0,0,1,0,0,0,0,0,0,1,\n               0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0), 10,10, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create and plot directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"W\", \"w\", \"MPL\", \"R\", \"P\", \"K\", \"N\", \"A\", expression(w^S))\n\n# Plot directed graph\nplot(dg, main=\"Figure 5: Directed graph of Ricardian One-Sector Model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create directed graph\n\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 10 variables: Y W w MPL R P K N A wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\nM_mat = np.array([\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 1, 0, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n    [1, 0, 1, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: 'Y', 1: 'W', 2: 'w', 3: 'MPL', 4: 'R', 5: 'P', 6: 'K', 7: 'N', 8: 'A', 9: 'wS'}\n\n# Plot the graph\npos = nx.spring_layout(G)\nnx.draw_networkx(G, pos, node_size=500, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=12, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure 5: Directed graph of Ricardian One-Sector Model\")\nplt.show()\n\n\n\n\nIn Figure 5, it can be seen that productivity (\\(A\\)) and the subsistence wage (\\(w^S\\)) are the key exogenous variables that impact income and the marginal product of labour, and population dynamics, respectively. Most other variables are endogenous and form a closed loop (or cycle) within the system. Profits are a residual. The directed graph illustrates the supply-driven nature of the model, where productivity determines employment and distribution, which in turn feed back into income and capital accumulation. At the same time, income distribution has an exogenous element in the form of the subsistence wage, which feeds into the system.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#analytical-discussion",
    "href": "a_ricardian_one_sector_model.html#analytical-discussion",
    "title": "14  A Ricardian One-Sector Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo analyse the dynamics, combine Equation 14.1 to Equation 14.6 and substitute into Equation 14.7. Further use Equation 14.2 and Equation 14.3 in Equation 14.8. This yields the two-dimensional dynamic system in \\(K_t\\) and \\(N_t\\):\n\\[\nK_t = (1-\\beta)K_{t-1}+\\beta(aA N_{t-1}^a )\n\\] \\[\nN_t = N_{t-1} +\\gamma\\left(\\frac{K_{t-1}}{N_{t-1}} -w^S\\right)\n\\] The Jacobian matrix is given by: \\[\nJ(K, N)=\\begin{bmatrix} 1-\\beta& \\beta a^2AN^{\\alpha-1} \\\\\\frac{\\gamma}{N} & 1-\\frac{\\gamma K}{N^2} \\end{bmatrix}.\n\\]\nFrom equations Equation 14.7 and Equation 14.8, it can readily be seen that an equilibrium is reached when \\[\nP^*=0\n\\] and \\[\nw^*=w^S.\n\\] Using \\(P^*=0\\) with Equation 14.5 and Equation 14.6, yields \\(w^*=w^S=MPL\\). Thus, in equilibrium, profits are zero, and the real wage is equal to the MPL and the subsistence wage. Setting \\(K_t=K_{t-1}\\) and \\(N_t=N_{t-1}\\), we can further derive:\n\\[\nK^*=aA\\left(\\frac{w^S}{aA}\\right)^{-\\frac{a}{1-a}}\n\\] and\n\\[\nN^*=\\left(\\frac{w^S}{aA}\\right)^{-\\frac{1}{1-a}}\n\\] With this, we can evaluate the Jacobian at the steady state: \\[\nJ(K^*, N^*)=\\begin{bmatrix} 1-\\beta & \\beta a w^S \\\\ \\gamma \\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}} & 1-\\gamma aA \\left(\\frac{w^S}{aA}\\right)^{\\frac{2-a}{1-a}}\n\\end{bmatrix}.\n\\] For the system to be stable, both eigenvalues of the Jacobian need to be inside the unit circle. This requires the following three conditions to hold:\n\\[\n1+tr(J)+det(J)&gt;0\n\\] \\[\n1-tr(J)+det(J)&gt;0\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nLet us consider the Classical case where \\(\\beta=1\\), i.e. all profits are reinvested. Then we have\n\\[\ndet(J)=-aw^S \\gamma \\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}}&lt;0,\n\\] so that the third condition is always satisfied and it is the first one that is binding. The first condition then becomes\n\\[\n2-\\gamma a \\left[ A \\left(\\frac{w^S}{aA}\\right)^{\\frac{2-a}{1-a}} + w^S\\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}} \\right]&gt;0\n\\]\nWe can check the analytical solutions and stability conditions numerically:\n\n# Calculate equilibrium solutions\nfor (i in 1:S){\n  N_eq[i]=(wS[i,Q]/(a[i,Q]*A[i,Q]))^(-1/(1-a[i,Q]))\n  K_eq[i]=a[i,Q]*A[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^(-a[i,Q]/(1-a[i,Q]))\n}\n\n# Compare with numerical solutions (here only for baseline)\nN_eq[1]\n\n[1] 30.94046\n\nN[1,Q]\n\n[1] 30.94031\n\nK_eq[1]\n\n[1] 15.47023\n\nK[1,Q]\n\n[1] 15.47018\n\n### Examine model properties (here for the baseline scenario only)\n# Construct Jacobian matrix at the equilibrium \nJ=matrix(c(1-beta, beta*a[1,Q]*wS[1,Q],\n           beta*(wS[1,Q]/(a[1,Q]*A[1,Q]))^(1/(1-a[1,Q])),\n           1-gamma*a[1,Q]*A[1,Q]*(wS[1,Q]/(a[1,Q]*A[1,Q]))^((2-a[1,Q])/(1-a[1,Q]))), 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values = ev$values)\n\n[1]  0.93134557 -0.01214592\n\n# Obtain determinant and trace\ndet=det(J)      # determinant\ntr=sum(diag(J)) # trace\n\n#Check general stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n# Check specific stability condition for the case beta=1\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(2-gamma*a[i,Q]*(A[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^((2-a[i,Q])/(1-a[i,Q])) \n                      + wS[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^(1/(1-a[i,Q])))&gt;0)\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Initialize arrays for equilibrium solutions\nN_eq = np.zeros(S)\nK_eq = np.zeros(S)\n\n# Calculate equilibrium solutions\nfor i in range(S):\n    N_eq[i] = (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (-1 / (1 - a[i, Q-1]))\n    K_eq[i] = a[i, Q-1] * A[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (-a[i, Q-1] / (1 - a[i, Q-1]))\n\n# Compare with numerical solutions (here only for baseline)\nN_eq[0]\nN[0,Q-1]\n\n# Construct Jacobian matrix at the equilibrium \nJ = np.array([\n    [1 - beta, beta * a[0, Q-1] * wS[0, Q-1]],\n    [beta * (wS[0, Q-1] / (a[0, Q-1] * A[0, Q-1])) ** (1 / (1 - a[0, Q-1])),\n     1 - gamma * a[0, Q-1] * A[0, Q-1] * (wS[0, Q-1] / (a[0, Q-1] * A[0, Q-1])) ** ((2 - a[0, Q-1]) / (1 - a[0, Q-1]))]\n])\n\n# Obtain eigenvalues\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\n\n# Check general stability conditions\nprint(1+tr+det&gt;0)\nprint(1-tr+det&gt;0)\nprint(1-det&gt;0)\n\n# Check specific stability condition for the case beta=1\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(2 - gamma * a[i, Q-1] * (\n        A[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** ((2 - a[i, Q-1]) / (1 - a[i, Q-1])) +\n        wS[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (1 / (1 - a[i, Q-1]))\n    ) &gt; 0)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#references",
    "href": "a_ricardian_one_sector_model.html#references",
    "title": "14  A Ricardian One-Sector Model",
    "section": "References",
    "text": "References\n\n\n\n\nFoley, Duncan K. 2006. Adam’s Fallacy. A Guide to Economic Theology. Cambridge, MA / London: Harvard University Press.\n\n\nPasinetti, Luigi L. 1960. “A Mathematical Formulation of the Ricardian System.” The Review of Economic Studies 27 (2): 78–98. https://doi.org/10.2307/2296129.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#footnotes",
    "href": "a_ricardian_one_sector_model.html#footnotes",
    "title": "14  A Ricardian One-Sector Model",
    "section": "",
    "text": "See chapter 2 of Foley (2006) for an excellent introduction.↩︎\nSee Chapter 15 for a two-sector extension of the model.↩︎\nPasinetti (1960) specifies a generic function \\(f(N_t)\\) with \\(f(0) \\geq\\) 0, \\(f'(0) &gt; w^*\\), and \\(f''(N_t) &lt; 0\\). Equation 14.1 satisfies these conditions.↩︎\nEquation 14.5 is based on the definition of total rent as the sum of the net gains of the non-marginal landowners. See Pasinetti (1960) for a formal derivation.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html",
    "href": "a_ricardian_two_sector_model.html",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "",
    "text": "The Model\nThe following equations describe the model: \\[\nY_t=AN_{1t}^{a_1}\n\\tag{15.1}\\]\n\\[\nMPL_t =\\frac{\\partial Y_{1t}}{\\partial N_{1t}} =a_1AN_{1t}^{a_1-1}\n\\tag{15.2}\\]\n\\[\nN_{1t}=N_t - N_{2t}\n\\tag{15.3}\\]\n\\[\nW_t=K_t\n\\tag{15.4}\\]\n\\[\nw_t =\\frac{W_t}{N_t}\n\\tag{15.5}\\]\n\\[\nR_t =  Y_{1t} - N_{1t}MPL_{t}\n\\tag{15.6}\\]\n\\[\nP_{1t} = Y_{1t} - R_t - N_{1t}w_t\n\\tag{15.7}\\]\n\\[\np_{1t}=\\frac{1}{MPL_t}\n\\tag{15.8}\\]\n\\[\nY_{2t}=\\left(\\frac{p_{1t}}{p_{2}}\\right)R_t\n\\tag{15.9}\\]\n\\[\nN_{2t} = \\frac{Y_{2t}}{a_2}\n\\tag{15.10}\\]\n\\[\np_{2}=\\frac{1}{a_2}\n\\tag{15.11}\\]\n\\[\nP_{2t}=Y_{2t}-\\left(\\frac{p_{1t}}{p_{2}}\\right)N_{2t}w_t\n\\tag{15.12}\\]\n\\[\nP_{t}=p_{1t}Y_{1t}+p_{2}Y_{2t}-p_{1t}R_t -p_{1t}W_t\n\\tag{15.13}\\]\n\\[\nK_t = K_{t-1} + g\\left(\\frac{P_{t-1}}{p_{1t-1}}\\right)\n\\tag{15.14}\\]\n\\[\nN_t = N_{t-1} + \\gamma (w_{t-1} - w^S)\n\\tag{15.15}\\]\nwhere \\(Y_t\\), \\(A\\), \\(N_t\\), \\(W_t\\), \\(K_t\\),\\(w_t\\), \\(Y_t\\), \\(MPL_t\\), \\(R_t\\), \\(P_t\\), \\(p\\), and \\(w^S\\) are real output, productivity, employment, the real wage bill (or wage fund), the capital stock (in terms of corn), the real wage rate (in terms of corn), the marginal product of labour (in the corn sector), rents, profits, prices, and the subsistence wage, respectively. The subscripts 1 and 2 denote the corn, i.e. agricultural, sector and the luxury goods sectors, respectively.\nEquation 15.1 is the production function with \\(\\alpha \\in (0,1)\\), i.e. exhibiting diminishing marginal returns to labour.3 By Equation 15.4, the wage fund is defined as the capital stock of this model (reflecting the fact that the production of corn only involves labour). Equation 15.5 defines the real wage rate. Equation 15.5 specifies the marginal product of labour. By Equation 15.3, employment in agriculture is residually determined after employment in the luxury goods sector has been determined (more on this below) Equation 15.6 captures the determination of (differential) rents as a negative function of the marginal product of labour.4 Thus, the lower the productivity on the marginal land, the higher the rents. By Equation 15.7, profits in agriculture are determined residually. Equation Equation 15.8 specifies price determination and captures Ricardo’s labour theory of value according to which the value of a good (net of rent) is determined by the quantity of labour required to produce it. 5\nEquation 15.9 specifies that the production of the luxury good is demand determined. Only landlords consume luxuries and they spend all their income (rent) on luxuries.6 With production in sector 2 demand determined, employment in sector 2 as given by Equation 15.10 must accommodate based on the production function \\(Y_{2t}=a_2N_{2t}\\). With employment in sector 2 pinned down in this way and total employment given by the wage fund (Equation 15.4), employment in sector 1 must be the residual (as specified in equation Equation 15.3). From the labour theory of value, \\(p_2Y_2=N_2\\) must hold. Together with the production function \\(Y_{2t}=a_2N_{2t}\\) this yields Equation 15.11 for the price of the luxury good. Note that due to the constant marginal returns in this sector, its price is constant too.7 By Equation 15.12, profits in the luxuries sector are determined residually (note that no rent is paid by this sector).\nEquation 15.13 specifies total profits (in nominal terms).8 Capital accumulation in equation Equation 15.14 is driven by the reinvestment of profits (with \\(\\beta\\) determining the proportion of profits that are reinvested). Finally, Equation 15.15 specifies population dynamics, whereby the population increases whenever the actual real wage is above the subsistence wage, echoing the Malthusian population mechanism.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#simulation",
    "href": "a_ricardian_two_sector_model.html#simulation",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation and initial values used in the simulation. In line with the Classical tradition, it will be assumed that all profits are reinvested, i.e. \\(\\beta=1\\). Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenarios 2-4 model three different forms of technological change: an increase in the productivity parameter \\(A\\) (scenario 2), an increase in the elasticity \\(a_1\\) of agricultural output with respect to labour (scenario 3), and an increase in labour productivity \\(a_2\\) in the luxury good sector (scenario 4). Scenario 5 considers a higher subsistence wage (\\(w^S\\)). In all scenarios the population/employment is initialised below its equilibrium value.\nTable 1: Parameterisation\n\n\nScenario\n\\(A\\)\n\\(a_1\\)\n\\(a_2\\)\n\\(w^S\\)\n\n\n\n1: baseline\n2\n0.7\n0.5\n0.5\n\n\n2: productivity boost I (\\(A\\))\n3\n0.7\n0.5\n0.5\n\n\n3: productivity boost II (\\(a_1\\))\n2\n0.75\n0.5\n0.5\n\n\n4: productivity boost III (\\(a_2\\))\n2\n0.7\n0.55\n0.5\n\n\n5: higher subsistence wage (\\(w^S\\))\n2\n0.7\n0.5\n0.6\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=600\n\n# Set number of scenarios (including baseline)\nS=5\n\n# Set period in which shock/shift will occur\ns=15\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1=matrix(data=1,nrow=S,ncol=Q) # Output in sector 1\nY2=matrix(data=1,nrow=S,ncol=Q) # Output in sector 2\nR=matrix(data=1,nrow=S,ncol=Q) # Rent\nP=matrix(data=1,nrow=S,ncol=Q) # Qotal profits\nP1=matrix(data=1,nrow=S,ncol=Q) # Profits in sector 1\nP2=matrix(data=1,nrow=S,ncol=Q) # Profits in sector 2\nN=matrix(data=1,nrow=S,ncol=Q) # total employment\nN1=matrix(data=1,nrow=S,ncol=Q) # employment in sector 1\nN2=matrix(data=1,nrow=S,ncol=Q) # employment in sector 2\nw=matrix(data=1,nrow=S,ncol=Q) # real wage\nwn=matrix(data=1,nrow=S,ncol=Q) # nominal wage\nK=matrix(data=1,nrow=S,ncol=Q) # capital stock\nMPL=matrix(data=1,nrow=S,ncol=Q) # marginal product of labour (in sector 1)\nr=matrix(data=1,nrow=S,ncol=Q) # profit rate\np1=matrix(data=1,nrow=S,ncol=Q) # price of good from sector 1\np2=matrix(data=1,nrow=S,ncol=Q) # price of good from sector 2\nN_eq=vector(length=S)          # equilibrium population\nK_eq=vector(length=S)          # equilibrium capital\n\ntest=matrix(data=1,nrow=S,ncol=Q) # price of good from sector 2\n\n\n# Set baseline parameter values\nA=matrix(data=2,nrow=S,ncol=Q) # productivity\na1=matrix(data=0.7,nrow=S,ncol=Q) # labour elasticity of output, sector 1\na2=matrix(data=0.5,nrow=S,ncol=Q) # labour coefficient, sector 2\ngamma=5 # adjustment speed of population \nbeta=1 # Sensitivity of investment with respect to profits\nwS=matrix(data=0.5,nrow=S,ncol=Q) # natural wage rate\n\n# Set parameter values for different scenarios\nA[2,s:Q]=3     # scenario 2: productivity boost I\na1[3,s:Q]=0.75 # scenario 3: productivity boost II\na2[4,s:Q]=0.55 # scenario 4: productivity boost III\nwS[5,s:Q]=0.6  # scenario 5: higher subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN1[,1]=1\nN2[,1]=1\nN[,1]=N1[,1]+N2[,1]\nK[,1]=1\nw[,1]=wS[,1]\nY1[,1]=A[,1]*N1[,1]^(a1[,1])\nMPL[,1]=a1[,1]*A[,1]*(N1[,1]^(a1[,1]-1))\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n\n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # run the model 1000-times in each period\n      \n    #Model equations\n      \n      #(2) Wage bill (omitted for simplicity)\n      #W[i,t]=K[i,t] \n\n      #(3) Output sector 1\n      Y1[i,t] = A[i,t]*(N1[i,t]^a1[i,t])\n      \n      #(4) Employment sector 1\n      N1[i,t] = N[i,t] - N2[i,t]\n\n      #(5) Marginal product of labour (sector 1)\n      MPL[i,t]=a1[i,t]*A[i,t]*(N1[i,t]^(a1[i,t]-1))\n\n      #(6) Rent (simplified equation)\n      R[i,t]= Y1[i,t]*(1-a1[i,t]) \n      \n      #(7) Profits sector 1\n      P1[i,t] = Y1[i,t] - R[i,t] - N1[i,t]*w[i,t]\n\n      #(8) Prices sector 1\n      p1[i,t] = 1/(MPL[i,t])        \n\n      #(9) Output sector 2\n      Y2[i,t]=(p1[i,t]/p2[i,t])*R[i,t]\n      \n      #(3 Real wage rate\n      w[i,t] = K[i,t]/N[i,t] \n      \n      #(10) Employment sector 2\n      N2[i,t]= Y2[i,t]/a2[i,t]\n\n      #(11) Prices\n      p2[i,t] = 1/a2[i,t]\n\n      #(12) Profits sector 2\n      P2[i,t] = Y2[i,t] - (p1[i,t]/p2[i,t])*N2[i,t]*w[i,t]\n\n      #(13) Total profits\n      P[i,t]=p1[i,t]*Y1[i,t] + p2[i,t]*Y2[i,t] - p1[i,t]*R[i,t] - p1[i,t]*K[i,t]\n\n      #(14) Capital accumulation\n      K[i,t]= K[i,t-1] + beta*(P[i,t-1]/p1[i,t-1])\n      \n      #(8) Employment/population dynamics  \n      N[i,t] = N[i,t-1] + gamma*(w[i,t-1] - wS[i,t-1])\n      \n    } # close iterations loop\n  } # close time loop\n} # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 600\n\n# Set number of scenarios (including baseline)\nS = 5\n\n# Set period in which shock/shift will occur\ns = 15\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1 = np.ones((S, Q))\nY2 = np.ones((S, Q))\nR = np.ones((S, Q))\nP = np.ones((S, Q))\nP1 = np.ones((S, Q))\nP2 = np.ones((S, Q))\nN = np.ones((S, Q))\nN1 = np.ones((S, Q))\nN2 = np.ones((S, Q))\nw = np.ones((S, Q))\nwn = np.ones((S, Q))\nK = np.ones((S, Q))\nMPL = np.ones((S, Q))\nr = np.ones((S, Q))\np1 = np.ones((S, Q))\np2 = np.ones((S, Q))\nN_eq = np.zeros(S)\nK_eq = np.zeros(S)\ntest = np.ones((S, Q))\n\n# Set baseline parameter values\ngamma = 5\nbeta = 1\nA = np.full((S, Q), 2.0)\na1 = np.full((S, Q), 0.7)\na2 = np.full((S, Q), 0.5)\nwS = np.full((S, Q), 0.5)\n\n# Set parameter values for different scenarios\nA[1, s:] = 3     # scenario 2: productivity boost I\na1[2, s:] = 0.75 # scenario 3: productivity boost II\na2[3, s:] = 0.55 # scenario 4: productivity boost III\nwS[4, s:] = 0.6  # scenario 5: higher subsistence wage\n\n# Initialize variables\nN1[:, 0] = 1\nN2[:, 0] = 1\nN[:, 0] = N1[:, 0] + N2[:, 0]\nK[:, 0] = 1\nw[:, 0] = wS[:, 0]\nY1[:, 0] = A[:, 0] * N1[:, 0] ** (a1[:, 0])\nMPL[:, 0] = a1[:, 0] * A[:, 0] * (N1[:, 0] ** (a1[:, 0] - 1))\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for iterations in range(1000):\n            # Model equations\n            Y1[i, t] = A[i, t] * (N1[i, t] ** a1[i, t])\n            N1[i, t] = N[i, t] - N2[i, t]\n            MPL[i, t] = a1[i, t] * A[i, t] * (N1[i, t] ** (a1[i, t] - 1))\n            R[i, t] = Y1[i, t] * (1 - a1[i, t])\n            P1[i, t] = Y1[i, t] - R[i, t] - N1[i, t] * w[i, t]\n            p1[i, t] = 1 / MPL[i, t]\n            Y2[i, t] = (p1[i, t] / p2[i, t]) * R[i, t]\n            w[i, t] = K[i, t] / N[i, t]\n            N2[i, t] = Y2[i, t] / a2[i, t]\n            p2[i, t] = 1 / a2[i, t]\n            P2[i, t] = Y2[i, t] - (p1[i, t] / p2[i, t]) * N2[i, t] * w[i, t]\n            P[i, t] = p1[i, t] * Y1[i, t] + p2[i, t] * Y2[i, t] - p1[i, t] * R[i, t] - p1[i, t] * K[i, t]\n            K[i, t] = K[i, t - 1] + beta * (P[i, t - 1] / p1[i, t - 1])\n            N[i, t] = N[i, t - 1] + gamma * (w[i, t - 1] - wS[i, t - 1])\n\n\n\n\nPlots\nFigures 1-4 illustrate the model’s dynamics under the baseline parameterisation. Starting from below-equilibrium levels, the economy grows in terms of output, capital, and employment but then approaches what Ricardo famously called a ‘stationary state’. Figure 3 shows that during the adjustment phase, the MPL declines, reflecting diminishing marginal returns in agriculture. This captures the idea that a growing economy will have to utilise less fertile lands. The real wage is driven up until it is equal to the MPL. Figure 4 shows that total profits initially increase but are then squeezed to zero as differential rents increase.\n\n# Set start and end periods for plots\nTmax=100\nTmin=6\n\n## Baseline\n#Employment and capital accumulation\nplot(N[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Employment and capital accumulation\",ylab = 'N', xlab = 'Time', cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(K[1, Tmin:(Tmax+1)]), cex=0.8)\naxis(side = 4, at = pretty(range(K[1, 2:(Tmax+1)])))  \nmtext(\"K\", side = 4, line = 2)\nlegend(\"bottomright\", legend=c(\"N\", \"K\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n#Output in the two sectors\nplot(Y1[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(Y1[1, Tmin:Tmax],Y2[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 2: Output in agriculture and luxuries\", xlab = 'Time',cex=0.8 ,line=2)\nlines(Y2[1, Tmin:(Tmax+1)],lty=2)\nlegend(\"bottomright\", legend=c(\"Y1\", \"Y2\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Real wage, MPL, and subsistence wage\nplot(w[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(wS[1, Tmin:Tmax],w[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 3: Real wage, marginal product of labour, and subsistence wage\", xlab = 'Time',cex=0.8,line=2)\nlines(MPL[1, Tmin:Tmax],lty=2)\nlines(wS[1, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"w\", \"MPL\", \"wS\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Total Profits and Rents\nplot(P[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(P[1, Tmin:Tmax],R[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 4: Total profits and rents\", xlab = 'Time',cex=0.8,line=2)\nlines(R[1, Tmin:(Tmax+1)],lty=2)\nlegend(\"right\", legend=c(\"P\", \"R\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nFigures 5 and 6 display capital accumulation under the five different scenarios described in Table 1. Technical change that increases productivity in agriculture (scenarios 2 and 3) raises the speed of capital accumulation and the equilibrium level of capital. By contrast, an increase in productivity in the luxury good sector (scenario 4) has no effect on capital accumulation. This is because productivity in sector 2 has no effects on functional income distribution.9 An increase in the initial stock of capital (scenario 5) raises the steady state value. Thus, economies with larger initial endowments will reach a higher level of income in the stationary state.\n\n## Scenarios\n# Capital accumulation under scenarios 1-3\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(K[1, Tmin:Tmax], K[2, Tmin:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 5: Capital accumulation under different scenarios (pt 1)\",ylab = 'K', xlab = 'Time',cex=0.8, line=2)\nlines(K[2, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(K[3, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"topleft\", legend=c(\"1: baseline\",\"2: productivity boost I\", \"3: productivity boost II\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Capital accumulation under scenarios 1, 4+5\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(K[1, Tmin:Tmax], K[5, Tmin:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 6: Capital accumulation under different scenarios (pt 2)\",ylab = 'K', xlab = 'Time',cex=0.8, line=2)\nlines(K[4, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(K[5, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"topleft\", legend=c(\"1: baseline\",\"4: productivity boost III\", \"5: higher subsist. wage\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nFigures 7 and 8 show the dynamics of relative prices (corn price relative to luxury good price) for the different scenarios. Over time, corn becomes more expensive in relative turns due to diminishing marginal returns. Improvements in labour productivity reduce the relative price of the respective sector in line with the labour theory of value.\n\n# Relative prices under scenarios 1 - 3\nrelpr=p1/p2\nplot(relpr[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     main=\"Figure 7: Relative prices under different scenarios (pt 1)\",ylab = 'p1/p2',xlab = 'Time',ylim = range(relpr[1, Tmin:(Tmax+1)], relpr[2, Tmin:(Tmax+1)]),cex=0.8)\nlines(relpr[2, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(relpr[3, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: baseline\", \"2: productivity boost I\", \"3: productivity boost II\"),lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Relative prices under scenarios 1, 4-5\nplot(relpr[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     main=\"Figure 8: Relative prices under different scenarios (pt 2)\",ylab = 'p1/p2',xlab = 'Time',ylim = range(relpr[1, Tmin:(Tmax+1)], relpr[4, Tmin:(Tmax+1)]),cex=0.8)\nlines(relpr[4, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(relpr[5, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: baseline\", \"4: productivity boost III\", \"5: higher subsist. wage\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plots (here for employment and capital accumulation only)\n\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 100\nTmin = 6\n\n# Baseline\n# Employment and capital accumulation\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\n\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(K[0, 2:Tmax], linestyle='dashed', label='K', linewidth=0.8, color=\"black\")\nax2.set_ylabel('K', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.title(\"Figure 1: Employment and capital accumulation\")\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#directed-graph",
    "href": "a_ricardian_two_sector_model.html#directed-graph",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).10\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 18 variables: \n#(1)Y1 (2)N1 (3)MPL (4)R (5)P1 (6)p1 (7)Y2 (8)w (9)N2 (10)p2 (11)P2\n#(12)P (13)K (14)N (15)A (16)a1 (17)a2 (18)wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\n#              1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\nM_mat=matrix(c(0,1,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 1, 1, 0, 0, #1\n               0,0,0,0,0,0,0,0,1,0, 0, 0, 0, 1, 0, 0, 0, 0, #2\n               0,1,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 1, 1, 0, 0, #3\n               1,1,1,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #4\n               1,1,0,1,0,0,0,1,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #5\n               0,0,1,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #6\n               0,0,0,1,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #7\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 1, 1, 0, 0, 0, 0, #8\n               0,0,0,0,0,0,1,0,0,0, 0, 0, 0, 0, 0, 0, 1, 0, #9\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 1, 0, #10\n               0,0,0,0,0,0,1,1,1,0, 0, 0, 0, 0, 0, 0, 0, 0, #11 \n               0,0,0,0,1,0,0,0,0,0, 1, 0, 0, 0, 0, 0, 0, 0, #12\n               0,0,0,0,0,0,0,0,0,0, 0, 1, 0, 0, 0, 0, 0, 0, #13\n               0,0,0,0,0,0,0,1,0,0, 0, 0, 0, 0, 0, 0, 0, 1, #14\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #15\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #16\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #17\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0  #18\n               ), 18,18, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create and plot directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(expression(Y[1]), expression(N[1]), \"MPL\", \"R\", expression(P[1]), \n             expression(p[1]), expression(Y[2]), \"w\", expression(N[2]), \n             expression(p[2]), expression(P[2]), \"P\", \"K\", \"N\", \"A\", \n             expression(a[1]), expression(a[2]), expression(w^S))\n\n# Plot directed graph\n# Plot directed graph\nplot(dg, main=\"Figure 9: Directed graph\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=0.8, \n     vertex.frame.color=\"NA\", margin=0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create directed graph\n\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 18 variables: \n#(1)Y1 (2)N1 (3)MPL (4)R (5)P1 (6)p1 (7)Y2 (8)w (9)N2 (10)p2 (11)P2\n#(12)P (13)K (14)N (15)A (16)a1 (17)a2 (18)wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\n#                    1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18\nM_mat = np.array([  [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], #1\n                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], #2\n                    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], #3\n                    [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #4\n                    [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #5\n                    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #6\n                    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #7\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], #8\n                    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], #9\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], #10\n                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], #11\n                    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], #12\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], #13\n                    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], #14\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #15\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #16\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #17\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])#18\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {\n    0: r'$Y_1$', 1: r'$N_1$', 2: 'MPL', 3: 'R', 4: r'$P_1$', \n    5: r'$p_1$', 6: r'$Y_2$', 7: 'w', 8: r'$N_2$', 9: r'$p_2$', \n    10: r'$P_2$', 11: 'P', 12: 'K', 13: 'N', 14: 'A', \n    15: r'$a_1$', 16: r'$a_2$', 17: r'$w^S$'\n}\n\n# Plot the graph\npos = nx.spring_layout(G, k=0.9)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure: Directed graph of Ricardian Two-Sector Model\")\nplt.show()\n\n\n\n\nIn Figure 9, it can be seen that productivity in agriculture (\\(A\\) and \\(a_1\\)) are key exogenous variables that impact income in sector 1 and the marginal product of labour. The subsistence wage (\\(w^S\\)) is another exogenous variable that impacts the system through its effect on population dynamics. Productivity in the luxuries sector (\\(a_2\\)) feeds into the system via employment.ost other variables are endogenous and form a closed loop (or cycle) within the system. Profits are a residual. The directed graph illustrates the supply-driven nature of the agricultural sector, where (marginal) productivity determine employment and distribution. By contrast, the luxury goods sector is demand-determined with employment being the residual. Profits determine capital accumulation, which in turn provides funds that can be used to hire more agricultural workers. A higher subsistence wage reduces capital accumulation as it leaves fewer profits to be reinvested.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#analytical-discussion",
    "href": "a_ricardian_two_sector_model.html#analytical-discussion",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo analyse the dynamics, combine Equation 15.1 to Equation 15.13 and substitute into Equation 15.14. Further use Equation 15.4 and Equation 15.5 in Equation 15.15. This yields the two-dimensional dynamic system in \\(K_t\\) and \\(N_t\\):\n\\[\nK_t = (1-\\beta)K_{t-1}+\\beta(a_1^{a_1}A N_{t-1}^{a_1} )\n\\] \\[\nN_t = N\\_{t-1} +\\gamma\\left(\\frac{K_{t-1}}{N_{t-1}} -w^S\\right)\n\\] The Jacobian matrix is given by:\n\\[\nJ(K, N)=\\begin{bmatrix} 1-\\beta& \\beta a_1^{1+a_1}AN^{a_1-1} \\\\\\frac{\\gamma}{N} & 1-\\frac{\\gamma K}{N^2} \\end{bmatrix}.\n\\]\nFrom equations Equation 15.14 and Equation 15.15, it can readily be seen that an equilibrium is reached when \\[\nP^*=0\n\\] and \\[\nw^*=w^S.\n\\] Using \\(P^*=0\\) with Equation 15.6 and Equation 15.13, yields \\(w^*=w^S=MPL\\). Thus, in equilibrium, profits are zero, and the real wage is equal to the MPL and the subsistence wage. Setting \\(K_t=K_{t-1}\\) and \\(N_t=N_{t-1}\\), we can further derive:\n\\[\nK^*=a_1^{a_1}A\\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{-\\frac{a_1}{1-a_1}}\n\\] and\n\\[\nN^*=\\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{-\\frac{1}{1-a_1}}\n\\] With this, we can evaluate the Jacobian at the steady state: \\[\nJ(K^*, N^*)=\\begin{bmatrix} 1-\\beta & \\beta a_1 w^S \\\\ \\gamma \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{1}{1-a_1}} & 1-\\gamma a_1^{a_1}A \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{2-a_1}{1-a_1}}\n\\end{bmatrix}.\n\\] For the system to be stable, both eigenvalues of the Jacobian need to be inside the unit circle. This requires the following three conditions to hold:\n\\[\n1+tr(J)+det(J)&gt;0\n\\] \\[\n1-tr(J)+det(J)&gt;0\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nLet us consider the Classical case where \\(\\beta=1\\), i.e. all profits are reinvested. Then we have\n\\[\ndet(J)=-a_1w^S \\gamma \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{1}{1-a_1}}&lt;0,\n\\]\nso that the third condition is always satisfied and it is the first one that is binding. The first condition then becomes\n\\[\n2-\\gamma  \\left[a_1^{a_1} A \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{2-a_1}{1-a_1}} + a_1 w^S\\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{1}{1-a_1}} \\right]&gt;0\n\\]\nWe can check the analytical solutions and stability conditions numerically:\n\n# Calculate equilibrium solutions\nfor (i in 1:S){\n  N_eq[i]=(wS[i,Q]/((a1[i,Q]^a1[i,Q])*A[i,Q]))^(-1/(1-a1[i,Q]))\n  K_eq[i]=(a1[i,Q]^a1[i,Q])*A[i,Q]*(wS[i,Q]/((a1[i,Q]^a1[i,Q])*A[i,Q]))^(-a1[i,Q]/(1-a1[i,Q]))\n}\n\n# Compare with numerical solutions (here for the example of Y, baseline)\nN_eq[1]\n\n[1] 44.20066\n\nN[1,Q]\n\n[1] 44.19942\n\nK_eq[1]\n\n[1] 22.10033\n\nK[1,Q]\n\n[1] 22.09989\n\n### Examine model properties (here for the baseline scenario only)\n# Construct Jacobian matrix at the equilibrium \nJ=matrix(c(1-beta, \n           beta*a1[1,Q]*wS[1,Q],\n           gamma*(wS[1,Q]/((a1[i,Q]^a1[i,Q])*A[1,Q]))^(1/(1-a1[1,Q])),\n           1-gamma*(a1[i,Q]^a1[i,Q])*A[1,Q]*(wS[1,Q]/((a1[i,Q]^a1[i,Q])*A[1,Q]))^((2-a1[1,Q])/(1-a1[1,Q]))), 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values = ev$values)\n\n[1]  0.98368845 -0.04024869\n\n# Obtain determinant and trace\ndet=det(J)      # determinant\ntr=sum(diag(J)) # trace\n\n#Check stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n# Check specific stability condition for the case beta=1\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(2-gamma*((a1[i,Q]^a1[i,Q])*A[i,Q]*(wS[i,Q]/(((a1[i,Q]^a1[i,Q])*A[i,Q])))^((2-a1[i,Q])/(1-a1[i,Q]))) + a1[i,Q]*wS[i,Q]*(wS[i,Q]/(((a1[i,Q]^a1[i,Q])*A[i,Q]))^(1/(1-a1[i,Q])))&gt;0)\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n[1] \"Scenario 5:\"\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Initialize arrays for equilibrium solutions\nN_eq = np.zeros(S)\nK_eq = np.zeros(S)\n\n# Calculate equilibrium solutions\nfor i in range(S):\n    N_eq[i] = (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** (-1 / (1 - a1[i, Q-1]))\n    K_eq[i] = (a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1] * (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** (-a1[i, Q-1] / (1 - a1[i, Q-1]))\n\n# Compare with numerical solutions (example for N, baseline)\nN_eq[0]\nN[0,Q-1]\n\n# Construct Jacobian matrix at the equilibrium \nJ = np.array([\n    [1 - beta, beta * a1[0, Q-1] * wS[0, Q-1]],\n    [gamma * (wS[0, Q-1] / ((a1[0, Q-1] ** a1[0, Q-1]) * A[0, Q-1])) ** (1 / (1 - a1[0, Q-1])),\n     1 - gamma * (a1[0, Q-1] ** a1[0, Q-1]) * A[0, Q-1] * (wS[0, Q-1] / ((a1[0, Q-1] ** a1[0, Q-1]) * A[0, Q-1])) ** ((2 - a1[0, Q-1]) / (1 - a1[0, Q-1]))]\n])\n\n# Obtain eigenvalues\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\n\n# Check general stability conditions\nprint(1+tr+det&gt;0)\nprint(1-tr+det&gt;0)\nprint(1-det&gt;0)\n\n# Check specific stability condition for the case beta=1\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(2 - gamma * (\n        (a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1] * \n        (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** ((2 - a1[i, Q-1]) / (1 - a1[i, Q-1])) +\n        a1[i, Q-1] * wS[i, Q-1] * (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** (1 / (1 - a1[i, Q-1]))\n    ) &gt; 0)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#references",
    "href": "a_ricardian_two_sector_model.html#references",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "References",
    "text": "References\n\n\n\n\nFoley, Duncan K. 2006. Adam’s Fallacy. A Guide to Economic Theology. Cambridge, MA / London: Harvard University Press.\n\n\nPasinetti, Luigi L. 1960. “A Mathematical Formulation of the Ricardian System.” The Review of Economic Studies 27 (2): 78–98. https://doi.org/10.2307/2296129.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#footnotes",
    "href": "a_ricardian_two_sector_model.html#footnotes",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "",
    "text": "See chapter 2 of Foley (2006) for an excellent introduction.↩︎\nSee Chapter 14 for a simpler one-sector version of the model,↩︎\nPasinetti (1960) specifies a generic function \\(f(N_t)\\) with \\(f(0) \\geq\\) 0, \\(f'(0) &gt; w^*\\), and \\(f''(N_t) &lt; 0\\). Equation 15.1 satisfies these conditions.↩︎\nEquation 15.6 is based on the definition of total rent as the sum of the net gains of the non-marginal landowners. See Pasinetti (1960) for a formal derivation. Note that by using Equation 15.2, Equation 15.6 can also be written as \\(R_t = Y_{1t}(1-a_1)\\).↩︎\nTo see this, notice that equation Equation 15.8 can be derived from \\(p_{t1}Y_{t1}-p_{t1}R_{t}=N_{t1}\\) if combined with equation Equation 15.6.↩︎\nOutput in equation Equation 15.9 is expressed in real terms and can be derived from \\(p_{2}Y_{2t}=p_{1t}R_t\\).↩︎\nThe luxury good may therefore serve as Ricardo’s ‘invariable standard of value’ in terms of which the value of all commodities could be expressed.↩︎\nNote that by combining Equation 15.13 with Equation 15.9, total profits can also be written as \\(P_t=p_{1t}(Y_{1t} - W_t)\\). In other words, total profits are independent of output in sector 2.↩︎\nThe increase in \\(a_2\\) does raise real output and profits in sector 2 but it leaves total profits unchanged.↩︎\nValuation effects from changes in relative prices were omitted for simplicity.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html",
    "href": "a_Lewis_model.html",
    "title": "16  A Lewis Model of Economic Development",
    "section": "",
    "text": "Overview\nThis model captures some key features of W. Arthur Lewis (1954)’ two-sector model of the growth process of a developing country. The model describes the development process as one where a modern urban sector draws labour inputs from a traditional subsistence sector that is characterised by surplus labour, i.e. labour that does not produce any additional output (reflected in a zero marginal product). Workers in the traditional sector are paid a fixed subsistence wage. The presence of surplus labour allows the modern sector to attract workers from the traditional sector for a small wage premium above the subsistence wage. This enables the modern sector to make excess profits that are reinvested and thus drive rapid capital accumulation in the modern sector. As a result, the economy undergoes industrialisation. This process of rapid structural change comes to an end when the surplus labour in the traditional sector is depleted. Labour supply then becomes sensitive to the real wage, leading to a slowdown in the growth of profits and capital accumulation.\nWe present a formal version of the model that is adapted from the graphical representation in Todaro and Smith (2015), pp. 124-127.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#the-model",
    "href": "a_Lewis_model.html#the-model",
    "title": "16  A Lewis Model of Economic Development",
    "section": "The Model",
    "text": "The Model\n\\[\n    Y_{1t}=\n\\begin{cases}\n    \\lambda^\\alpha, &    \\text{if } L_{1t-1} &gt; \\lambda \\\\\n    L^\\alpha_{1t},& \\text{if } L_{1t-1}\\leq \\lambda\n\\end{cases}\n\\tag{16.1}\\]\n\\[\nw_{1t} = w^S  \n\\tag{16.2}\\]\n\\[\nL_{1t} = L - L_{2t}  \n\\tag{16.3}\\]\n\\[\nY_{2t} = L_{2t}^\\beta K_{2t}^{1-\\beta}  \n\\tag{16.4}\\]\n\\[\n    w_{2t}=\n\\begin{cases}\n    w^S(1 + \\rho), &    \\text{if } L_{1t-1} &gt; \\lambda \\\\\n    \\gamma L_{2t},& \\text{if } L_{1t-1}\\leq \\lambda\n\\end{cases}\n\\tag{16.5}\\]\n\\[\nMPL_{2t}= \\frac{\\partial Y_{2t}}{\\partial L_{2t}} = \\frac{\\beta Y_{2t}}{L_{2t}}\n\\tag{16.6}\\]\n\\[\nL_{2t}= L_{2t-1} + \\delta(MPL_{2t-1} - w_{2t-1})\n\\tag{16.7}\\]\n\\[\nP_{2t}=Y_{2t} - w_{2t}L_{2t}\n\\tag{16.8}\\]\n\\[\nK_{2t}=K_{2t-1} + P_{2t-1}\n\\tag{16.9}\\]\nwhere the subscripts 1 and 2 refer to the traditional and modern sector, respectively, and \\(Y_t\\), \\(w_t\\), \\(L_t\\), \\(MPL_t\\), \\(K_t\\), and \\(P_t\\) represent output, the real wage rate, employment, the marginal product of labour, the capital stock, and profits, respectively.\nEquation 16.1 describes output determination in the traditional sector. The variable \\(\\lambda\\) is the employment level beyond which the marginal product of labour (MPL) in sector 1 becomes zero. As long as employment is above this threshold, there is surplus labour and output is fixed at the level implied by the level of employment for which the MPL becomes zero (\\(\\lambda\\)). If actual employment falls below this level, the sector faces a production function that is increasing in employment but with diminishing marginal returns \\((\\alpha \\in (0,1))\\). By Equation 16.2, the real wage in the traditional sector is an exogenously given subsistence wage \\(w^S\\). Equation 16.3 says that the level of employment in the traditional sector is residually determined by the total labour supply net of employment in the modern sector. Total labour is taken to be exogenous. Unlike the traditional sector, the modern sector employs capital. Equation 16.4 is the production function of the modern sector, which exhibits constant returns to scale and diminishing marginal returns \\((\\beta\\in (0,1))\\). Equation 16.5 specifies wage determination in the modern sector. If there is surplus labour in the traditional sector, the modern sector pays a wage premium \\(\\rho\\) on the subsistence wage. As soon as surplus labour is depleted, the modern sector faces an upward-sloping labour supply curve, which we model for simplicity as a linear function with slope coefficient \\(\\gamma\\). Equation 16.6 specifies the marginal product of labour of the modern sector: \\(MPL_{2t}=\\beta L_{2t}^{\\beta-1} K_{2t}^{1-\\beta} = \\beta \\frac{Y_{2t}}{L_{2t}}\\). Equation 16.7 is the labour demand curve of the modern sector. To maximise profits, the firm would have to equalise the real wage and the MPL: \\(w_{2t}=MPL_{2t}\\). Equation 16.7 specifies this as a gradual process, where the rate at which the modern firm attracts workers from the traditional sector is increasing in the gap between their marginal product and the fixed wage the firm pays these workers. Finally, Equation 16.8 defines profits in the modern sector, and Equation 16.9 describes capital accumulation in that sector, where it is assumed that all profits are invested \\((P_{2t}=I_{2t})\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#simulation",
    "href": "a_Lewis_model.html#simulation",
    "title": "16  A Lewis Model of Economic Development",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable reports the parameterisation used in the simulation. All scenarios are initialised such that there is surplus labour (\\(L_{10} &gt; \\lambda\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(L\\)\n\\(\\lambda\\)\n\\(\\alpha\\)\n\\(\\beta\\)\n\\(\\delta\\)\n\\(w^S\\)\n\\(\\gamma\\)\n\n\n\n1: baseline\n20\n10\n0.9\n0.7\n0.5\n0.4\n0.12\n\n\n2: rise subsistence wage (\\(w^S\\))\n20\n10\n0.9\n0.7\n0.5\n0.3\n0.12\n\n\n3: rise in labour supply elasticity (\\(\\gamma\\))\n20\n10\n0.9\n0.7\n0.5\n0.4\n0.17\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=250\n\n# Set number of scenarios (including baseline)\nS=3\n\n# Set period in which shock/shift will occur\ns=1\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1=matrix(data=1,nrow=S,ncol=Q) # Output in sector 1 (traditional)\nY2=matrix(data=1,nrow=S,ncol=Q) # Output in sector 2 (modern)\nL1=matrix(data=1,nrow=S,ncol=Q) # employment in sector 1\nL2=matrix(data=1,nrow=S,ncol=Q) # employment in sector 2\nw2=matrix(data=1,nrow=S,ncol=Q) # real wage sector 2\nMPL2 = matrix(data=1, nrow=S, ncol=Q) # marginal product of labour in sector 2\nK=matrix(data=1,nrow=S,ncol=Q) # capital stock (only in sector 2)\nP2=matrix(data=1,nrow=S,ncol=Q) #  profits in sector 2\n\n# Set fixed parameter values\nalpha=0.9 # labour elasticity of output, sector 1\nrho=1     # wage premium\nL=20      # total labour supply (exogenous)\nlambda=10 # employment at which MPL in sector 1 becomes zero\nbeta=0.7  # labour elasticity of output, sector 2\ndelta = 0.5  # sensitivity of employment in sector 2 to deviation of MPL2 from w2\n\n# Set baseline parameter values\nw1=matrix(data=0.4,nrow=S,ncol=Q) # subsistence real wage sector 1\ngamma=matrix(data=0.12, nrow=S, ncol=Q) # labour supply coefficient, sector 2\n\n# Set parameter values for different scenarios\nw1[2,s:Q]=0.3         # scenario 2: fall in subsistence wage\ngamma[3,s:Q]=0.17     # scenario 3: rise in labour supply elasticity\n\n# Create vectors that will record when the turning point occurs and when the simulation ends\ntp = rep(NA, S)\nend = rep(NA, S)\n\n# Initialise such that there is surplus labour (L1 &gt; lambda)\nL1[,1]= 0.9*L\nL2[,1]= L - L1[,1]\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor (i in 1:S){\n  \n  # Create flag that will be set to TRUE when the turning point has been reached\n  cond = FALSE\n  \n  # Inititalise time index\n  t = 2\n  \n  # Run the model as long as the number of periods Q hasn't been reached yet and employment in sector 1 is positive \n  while (t &lt;= Q && L1[i, t-1] &gt; 0) {\n    \n   for (iterations in 1:1000){ \n      \n      ## Model equations\n      # Output sector1 and wages sector 2\n      if (!cond && L1[i, t-1] &gt; lambda) {\n      Y1[i,t] = lambda^alpha\n      w2[i,t]= w1[i,t]*(1 + rho)\n      }\n      else{\n      Y1[i,t] = (L1[i,t]^alpha)\n      w2[i,t]= gamma[i,t]*L2[i,t]\n      cond = TRUE # set the flag to TRUE once the condition is violated \n                  #(this prevents the iterations loop from getting trapped between the two conditions)\n      }\n\n      # Employment sector 1\n      L1[i,t] = L - L2[i,t]\n     \n      # Output sector 2\n      Y2[i,t]=(L2[i,t]^beta)*(K[i,t]^(1-beta))\n\n      # MPL sector 2\n      MPL2[i,t] = beta* (Y2[i, t]/L2[i, t]) \n            \n      # Employment sector 2 \n      L2[i,t] =L2[i, t-1] + delta*(MPL2[i,t-1] - w2[i,t-1])\n      \n      # Profits sector 2\n      P2[i,t]=Y2[i,t] - w2[i,t]*L2[i,t]\n      \n      # Capital accumulation sector 2\n      K[i,t]= K[i,t-1] + P2[i,t-1]\n\n    } # close iterations loop\n    \n      if (L1[i, t] &gt; lambda) {\n        tp[i] = t # record when turning point occurs\n      }\n    \n      if (L1[i, t] &lt;= 0) {\n        end[i] = t # record when L1 becomes non-positive, which terminates the simulation\n      }\n    \n    # Update time index  \n     t = t + 1\n\n  } # close time loop\n} # close scenarios loop\n\n# Calculate profits in S1\nP1=Y1 - w1*L1\n\n#Calculate aggregate profit share \nPS=(P1 + P2)/(Y1 + Y2)\n\n# Calculate sectoral profit shares\nPS1=(P1)/(Y1)\nPS2=(P2)/(Y2)\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 250\n\n# Set number of scenarios (including baseline)\nS = 3\n\n# Set period in which shock/shift will occur\ns = 1\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1 = np.ones((S, Q))  # Output in sector 1 (traditional)\nY2 = np.ones((S, Q))  # Output in sector 2 (modern)\nL1 = np.ones((S, Q))  # Employment in sector 1\nL2 = np.ones((S, Q))  # Employment in sector 2\nw2 = np.ones((S, Q))  # Real wage sector 2\nMPL2 = np.ones((S, Q))  # Marginal product of labour in sector 2\nK = np.ones((S, Q))  # Capital stock (only in sector 2)\nP2 = np.ones((S, Q))  # Profits in sector 2\n\n# Set fixed parameter values\nalpha = 0.9  # Labour elasticity of output, sector 1\nrho = 1  # Wage premium\nL = 20  # Total labour supply (exogenous)\nlambda_ = 10  # Employment at which MPL in sector 1 becomes zero\nbeta = 0.7  # Labour elasticity of output, sector 2\ndelta = 0.5  # Sensitivity of employment in sector 2 to deviation of MPL2 from w2\n\n# Set baseline parameter values\nw1 = np.full((S, Q), 0.4)  # Subsistence real wage sector 1\ngamma = np.full((S, Q), 0.12)  # Labour supply coefficient, sector 2\n\n# Set parameter values for different scenarios\nw1[1, s:Q] = 0.3  # Scenario 2: fall in subsistence wage\ngamma[2, s:Q] = 0.17  # Scenario 3: rise in labour supply elasticity\n\n# Create vectors that will record when the turning point occurs and when the simulation ends\ntp = np.full(S, np.nan)\nend = np.full(S, np.nan)\n\n# Initialise such that there is surplus labour (L1 &gt; lambda)\nL1[:, 0] = 0.9 * L\nL2[:, 0] = L - L1[:, 0]\n\n# Simulate the model by looping over time periods for different scenarios\nfor i in range(S):\n    cond = False  # Flag for turning point condition\n    t = 1  # Initialize time index (Python uses 0-based indexing)\n\n    # Run the model as long as Q periods haven't been reached and employment in sector 1 is positive\n    while t &lt; Q and L1[i, t-1] &gt; 0:\n        for _ in range(1000):  # Iterations loop\n            # Model equations for output sector 1 and wages sector 2\n            if not cond and L1[i, t-1] &gt; lambda_:\n                Y1[i, t] = lambda_**alpha\n                w2[i, t] = w1[i, t] * (1 + rho)\n            else:\n                Y1[i, t] = L1[i, t]**alpha\n                w2[i, t] = gamma[i, t] * L2[i, t]\n                cond = True  # Set flag once condition is violated\n\n            # Employment sector 1\n            L1[i, t] = L - L2[i, t]\n\n            # Output sector 2\n            Y2[i, t] = (L2[i, t]**beta) * (K[i, t]**(1 - beta))\n\n            # MPL sector 2\n            MPL2[i, t] = beta * (Y2[i, t] / L2[i, t])\n\n            # Employment sector 2\n            L2[i, t] = L2[i, t-1] + delta * (MPL2[i, t-1] - w2[i, t-1])\n\n            # Profits sector 2\n            P2[i, t] = Y2[i, t] - w2[i, t] * L2[i, t]\n\n            # Capital accumulation sector 2\n            K[i, t] = K[i, t-1] + P2[i, t-1]\n\n        # Record turning point\n        if L1[i, t] &gt; lambda_:\n            tp[i] = t\n\n        # Record when L1 becomes non-positive\n        if L1[i, t] &lt;= 0:\n            end[i] = t\n\n        # Update time index\n        t += 1\n\n# Calculate profits in sector 1\nP1 = Y1 - w1 * L1\n\n# Calculate aggregate profit share\nPS = (P1 + P2) / (Y1 + Y2)\n\n# Calculate sectoral profit shares\nPS1 = P1 / Y1\nPS2 = P2 / Y2\n\n\n\n\nPlots\nFigure 16.1 - Figure 16.3 display the model’s dynamics under the baseline scenario. The red vertical line marks the ‘Lewis turning point’, which is the period in which the surplus labour in the traditional sector is depleted \\((L_{1t}&lt;\\lambda)\\). It can be seen that before the Lewis turning point is reached, output in the modern sector grows exponentially thanks to the availability of cheap surplus labour whose employment comes with rising profits. After the turning point, output continues to increase but at a lower rate. This is because as the surplus labour in the traditional sector is depleted, the modern sector faces an upward-sloping labour supply curve. As a result, real wages increase and profits are reduced. This slows down capital accumulation and growth. In the traditional sector, output falls after the turning point as the sector now faces diminishing marginal return to labour.\n\n# Set start and end periods for plots\nTmax=50\nTmin=2\n\n#Output in the two sectors, baseline\nplot(Y1[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y\", ylim=range(Y1[1, Tmin:Tmax],Y2[1, Tmin:Tmax])) \ntitle(main=\"Output in traditional (Y1) and modern (Y2) sector\", xlab = 'Time',cex=0.8 ,line=2)\nlines(Y2[1, Tmin:Tmax],lty=2)\nabline(v = tp[1], col = \"darkred\")\nlegend(\"topleft\", legend=c(expression(Y[1]), expression(Y[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.1: Output in traditional (Y1) and modern (Y2) sector\n\n\n\n\n\n#Employment in the two sectors, baseline\nplot(L1[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"L\", ylim=range(L1[1, Tmin:Tmax],L2[1, Tmin:Tmax])) \ntitle(main=\"Employment in traditional (L1) and modern (L2) sector\", xlab = 'Time',cex=0.8 ,line=2)\nlines(L2[1, Tmin:Tmax],lty=2)\nabline(v = tp[1], col = \"darkred\")\nlegend(\"right\", legend=c(expression(L[1]), expression(L[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.2: Employment in traditional (L1) and modern (L2) sector\n\n\n\n\n\n#Profits and capital accumulation in manufacturing, baseline\nplot(P2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"\", ylim=range(P2[1, Tmin:Tmax])) \ntitle(main=\"Capital accumulation and profits in modern sector\", ylab = expression(P[2]), xlab = 'Time', cex=0.8, line=2)\nabline(v = tp[1], col = \"darkred\")\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(K[1, Tmin:Tmax]),cex.axis=1,cex.lab=0.75)\naxis(side = 4, at = pretty(range(K[1, Tmin:Tmax])))  \nmtext(expression(K[2]), side = 4, line = 2)\nlegend(\"bottomright\", legend=c(expression(P[2]), expression(K[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.3: Capital accumulation and profits in modern sector\n\n\n\n\nFigure 16.4 and Figure 16.5 illustrate the distributional implications of the model. Before the Lewis turning point, the profit share of the modern sector increases, as firms benefit from a real wage that is fixed below the marginal product of labour. After the turning point, real wages jump upwards and begin to increase further, gradually closing the gap with the marginal product. As a result, the profit share falls and embarks on a downward convergence to the level implied by the marginal product of labour.1 The aggregate profit share broadly displays an inverted U-shaped pattern.\n\n# Real wage and profit share in manufacturing\nplot(PS2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"\", xlim=range(Tmin:Tmax), ylim=range(PS2[1, Tmin:Tmax])) \ntitle(main=\"Profit share and real wage in modern sector\",ylab = expression(pi[2]), xlab = 'Time', cex=0.8, line=2)\nabline(v = tp[1], col = \"darkred\")\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(w2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE, xlim=range(0:Tmax),\n     xlab = '', ylim = range(w2[1, Tmin:Tmax]), cex.axis=1,cex.lab=0.75)\naxis(side = 4, at = pretty(range(w2[1, Tmin:Tmax])))  \nmtext(expression(w[2]), side = 4, line = 2)\nlegend(\"topleft\", legend=c(expression(pi[2]), expression(w[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.4: Real wage and profit share in modern sector\n\n\n\n\n\n# Aggregate profit share\nplot(PS[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=expression(pi), xlim=range(Tmin:Tmax), ylim=range(PS[1, Tmin:Tmax])) \ntitle(main=\"Aggregate profit share\",ylab = '', xlab = 'Time', cex=0.8, line=2)\nabline(v = tp[1], col = \"darkred\")\n\n\n\n\n\n\nFigure 16.5: Aggregate profit share\n\n\n\n\nFigure 17.2 compares output dynamics in the modern sector for the baseline scenario with scenario 2 in which the subsistence wage \\(w^s\\) is fixed at a lower level and with scenario 3 in which the labour supply elasticity \\(\\gamma\\) the modern sector faces after the turning point is higher. It can be seen that for a lower subsistence wage, the modern sector grows faster and the Lewis turning point is reached earlier. For a higher labour supply elasticity, the labour supply curve after the turning point is steeper, which leads to a faster increase in the real wage, a stronger squeeze of profits, and thus slower output growth. These results illustrate the Classical nature of the model, whereby capital accumulation is driven by profits. Thus, any reduction in profits slows down the growth process.\n\nTmax=60\nplot(Y2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlim=range(Tmin:Tmax), xlab=\"\", ylab=expression(Y[2]), ylim=range(Y2[1, Tmin:Tmax],Y2[2, Tmin:Tmax])) \ntitle(main=\"Output in  modern sector\", xlab = 'Time',cex=0.8 ,line=2)\nlines(Y2[2, Tmin:Tmax],lty=2)\nlines(Y2[3, Tmin:Tmax],lty=3)\nabline(v = tp[1], col = \"darkred\")\nabline(v = tp[2], col = \"red\")\nlegend(\"bottomright\", legend=c(\"1: baseline\", \"2: lower subsistence wage\", \"3: higher labour supply elasticity\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.6: Output in modern sector under different scenarios\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Plots (here only for output)\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots (set as integers)\nTmax = int(end[0] -2)\nTmin = int(2)\n\n# Output in the two sectors, baseline\nplt.plot(range(Tmin, Tmax + 1), Y1[0, Tmin:Tmax + 1], 'k-', linewidth=2, label='Y1')\nplt.plot(range(Tmin, Tmax + 1), Y2[0, Tmin:Tmax + 1], 'k--', linewidth=2, label='Y2')\n\n# Highlight Lewis turning point\nplt.axvline(x=tp[0], color='darkred', linestyle='-')\n\n# Set plot labels and title\nplt.title('Output in traditional (Y1) and modern (Y2) sector')\nplt.xlabel('Time')\nplt.ylabel('Y')\nplt.ylim(min(Y1[0, Tmin:Tmax]), max(Y2[0, Tmin:Tmax]))\n\n# Add legend\nplt.legend(loc='upper left')\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#directed-graph",
    "href": "a_Lewis_model.html#directed-graph",
    "title": "16  A Lewis Model of Economic Development",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 9 variables: \n\n#              Y1,Y2,L1,L2,w1,w2,P2,K, MPL2\nM_mat=matrix(c(0, 0, 1, 0, 0, 0, 0, 0, 0,\n               0, 0, 0, 1, 0, 0, 0, 1, 0,\n               0, 0, 0, 1, 0, 0, 0, 0, 0, \n               0, 0, 0, 0, 0, 1, 0, 0, 1, \n               0, 0, 0, 0, 0, 0, 0, 0, 0,\n               0, 0, 0, 0, 1, 0, 0, 0, 0,\n               0, 1, 0, 1, 0, 1, 0, 0, 0,\n               0, 0, 0, 0, 0, 0, 1, 0, 0,\n               0, 1, 0, 1, 0, 0, 0, 0, 0), 9, 9, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(expression(Y[1]), expression(Y[2]), expression(L[1]), expression(L[2]), \n             expression(w[1]), expression(w[2]), expression(P[2]), \"K\", \"MPL\")\n\n# Plot directed graph\nplot(dg, main=\"Directed Graph of Lewis Model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create directed graph\nimport networkx as nx\n\n# Create the adjacency matrix (M_mat in R)\nM_mat = np.array([[0, 0, 1, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 1, 0, 0, 0, 1, 0],\n                  [0, 0, 0, 1, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 1, 0, 0, 1],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 1, 0, 0, 0, 0],\n                  [0, 1, 0, 1, 0, 1, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 1, 0, 0],\n                  [0, 1, 0, 1, 0, 0, 0, 0, 0]])\n\n# Transpose the matrix to get A_mat\nA_mat = M_mat.transpose()\n\n# Create a directed graph from the adjacency matrix using networkx\nG = nx.DiGraph(A_mat)\n\n# Define the node labels as expressions for plotting\nnodelabs  = {0: r'$Y_1$', 1: r'$Y_2$', 2: r'$L_1$', 3: r'$L_2$', \n          4: r'$w_1$', 5: r'$w_2$', 6: r'$P_2$', 7: 'K', 8: 'MPL'}\n\n# Plot the graph\npos = nx.spring_layout(G, k=0.4)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Directed Graph of Lewis Model\")\nplt.show()\n\n\n\n\nThe directed graph illustrates that the subsistence wage in the traditional sector \\(w_1=w^s\\) is the key exogenous variables that impact the dynamics of growth and distribution via its effect on real wages in the modern sector. Employment, output, profits, and capital accumulation in the modern sector form a closed loop (or cycle) within the system. The traditional sector plays a residual role.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#analytical-discussion",
    "href": "a_Lewis_model.html#analytical-discussion",
    "title": "16  A Lewis Model of Economic Development",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nLet us analyse the dynamic stability of the model before the Lewis turning point, i.e. for the case where \\((L_{1t}&gt;\\lambda)\\) such that \\(w_2\\) is exogenous. Combining Equation 16.7 and Equation 16.6 yields a first-order difference equation for \\(L_2\\), and combining Equation 16.9, Equation 16.8, and Equation 16.7, yields a first-order difference equation for \\(K_2\\):\n\\[\nL_{2t}= L_{2t-1} + \\delta(\\beta L_{2t-1}^{\\beta -1}K_{2t-1}^{1-\\beta} - w_{2})\n\\] \\[\nK_{2t}=K_{2t-1} + L_{2t-1}^\\beta K_{2t-1}^{1-\\beta} - wL_{2t-1}\n\\] The Jacobian matrix is given by:\n\\[\nJ(L_2, K_2)=\\begin{bmatrix} 1+ \\delta\\beta (\\beta-1) L_{2t-1}^{\\beta-2} K_{2t-1}^{1-\\beta}   &\\delta\\beta (1-\\beta) L_{2t-1}^{\\beta-1} K_{2t-1}^{-\\beta} \\\\ \\beta L_{2t-1}^{\\beta-1} K_{2t-1}^{1-\\beta} -w & 1+ (1-\\beta) L_{2t-1}^{\\beta} K_{2t-1}^{-\\beta} \\end{bmatrix}.\n\\]\nFor the system to be stable, both eigenvalues of the Jacobian need to be inside the unit circle. This requires the following three conditions to hold:\n\\[\n1+tr(J)+det(J)&gt;0\n\\] \\[\n1-tr(J)+det(J)&gt;0\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nWith \\(tr(J)\\) clearly positive, let us focus on \\(1-tr(J)+det(J)&gt;0\\). Plugging in \\(tr(J)\\) and \\(det(J)\\) and simplifying yields:\n\\[\nw_2 - \\frac{Y_{2t-1}}{L_{2t-1}}&gt;0.\n\\] As long as the real wage is below the average product of labour, \\(\\frac{Y_{2}}{L_{2}}\\), the condition will be violated, as there are positive profits and thus capital accumulation. With the real wage being lower or equal to the marginal product of labour, this is indeed the case. The system is then dynamically unstable and will generate exponential growth.\nWe can check this stability analysis numerically:\n\n### Examine stability before the turning point (here for the baseline scenario only)\n\n# Construct Jacobian matrix before the turning point \nJ=matrix(c(1 + delta*beta*(beta-1)*(L2[1,tp[1]-1]^(beta-2))*(K[1,tp[1]-1]^(1-beta)), \n           delta*beta*(1-beta)*(L2[1,tp[1]-1]^(beta-1))*(K[1,tp[1]-1]^(-beta)),\n           beta*(L2[1,tp[1]-1]^(beta-1))*(K[1,tp[1]-1]^(1-beta)) - w2[1,tp[1]-1],\n           1 + (1-beta)*(L2[1,tp[1]-1]^(beta))*(K[1,tp[1]-1]^(-beta))), \n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values = ev$values)\n\n[1] 1.0552484 0.9580697\n\n# Obtain determinant and trace\n(det=det(J))      # determinant\n\n[1] 1.011002\n\n(tr=sum(diag(J))) # trace\n\n[1] 2.013318\n\n#Check stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] FALSE\n\nprint(1-det&gt;0)\n\n[1] FALSE\n\n# Check simplified stability condition\nprint(w2[1,(tp[1]-1)] - Y2[1,(tp[1]-1)]/L2[1,(tp[1]-1)] &gt;0)\n\n[1] FALSE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Examine stability before the turning point (here for the baseline scenario only)\n\n# Set turning point as integer\ntp = tp.astype(int)  \n\n# Construct Jacobian matrix before the turning point \nJ = np.array([\n    [1 + delta * beta * (beta - 1) * (L2[0, tp[0]-1] ** (beta - 2)) * (K[0, tp[0]-1] ** (1 - beta)),\n     delta * beta * (1 - beta) * (L2[0, tp[0]-1] ** (beta - 1)) * (K[0, tp[0]-1] ** (-beta))],\n    [beta * (L2[0, tp[0]-1] ** (beta - 1)) * (K[0, tp[0]-1] ** (1 - beta)) - w2[0, tp[0]-1],\n     1 + (1 - beta) * (L2[0, tp[0]-1] ** beta) * (K[0, tp[0]-1] ** (-beta))]\n])\n\n# Obtain eigenvalues\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\n\n# Check general stability conditions\nprint(1+tr+det&gt;0)\nprint(1-tr+det&gt;0)\nprint(1-det&gt;0)\n\n# Check simplified stability condition\nprint(w2[0, tp[0]-1] - Y2[0, tp[0]-1] / L2[0, tp[0]-1] &gt; 0)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#references",
    "href": "a_Lewis_model.html#references",
    "title": "16  A Lewis Model of Economic Development",
    "section": "References",
    "text": "References\n\n\n\n\nLewis, W. A. 1954. “Economic Development with Unlimited Supplies of Labour.” The Manchester School 22 (2): 139–91. https://doi.org/10.1111/j.1467-9957.1954.tb00021.x.\n\n\nTodaro, Michael P., and Stephen C. Smith. 2015. Economic Development, 12th Edition. Pearson.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#footnotes",
    "href": "a_Lewis_model.html#footnotes",
    "title": "16  A Lewis Model of Economic Development",
    "section": "",
    "text": "In equilibrium, where \\(L_{2t} - L_{2t-1} =0\\), the real wage \\(w_2\\) will be equal to the MPL in sector 2. The profit share is then constant and given by \\(\\frac{P{_2}}{Y{_2}} = 1-\\beta\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html",
    "href": "a_Hicks_model.html",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "",
    "text": "Overview\nThis model captures some key features of John R. Hicks (1950)’ nonlinear model of business cycle fluctuations. The model builds on Samuelson (1939)’s linear multiplier-accelerator model analysed in Chapter 2 and Chapter 9, but gives it a different twist. While Samuelson (1939)’s business cycle model requires repeated external shocks to produce sustained cycles, Hicks (1950)’s model produces permanent, shock-independent fluctuations that are bounded by a floor and a ceiling. The goods market equilibrium is assumed to be locally unstable due to a strong accelerator effect, i.e. investment reacts strongly to increases in aggregate output, which creates more output and boosts investment even further. However, aggregate output is constrained by a ceiling that may stem from full employment (and a fixed labour supply). On the downward trajectory, output is constrained by a floor that is given by a minimum amount of investment needed to replace the depreciated capital stock.\nWe present a version of the model that is adapted from Gabisch and Lorenz (1989), chapter 2.1.1",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#the-model",
    "href": "a_Hicks_model.html#the-model",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "The Model",
    "text": "The Model\n\\[\n  Y_{t}=\\min[C_t + I_t, Y^C]\n\\tag{17.1}\\]\n\\[\nC_{t} = c_0 + c_1 Y_{t-1},  \\quad c_1 \\in (0,1)\n\\tag{17.2}\\]\n\\[\nI_{t} = I_0 + \\max[\\beta(Y_{t-1} - Y_{t-2}), -D],  \\quad \\beta &gt; 1, D &gt;0\n\\tag{17.3}\\]\nwhere \\(Y_t\\), \\(C_t\\), \\(I_t\\), \\(Y^C\\), and \\(D\\), represent output, consumption, investment, the (full employment) output ceiling, and depreciation, respectively.\nEquation 17.1 specifies aggregate income. For values below the ceiling \\(Y^C\\), aggregate income is determined by aggregate demand (consisting only of consumption and net investment). As soon as aggregate demand hits the ceiling, aggregate income is given by the ceiling. Equation 17.2 is a simple linear Keynesian consumption function. Equation 17.3 is the investment function. For investment levels above depreciation \\(D\\), net investment is given by an autonomous component \\(I_0\\) and an accelerator component that is responsive to the change in aggregate income.2 The reaction coefficient \\(\\beta\\) is assumed to be sufficiently large to generate explosive dynamics. Once the change in aggregate income has fallen below the negative of the level of depreciation \\(D\\), net investment is given by the floor \\(I_0 - D\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#simulation",
    "href": "a_Hicks_model.html#simulation",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (scenario 1), we consider a fall in the output ceiling \\(Y^C\\) in scenario 2, an increase in the investment floor \\(I_0 - D\\) in scenario 3, and finally a decrease in the accelerator coefficient \\(\\beta\\) (scenario 4).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(c_0\\)\n\\(c_1\\)\n\\(I_0\\)\n\\(\\beta\\)\n\\(Y^C\\)\n\\(D\\)\n\n\n\n1: baseline\n0\n0.75\n10\n1.25\n80\n10\n\n\n2: fall in output ceiling (\\(Y^C\\))\n0\n0.75\n10\n1.25\n100\n10\n\n\n3: increase in investment floor (\\(I_0 - D\\))\n0\n0.75\n10\n1.25\n80\n1\n\n\n4: decrease in accelerator coefficient (\\(\\beta\\))\n0\n0.75\n10\n0.8\n80\n10\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=200\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=50\n\n# Create (S x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=S,ncol=Q) # Income/output\nC=matrix(data=1,nrow=S,ncol=Q) # Consumption\nI=matrix(data=1,nrow=S,ncol=Q) # Investment\n\n# Set fixed parameter values\nc0=0\nc1=0.75\nI0=10\n\n# Set baseline parameter values\nYc=matrix(data=80,nrow=S,ncol=Q)      # output ceiling\nD=matrix(data=10,nrow=S,ncol=Q)       # investment floor (depreciation)\nbeta=matrix(data=1.25,nrow=S,ncol=Q)  # accelerator coefficient\n\n# Set parameter values for different scenarios\nYc[2,s:Q]=100 # scenario 2: increase in output ceiling\nD[3,s:Q]=1    # scenario 3: increase in investment floor\nbeta[4,s:Q]=0.8 # scenario 4: reduction in accelerator coefficient\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:500){ # run the model 500-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = min(C[i,t]+I[i,t], Yc[i,t])\n    \n    #(2) Consumption\n    C[i,t] = c0 + c1*Y[i,t-1]\n    \n    #(3) Investment\n    I[i,t] = I0 + max(beta[i,t]*(Y[i,t-1] - Y[i,t-2]), -D[i,t]) \n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 200\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 50\n\n# Create (S x Q)-arrays that will contain the simulated data\nY = np.ones((S, Q))  # Income/output\nC = np.ones((S, Q))  # Consumption\nI = np.ones((S, Q))  # Investment\n\n# Set fixed parameter values\nc0 = 0\nc1 = 0.75\nI0 = 10\n\n# Set baseline parameter values\nYc = np.full((S, Q), 80)      # output ceiling\nD = np.full((S, Q), 10)       # investment floor (depreciation)\nbeta = np.full((S, Q), 1.25)  # accelerator coefficient\n\n# Set parameter values for different scenarios\nYc[1, s:Q] = 100     # scenario 2: increase in output ceiling\nD[2, s:Q] = 1        # scenario 3: increase in investment floor\nbeta[3, s:Q] = 0.8   # scenario 4: reduction in accelerator coefficient\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    \n    for t in range(1, Q):\n        \n        for iterations in range(500):  # run the model 500-times in each period\n            \n            # Model equations\n            \n            # (1) Output\n            Y[i, t] = min(C[i, t] + I[i, t], Yc[i, t])\n            \n            # (2) Consumption\n            C[i, t] = c0 + c1 * Y[i, t - 1]\n            \n            # (3) Investment\n            I[i, t] = I0 + max(beta[i, t] * (Y[i, t - 1] - Y[i, t - 2]), -D[i, t])\n            \n        # Close iterations loop\n    # Close time loop\n# Close scenario loop\n\n\n\n\nPlots\nFigure 17.1 displays the model’s dynamics under the baseline scenario. The model generates cycles in aggregate output, consumption and investment that are constrained by the output ceiling \\(Y^C=80\\) and the investment floor \\(I_0-D=0\\). These cycles are permanent, i.e. they don’t require any external shocks, and they are (roughly) periodic, with a cycle length from peak (trough) to peak (trough) of around 13.5 periods. What generates the turning points? Suppose income is on an increasing trajectory. The accelerator effect on investment will amplify this process as firms will increase their investment, which raises aggregate demand and increases income further. When the output ceiling is reached, the change in income becomes zero, and investment demand decreases relative to the boom phase. This decrease in investment lowers aggregate output, and the accelerator effect again amplifies this tendency that now plays out on a downward trajectory until net investment hits the lower bound. Once investment has stopped its downward trajectory, aggregate income stops falling as well, which allows the accelerator effect to turn positive again and thereby induce a new cycle.\n\n# Set start and end periods for plots\nTmax=100\nTmin =10\n\n#Income, consumption, and investment\nplot(Y[1, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[1, Tmin:Tmax],Y[1, Tmin:(Tmax)]))\ntitle(main=\"Income, consumption, and investment (baseline)\", xlab = 'Time',cex=0.8,line=2)\nlines(C[1, Tmin:Tmax],lty=2)\nlines(I[1, Tmin:Tmax],lty=3)\nlegend(\"topleft\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.1: Income, consumption, and investment (baseline)\n\n\n\n\nIn Figure 17.2, the output ceiling rises to \\(Y^C = 100\\) in \\(t=50\\). This raises the amplitude of the cycles. Interestingly, the ceiling is no longer binding, but the cycles still do not explode. This illustrates a feature of the model that has been noted before: it actually does not need a ceiling to generate bounded cycles (see, e.g., Puu, Gardini, and Sushko (2005)). The acceleration of income during a boom will become smaller and smaller, and eventually turn negative, thereby lowering investment and inducing a switch from boom to bust. Hence, cycles (and thus turning points) will occur even without floor and ceilings, but to prevent these cycles to become larger and larger, a floor is sufficient.\n\n# Scenario 2: increase in ceiling\nplot(Y[2, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[2, Tmin:Tmax],Y[2, Tmin:(Tmax)]))\ntitle(main=\"Scenario 2: Increase in output ceiling\", xlab = 'Time',cex=0.8,line=2)\nlines(C[2, Tmin:Tmax],lty=2)\nlines(I[2, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.2: Increase in output ceiling\n\n\n\n\nAn increase in the investment floor to \\(I_0 - D = 9\\) in period \\(t=50\\), displayed in Figure 17.3, has the effect of reducing the amplitude of the fluctuations. Intuitively, the milder the bust, the milder the recovery.\n\n# Scenario 3: increase in investment floor\nplot(Y[3, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[3, Tmin:Tmax],Y[3, Tmin:(Tmax)]))\ntitle(main=\"Scenario 3: Increase in investment floor\", xlab = 'Time',cex=0.8,line=2)\nlines(C[3, Tmin:Tmax],lty=2)\nlines(I[3, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.3: Increase in investment floor\n\n\n\n\nFinally, Figure 17.4 displays the scenario where the accelerator coefficient \\(\\beta\\) falls, rendering investment much less sensitive to changes in aggregate income. As a result, the model’s regular cycles turn into damped oscillations that eventually converge to a stable equilibrium.\n\n# Scenario 4: Reduction in accelerator coefficient\nplot(Y[4, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[4, Tmin:Tmax],Y[4, Tmin:(Tmax)]))\ntitle(main=\"Scenario 4: Reduction in accelerator coefficient\", xlab = 'Time',cex=0.8,line=2)\nlines(C[4, Tmin:Tmax],lty=2)\nlines(I[4, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.4: Reduction in accelerator coefficient\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Plots (here only for baseline)\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 100\nTmin = 10\n\n# Plot income (Y), consumption (C), and investment (I)\nplt.plot(range(Tmin, Tmax), Y[0, Tmin:Tmax], label='Y', color='black', linewidth=2, linestyle='-')\nplt.title(\"Income, consumption, and investment (baseline)\", fontsize=10)\nplt.xlabel('Time')\nplt.ylabel('Y, C, I')\nplt.plot(range(Tmin, Tmax), C[0, Tmin:Tmax], label='C', linestyle='--', color='black',)\nplt.plot(range(Tmin, Tmax), I[0, Tmin:Tmax], label='I', linestyle=':', color='black',)\n\n# Add a legend to the top-left corner\nplt.legend(loc='upper left', fontsize=8, frameon=False)\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#directed-graph",
    "href": "a_Hicks_model.html#directed-graph",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 5 variables: \n  # endogenous: (1) Y, (2) C, (3) I\n  # exogenous: (4) I0-D, (5) Yc\n\n              #Y C I I0-D Yc\nM_mat=matrix(c(0,1,1, 0,  1, # Y\n               1,0,0, 0,  0, # C\n               1,0,0, 1,  0, # I\n               0,0,0, 0,  0, # I0-D\n               0,0,0, 0,  0),# Yc\n               5, 5, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(I[0]-D), expression(Y^C))\n\n# Plot directed graph matrix\nplot(dg, main=\"Directed graph of Hicks model\", vertex.size=40, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Directed graph\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 5 variables: \n# endogenous: (1) Y, (2) C, (3) I\n# exogenous: (4) I0-D, (5) Yc\n\n# Create the matrix M_mat\nM_mat = np.array([[0, 1, 1, 0, 1],  # Y\n                  [1, 0, 0, 0, 0],  # C\n                  [1, 0, 0, 1, 0],  # I\n                  [0, 0, 0, 0, 0],  # I0-D\n                  [0, 0, 0, 0, 0]]) # Yc\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat = M_mat.T\n\n# Create directed graph from adjacency matrix using networkx\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"Y\", 1: \"C\", 2: \"I\", 3: \"$I_0 - D$\", 4: \"$Y^C$\"}\n\n# Plot directed graph\npos = nx.spring_layout(G, k=0.08)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Directed Graph of Lewis Model\")\nplt.show()\n\n\n\n\nIt can thus be seen that the key exogenous variables in the Hicks (1950) model are the output ceiling \\(Y^C\\) and the investment floor \\(I_0 - D\\), which constrain the endogenous cycle generated by the interaction between the endogenous variables income \\(Y\\), investment \\(I\\), and consumption \\(C\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#analytical-discussion",
    "href": "a_Hicks_model.html#analytical-discussion",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nThe dynamic properties of the Hicks (1950) model when the floor and ceiling are not binding are similar, but not entirely equivalent to the Samuelson (1939) model analysed in Chapter 9.\nFirst, define \\(X_t = Y_{t-1}\\) to re-write the system as:\n\\[\n  X_{t}=\\min[C_{t-1} + I_{t-1}, Y^C]\n\\tag{17.4}\\]\n\\[\nC_{t} = c_0 + c_1 X_{t}\n\\tag{17.5}\\]\n\\[\nI_{t} = I_0 + \\max[\\beta(X_{t} - X_{t-1}), -D].\n\\tag{17.6}\\]\nThen shift Equation 17.5 one period back and substite into Equation 17.4 to obtain:\n\\[\n  X_{t}=\\min [c_0 + c_1 X_{t-1} + I_{t-1}, Y^C].\n\\tag{17.7}\\]\nNext, substitute Equation 17.7 into Equation 17.6:\n\\[\nI_{t} = I_0 + \\max[\\beta( c_0 + (c_1 -1) X_{t-1} + I_{t-1}), -D].\n\\tag{17.8}\\]\nEquation 17.7 and Equation 17.8 are a two-dimensional dynamic system in \\(X_t\\) and \\(It\\).\nFor \\(Y_t &lt; Y^C\\) and \\(I_t &gt; I_0 - D\\), the system’s Jacobian matrix is given by:\n\\[\nJ=\\begin{bmatrix} c_1 & 1 \\\\ \\beta(c_1-1) & \\beta  \\end{bmatrix}.\n\\]\nThe characteristic polynomial yielding the eigenvalues of the Jacobian is:\n\\[\\lambda^2-\\lambda(c_1+\\beta)+\\beta=0,\\]\nwhere \\(c_1+\\beta =tr(J)\\) and \\(\\beta = det(J)\\).\nThus, we have:\n\\[\n\\lambda_{1,2} = \\frac{(c_1+\\beta) \\pm \\sqrt{(c_1+\\beta)^2-4\\beta}}{2},\n\\]\nand two eigenvalues will be a pair of complex conjugates if \\((c_1+\\beta)^2-4\\beta &lt;0\\) or \\(\\left( \\frac{c_1+\\beta}{2} \\right)^2 &lt; \\beta\\).\nTo assess stability, we need to check whether the modulus of the complex eigenvalue \\(R\\) is inside the unit circle, i.e. \\(R \\in (-1,1)\\). For a two-dimensional system with complex eigenvalues, we have \\(R=\\sqrt{det(J)}\\). Thus, the stability condition for the Hicks model is \\(\\beta &lt;1\\).\nThe following code generates a plot that displays the condition for cycles, \\(\\left( \\frac{c_1+\\beta}{2} \\right)^2 &lt; \\beta\\), and the stability condition, \\(\\beta &lt;1\\), in the \\((\\beta, c_1)\\)-space:3\n\n# Create function for cycle condition using beta as argument\ncyc= function (beta) {\n  2*sqrt(beta)-beta\n}\n\n# Plot the two conditions in (beta, c1)-space\ncurve(cyc, from = 0, to = 4.5, col = 1, xlab=expression(beta), ylab=expression(c[1]) , main=\"\",\n      lwd=1.5, n=10000, ylim=range(0,1.5))\nabline(v=1, col=2)\nlegend(\"topright\", legend = c(\"cycle condition\", \"stability condition\"), \n       col = c(1, 2), lwd = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create function for cycle condition using beta as an argument\ndef cyc(beta):\n    return 2 * np.sqrt(beta) - beta\n\n# Define the range for beta \nbeta_values = np.linspace(0, 4.5, 10000)\n\n# Compute the corresponding c1 values using the cyc function\nc1_values = cyc(beta_values)\n\n# Plot the cycle condition in (beta, c1)-space\nplt.plot(beta_values, c1_values, color='black', linewidth=1.5, label='cycle condition')\n\n# Plot the stability condition as a vertical line at beta = 1\nplt.axvline(x=1, color='red', linewidth=2, label='stability condition')\n\n# Set labels and title\nplt.xlabel(r'$\\beta$', fontsize=12)\nplt.ylabel(r'$c_1$', fontsize=12)\nplt.title('')\n\n# Set y-axis limit \nplt.ylim(0, 1.5)\n\n# Add legend\nplt.legend(loc='upper right')\n\n# Show the plot\nplt.show()\n\n\n\n\nThe Hicks model requires combinations of \\(c_1\\) and \\(\\beta\\) below the cycle condition and to the right of the stability condition to yield cycles that would be explosive without the floor.\nWe can also compute the eigenvalues and check the general stability conditions numerically.\n\n### Stability analysis\n## Baseline\n\n# Construct Jacobian matrix \nJ_base=matrix(c(c1, 1,\n           beta[1,1]*(c1-1), beta[1,1]),\n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_base=eigen(J_base)\n(evals_base = ev_base$values)\n\n[1] 1+0.5i 1-0.5i\n\n# Obtain determinant and trace\n(det=det(J_base))      # determinant\n\n[1] 1.25\n\ntr=sum(diag(J_base)) # trace\n\n# Calculate modulus\n(mod_base=Mod(evals_base[1]))\n\n[1] 1.118034\n\n#Check general stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] FALSE\n\n# Check analytical stability condition\nbeta[1,1] &lt; 1\n\n[1] FALSE\n\n## Compare with scenario 4\nJ_scen4=matrix(c(c1, 1,\n           beta[4,s]*(c1-1), beta[4,s]),\n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_scen4=eigen(J_scen4)\n(evals_scen4 = ev_scen4$values)\n\n[1] 0.775+0.4465143i 0.775-0.4465143i\n\n# Obtain determinant and trace\n(det=det(J_scen4))      # determinant\n\n[1] 0.8\n\ntr=sum(diag(J_scen4)) # trace\n\n# Calculate modulus\n(mod_scen4=Mod(evals_scen4[1]))\n\n[1] 0.8944272\n\n#Check general stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n# Check analytical stability condition\nbeta[4,s] &lt; 1\n\n[1] TRUE\n\n\nFor the baseline, the modulus of the complex eigenvalue is indeed larger than unity and the system thus unstable. This is due to the accelerator coefficient \\(\\beta\\) being larger than unity. By contrast, in scenario 4, we have \\(\\beta &lt; 1\\) and the system is thus stable.\n\n### Check cycle condition and compute cycle length (baseline)\n\n# Check analytical cycle condition\n(c1+beta[1,1])^2 - 4*beta[1,1] &lt; 0\n\n[1] TRUE\n\n# Save real and imaginary part of complex eigenvalue\nre=Re(evals_base[1])\nim=Im(evals_base[1])\n\n# Calculate cycle length\nL=(2*pi)/(acos(re/mod_base))\nL\n\n[1] 13.55164\n\n\nThe analytical cycle condition confirms that the eigenvalues of the system will be complex and thus generate cycles. The implied cycle length is around 13.5 periods.\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Stability Analysis - Baseline\n# Construct the Jacobian matrix for the baseline scenario\nJ_base = np.array([[c1, 1],\n                   [beta[0, 0] * (c1 - 1), beta[0, 0]]])\n\n# Obtain eigenvalues\nevals_base, _ = np.linalg.eig(J_base)\nprint(\"Eigenvalues (Baseline):\", evals_base)\n\n# Obtain determinant and trace\ndet_base = np.linalg.det(J_base)  # determinant\ntr_base = np.trace(J_base)  # trace\n\n# Calculate modulus of the first eigenvalue\nmod_base = np.abs(evals_base[0])\nprint(\"Modulus (Baseline):\", mod_base)\n\n# Check general stability conditions\nprint(\"Stability conditions (Baseline):\")\nprint(1 + tr_base + det_base &gt; 0)\nprint(1 - tr_base + det_base &gt; 0)\nprint(1 - det_base &gt; 0)\n\n# Check analytical stability condition\nprint(\"Analytical stability condition (Baseline):\", beta[0, 0] &lt; 1)\n\n\n### Compare with Scenario 4\n# Construct the Jacobian matrix for scenario 4\nJ_scen4 = np.array([[c1, 1],\n                    [beta[3, s] * (c1 - 1), beta[3, s]]])\n\n# Obtain eigenvalues\nevals_scen4, _ = np.linalg.eig(J_scen4)\n\n# Print eigenvalues\nprint(\"Eigenvalues (Scenario 4):\", evals_scen4)\n\n# Obtain determinant and trace\ndet_scen4 = np.linalg.det(J_scen4)  # determinant\ntr_scen4 = np.trace(J_scen4)  # trace\n\n# Calculate modulus of the first eigenvalue\nmod_scen4 = np.abs(evals_scen4[0])\nprint(\"Modulus (Scenario 4):\", mod_scen4)\n\n# Check general stability conditions\nprint(\"Stability conditions (Scenario 4):\")\nprint(1 + tr_scen4 + det_scen4 &gt; 0)\nprint(1 - tr_scen4 + det_scen4 &gt; 0)\nprint(1 - det_scen4 &gt; 0)\n\n# Check analytical stability condition\nprint(\"Analytical stability condition (Scenario 4):\", beta[3, s] &lt; 1)\n\n### Check cycle condition (baseline)\ncycle_condition = (c1 + beta[0, 0])**2 - 4 * beta[0, 0] &lt; 0\nprint(\"Cycle condition (Baseline):\", cycle_condition)\n\n# Save real and imaginary parts of the complex eigenvalue\nre = np.real(evals_base[0])\nim = np.imag(evals_base[0])\n\n# Calculate cycle length (L)\nL = (2 * np.pi) / np.arccos(re / mod_base)\nprint(\"Cycle length (Baseline):\", L)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#references",
    "href": "a_Hicks_model.html#references",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "References",
    "text": "References\n\n\n\n\nGabisch, Günter, and Hans-Walter Lorenz. 1989. Business Cycle Theory. A Survey of Methods and Concepts, 2nd Edition. Springer-Verlag.\n\n\nHicks, John R. 1950. A Contribution to the Theory of the Trade Cycle. Clarendon Press.\n\n\nHommes, Cars H. 1995. “A reconsideration of Hicks’ non-linear trade cycle model.” Structural Change and Economic Dynamics 6 (4): 435–95. https://doi.org/10.1016/0954-349X(95)00032-I.\n\n\nPuu, Tönu, Laura Gardini, and Irina Sushko. 2005. “A Hicksian Multiplier-Accelerator Model with Floor Determined by Capital Stock.” Journal of Economic Behavior & Organization 56 (3): 331–48. https://doi.org/10.1016/j.jebo.2003.10.008.\n\n\nSamuelson, Paul A. 1939. “Interactions between the Multiplier Analysis and the Principle of Acceleration.” The Review of Economics and Statistics 21 (2): 75–78. https://doi.org/10.2307/1927758.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#footnotes",
    "href": "a_Hicks_model.html#footnotes",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "",
    "text": "Following Hommes (1995), we consider a stationary version of the model that abstracts from the growth path assumed in Hicks (1950).↩︎\n This differs from Samuelson (1939), who assumed that investment reacts to changes in consumption, see Chapter 2.↩︎\nTo create the function for the cycle condition, we set \\(\\left( \\frac{c_1+\\beta}{2} \\right)^2 = \\beta\\) and solve for \\(c_1\\), where we only consider positive values for \\(c_1\\) and \\(\\beta\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "additional_resources.html",
    "href": "additional_resources.html",
    "title": "Additional Online Resources",
    "section": "",
    "text": "Economic Modelling in General",
    "crumbs": [
      "Additional Online Resources"
    ]
  },
  {
    "objectID": "additional_resources.html#economic-modelling-in-general",
    "href": "additional_resources.html#economic-modelling-in-general",
    "title": "Additional Online Resources",
    "section": "",
    "text": "Sayama (2015) is a free introductory textbook for the modelling and simulation of complex systems in Python\nQuantEcon provides online intermediate and advanced resources for economic modelling and data analysis in Python and Julia",
    "crumbs": [
      "Additional Online Resources"
    ]
  },
  {
    "objectID": "additional_resources.html#stock-flow-consistent-modelling",
    "href": "additional_resources.html#stock-flow-consistent-modelling",
    "title": "Additional Online Resources",
    "section": "Stock-Flow Consistent Modelling",
    "text": "Stock-Flow Consistent Modelling\n\nMarco Veronese Passarella’s website provides R codes for most chapters of Monetary Economics: An Integrated Approach to Credit, Money, Income, Production and Wealth by Wynne Godley and Marc Lavoie, and more\nSFC Models provides resources on stock-flow consistent modelling",
    "crumbs": [
      "Additional Online Resources"
    ]
  },
  {
    "objectID": "additional_resources.html#agent-based-modelling",
    "href": "additional_resources.html#agent-based-modelling",
    "title": "Additional Online Resources",
    "section": "Agent-Based Modelling",
    "text": "Agent-Based Modelling\n\nAlessandro Caiani’s website provides R codes for simple agent-based models, including those in the introductory book Economics with Heterogeneous Interacting Agents: A Practical Guide to Agent-Based Modeling by Alessandro Caiani, Alberto Russo, Antonio Palestrini and Mauro Gallegati",
    "crumbs": [
      "Additional Online Resources"
    ]
  },
  {
    "objectID": "additional_resources.html#coding",
    "href": "additional_resources.html#coding",
    "title": "Additional Online Resources",
    "section": "Coding",
    "text": "Coding\n\nCoding for Economists provides a guide for coding in Python",
    "crumbs": [
      "Additional Online Resources"
    ]
  }
]