[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "",
    "text": "Welcome\nThis platform provides an open source code repository and online script for macroeconomic model simulation. It follows a “do-it-yourself” (DIY) approach, empowering users to numerically simulate key macroeconomic models on their own using the open-source programming languages R and Python. Whether you are a university teacher, student, researcher, or an economics enthusiast, our platform offers resources to deepen your understanding of both macroeconomic modelling and coding.\nThe platform covers an array of macroeconomic models, including canonical textbook models, models from different economic paradigms, and seminal models from the history of economic thought. It bridges a gap between intermediate and advanced level macroeconomics by providing detailed yet accessible treatments of seminal macroeconomic models. Most intermediate macroeconomics textbooks focus on graphical analysis, while advanced level materials are often more mathematical and less accessible. Our platform offers a hands-on and approachable resource for users to build both a solid foundation in modelling and macroeconomic intuition.\nThe platform’s DIY-approach aims to foster reproducibility and open-source principles in macroeconomic research and education by providing learning materials that are freely available and modifiable by everyone. The platform’s content will expand over time through new entries added by the project team.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#project-team",
    "href": "index.html#project-team",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "Project team",
    "text": "Project team\n\n\n\n\n\n\n\n\n\nKarsten Kohler\n\n\n\n\n\n\n\nFranz Prante\n\n\n\n\n\n\n\n\n\n\n\nKarsten is an Associate Professor in Economics at Leeds University Business School, where he does research on the interaction between finance and the real economy, especially sources of cyclical dynamics, instability, and rising inequality.\n\n\nFranz is a research associate at Chemnitz University of Technology, where he is currently working on the macroeconomic effects of monetary policy and price effects on energy demand. He holds a PhD from Université Sorbonne Paris Nord.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "Contact",
    "text": "Contact\nWe welcome any feedback. If you encounter any issues, find typos or mistakes, or have questions/thoughts on the content, please do get in touch.\n\nIf you are Github user, you can report an issue in our repository\nYou can also email us directly: k.kohler@leeds.ac.uk",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "License",
    "text": "License\nThe material on this page is licensed under CC BY-NC 4.0, thus feel free to use the material for non-commercial purposes but please give credit.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "DIY Macroeconomic Model Simulation",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe are grateful for helpful comments from Adam Aboobaker, Chandni Dwarkasing, Giuseppe Fontana, Alex Guschanski, Eckhard Hein, Grégoire Noël, and Rafael Wildauer on various sections of this website. All errors are ours.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "how_to_use.html",
    "href": "how_to_use.html",
    "title": "1  Getting Started",
    "section": "",
    "text": "Structure of platform\nThe platform starts off with a general introduction the numerical simulation of economic models (Chapter 2). After that, it jumps right into a series of macroeconomic models. These models are grouped into static and dynamic models. In static models, time plays no role and all variables adjust instantaneously. By contrast, dynamic models characterise the adjustment of variables over time.\nThe model entries are largely self-contained and can be read independently of each other. For each model, the chapters provide three main components:\nTo further facilitate the understanding of dynamic models, Chapter 9 of the section on dynamic models begins with a general introduction into the mathematical analysis of dynamic models (this is mostly relevant for the analytical discussions of dynamic models).\nAll simulation codes are written in the open-source programming languages R and Python. R codes are presented in the main text (and images and results in the text are the output of the shown R codes), while the corresponding Python codes are available by clicking on the callout blocks underneath the R codes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#structure-of-platform",
    "href": "how_to_use.html#structure-of-platform",
    "title": "1  Getting Started",
    "section": "",
    "text": "Model descriptions that concisely explain the key ideas, assumptions, and equations of each model. This helps users grasp the underlying concepts and intuition behind the models.\n\nAnnotated code that allows users to numerically simulate the models, examine their results under different scenarios, and produce visualisations to better understand the models’ structure and output. This hands-on approach enables users to gain practical coding skills while exploring different macroeconomic theories.\n\nAnalytical discussions for users who are interested in delving deeper into the mathematical properties of the models.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#access-to-r-and-python-and-some-online-resources",
    "href": "how_to_use.html#access-to-r-and-python-and-some-online-resources",
    "title": "1  Getting Started",
    "section": "Access to R and Python and some online resources",
    "text": "Access to R and Python and some online resources\nTo be able to manipulate the codes on this platform on your own machine, you first need to download and install R and RStudio. For Python, there are different options. One of them is to download and install Spyder via the Anaconda Python distribution. Spyder provides an interface for Python (like RStudio for R). If you install it via Anaconda, it will install Python automatically.\nBesides being free, a key advantage of both R and Python is their huge and growing functionality due to new user-written libraries and packages continuously being added. In addition, a large amount of learning material is freely available on the web, e.g. here and here for R and here, and here for Python. However, to get started in can be best to directly delve into some of the codes on this platform and learn by doing. To this end, the following “cheatsheets” that provide a concise overview of key functions are useful:\n\nR Studio Cheatsheet\nBase R Cheatsheet\nmore R cheatsheets here\nPython Basics Cheatsheet\nPython for Data Science Cheatsheet\nPython Cheatsheet for NumPy library\n\nOnce you have installed R or Python, you can play with the codes on this platform yourself by copy and pasting them into the script panel of your local interface (IDE) and hitting CTRL + Enter to execute them. Don’t forget to always comment your code using the “#” symbol and to save your scripts to make sure your future self can seamlessness continue working on it.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#introduction-to-r-and-python",
    "href": "how_to_use.html#introduction-to-r-and-python",
    "title": "1  Getting Started",
    "section": "Introduction to R and Python\n",
    "text": "Introduction to R and Python\n\nThe following codes cover some basic operations.1 There are also some simple exercises to work through. Open RStudio or Spyder on your machine to get started.\nSetting your working directory\nA first step is often to set the working directory, which is the folder on your PC where any output you produce will be stored (e.g. simulated data, graphs). To set the working directory, you need to find the path to the folder on your PC where you want to store results:\n\nfinding the path to a folder on your Microsoft PC\nfinding the path to a folder on your Mac\n\nNote that folders in the path to your working directory need to be separated by forward slashes: /\n\n################################### Set working directory ###########################\n# Set the working directory to the desired folder by adjusting the path below:\n# setwd(\"C:/Users/Your Name/Your Folder\")\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Set the working directory to the desired folder by adjusting the path below:\nimport os\n# os.chdir(\"\"C:/Users/Your Name/Your Folder\")  \n\n\n\n\nElementary operations\n\nthe following block of code covers some elementary operations\n\n\n################################### Elementary operations ###########################\n\n#In the R script you write code and comments\n#any line starting with # is a comment and it is NOT executed\n\n#Let's define some variables\ns = 0.05\nY = 10\n\n#We can also assign several variables the same value at once\nC = I = R = 2\n\n#For displaying them we simply call the name of the object and execute the relevant line\nY\nC\n\n#We can define new variables using existing ones\nW = Y - R\nW\n\n#R has a vast amount of built in functions, for example\nmax(10,2,100,-3)\nsqrt(9)\nabs(-13)\n\n#you can find out more about these by using the help function, e.g.:?max()\n\n#How can you delete stuff? Use the remove function rm()\n#for individual objects\nrm(Y)\n#if you want to remove everything\nrm(list=ls(all=TRUE))\n\n#You can also assign text (a string) to a variable\ntext1 = 'Reggaeton'\ntext2 = \"Bad Bunny\"\n#note \"text\" is the same as 'text' and a string can contain spaces\n#You use the paste function to combine strings\npaste(text1, text2)\n\n#R uses standard operators like +, -, *\n#for exponents use ^\n3^2\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n################################### Elementary operations ###########################\n\n#In the Python script you write code and comments\n#any line starting with # is a comment and it is NOT executed\n\n# Most of what we will do relies on the library NumPy\n# Let's load NumPy and call its commands by the prefix .np\n\n# Load relevant libraries\nimport numpy as np \n\n#Let's define some variables\ns = 0.05\nY = 10\n\n#We can also assign several variables the same value at once\nC = I = R = 2\n\n#For displaying them we simply call the name of the object and \n# execute the relevant line\nY\nC\n\n#We can define new variables using existing ones\nW = Y - R\nW\n\n#Python/Numpy has a vast amount of built in functions, for example\nmax(10, 2, 100, -3)\nnp.sqrt(9)\nabs(-13)\n\n#you can find out more about these by using the help function, e.g.:\n# help(max)\n\n#How can you delete stuff? Use the del function\n#for individual objects\ndel Y, C, I, R\n\n#You can also assign text (a string) to a variable\ntext1 = 'Reggaeton'\ntext2 = \"Bad Bunny\"\nprint(text1 + ' ' + text2)\n\n#Python uses standard operators like +, -, *\n#for exponents use **\n3**2\n\n\n\n\nIf-else statements and loops\n\nsometimes we want to make the execution of code conditional on an if condition\n\nthe basic syntax is: if condition = TRUE, then do the following …\nanother key tool are loops that iterate over the lines of code inside the loop for a specified number of times\na for loop allows you to iterate over a range of values and also to specify an index variable that is updated in every iteration of the loop\nfor loops will be extensively used on this website to solve economic models\n\n\n################################### If-else statements and loops ###########################\n# example of an if condition\na = 10\nb = 13\nif (b&gt;a) {\n  print(\"b is bigger\")\n}\n#we can also tell R what to do in case the condition is not fulfilled\nb=10\nif (b&gt;a) {\n  print(\"b is bigger\")\n} else {\n  print(\"b not bigger\")\n}\n\n#example of a for loop\nfor (i in 1:5){\n  print(i)\n}\n\n#Let's use it to solve a simple Keynesian cross model of the form\n#Y=C+I\n#C=c0+c1Y\n# where Y is output, C is consumption, and I is investment\n\n\n#Define exogenous parameters\nc0=2\nc1=0.8\nI=10\n\n#set initial values for two endogenous variable\nY=C=1\n\n#Use a for loop to solve it\nC\nY\nfor (i in 1:100){\n  Y = C+I\n  C = c0+c1*Y\n}\nC\nY\n\n# NB: equilibrium solution of this model is Y*=(I+c0)/(1-c1)\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n########################### if-else statements and loops ######################\n# example of an if condition\na = 10\nb = 13\nif b &gt; a:\n    print(\"b is bigger\")\n    \n#we can also define what to do in case the condition is not fulfilled\nb = 10\nif b &gt; a:\n    print(\"b is bigger\")\nelse:\n    print(\"b not bigger\")\n\n# example of a for loop\nfor i in range(1, 6):\n    print(i)\n# Note the key role played by indentation in Python!\n\n#Let's use it to solve a simple Keynesian cross model of the form\n#Y=C+I\n#C=c0+c1Y\n# where Y is output, C is consumption, and I is investment\n\n#Define exogenous parameters and initialise endogenous variables\nc0 = 2\nc1 = 0.8\nI = 10\nY = C = 1\n\n#Use a for loop that iterates the equations 100 times to solve them\nfor i in range(1, 100):\n    Y = C + I\n    C = c0 + c1 * Y\nC\nY\n# NB: equilibrium solution of this model is Y*=(I+c0)/(1-c1)\n\n\n\n\nExercise 1: loops\nSet the parameter values of the Keynesian cross model to \\(c_0=2\\), \\(c_1=0.8\\), and \\(I=11\\), run the loop and check the equilibrium value \\(Y^*\\). Cross-check your result with the analytical solution for \\(Y^*\\).\n\n\n\n\n\n\nR Solution\n\n\n\n\n\n\n#Define exogenous parameters\nc0=2\nc1=0.8\nI=11\n\n#set initial values for two endogenous variable\nY=C=1\n\n#Use a for loop to solve it\nfor (i in 1:100){\n  Y = C+I\n  C = c0+c1*Y\n}\n\nY\n\n[1] 65\n\n\n\n\n\n\n\n\n\n\n\nPython Solution\n\n\n\n\n\n\n#Define exogenous parameters and initialise endogenous variables\nc0 = 2\nc1 = 0.8\nI = 10\nY = C = 1\n\n#Use a for loop that iterates the equations 100 times to solve them\nfor i in range(1, 100):\n    Y = C + I\n    C = c0 + c1 * Y\n\nY\n\n59.999999984403956\n\n\n\n\n\n\n\n\n\n\n\nMathematical solution\n\n\n\n\n\n\\(Y^*=\\frac{I+c_0}{1-c_1}=\\frac{11+2}{1-0.8}=65\\)\n\n\n\nFunctions\n\nyou can write your own functions that can be called and again for different purposes\na function consists of a fixed block of code that contains terms (the inputs or arguments of the function) whose values need to be supplied when the function is called\nthis allows running the same type of code many times with changes only to the inputs of the function\n\n\n################## Functions ##################################################\n# Let's cast the previous loop that simulates they Keynesian across \n# into a function called \"keynes\"\n\n# the terms inside the brackets are the arguments of the function whose \n# values need to be supplied when the function is called\n\nkeynes=function(c0, c1, I){\n  # Initialise\n  Y=C=1\n\n  # Solve\n  for (i in 1:100){\n    Y = C+I\n    C = c0+c1*Y\n    } # close loop\n \n return(Y) # specify the value that will be return when the function is executed\n\n} # close function\n\n# Execute function for desired parameter combination\nprint(keynes(c0=2, c1=0.8, I=10))\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n################## Functions ##################################################\n# Let's cast the previous loop that simulates the Keynesian cross \n# into a function called \"keynes\"\n\n# the terms inside the brackets are the arguments of the function whose \n# values need to be supplied when the function is called\n\ndef keynes(c0, c1, I):\n    # Initialize\n    Y = C = 1\n\n    # Solve\n    for i in range(100):\n        Y = C + I\n        C = c0 + c1 * Y\n\n    return Y  # specify the value that will be returned when the function is executed\n\n# Execute function for desired parameter combination\nprint(keynes(c0=2, c1=0.8, I=10))\n\n\n\n\nExercise 2: functions\nUse the ‘keynes’ function we’ve just defined to find the equilibrium solution \\(Y^*\\) when setting \\(c_0=3\\), \\(c_1=0.8\\), and \\(I=10\\).\n\n\n\n\n\n\nR solution\n\n\n\n\n\n\nprint(keynes(c0=3, c1=0.8, I=10))\n\n[1] 65\n\n\n\n\n\n\n\n\n\n\n\nPython solution\n\n\n\n\n\n\nprint(keynes(c0=3, c1=0.8, I=10))\n\n64.99999998625\n\n\n\n\n\nBasic data structures: vectors and matrices\n\nin most applications we produce outputs which do not consist of a single number\noften we have an entire stream of results, or we want to analyse data and have to store larger amounts of data\nboth R and Python have a variety of data structures for this purpose\nwe will mostly work with elementary vectors and matrices\n\n\n########################### Basic data structures ##########################\n\n# Let's clean up first by clearing the environment (this is not\n# strictly necessary but keeps your work environment tidy)\nrm(list=ls(all=TRUE))\n\n#### Vectors \n# We can create an empty vector and fill it later (with results of our model for example)\nvec1 = vector(length=3)\n# we can define vectors explicitly using the c() function (c for column?)\nvec2 = c(1,2,3)\nvec3 = c(6,7,8)\n# we can also use the sequence operator\nvec4 = 1:10\n# and we can define the step size\nvec5 = seq(1,2,0.1)\nvec5\n# we can call specific entries using square brackets\nvec5[4]\n# if we want to access more elements at once\nvec5[c(4,1)]\n\n#### Matrices\n# define a matrix: 3 rows and 2 columns, all elements equal to 0\nmat1 = matrix(0, nrow=3, ncol=2)\nmat1\n# we can also fill it with specific values\nmat2 = matrix(c(1,2,3,4,5,6), nrow = 3, ncol = 2)\nmat2\n# access specific elements (columns,rows)\nmat2[3,1]\n# access entire rows or columns\nmat2[,1]\nmat2[1,]\n# access sub matrices\nmat2[c(1,2),]\n## Combine two column vectors in a matrix\nmat3=cbind(vec1, vec2)\nmat3\n## Combine two row vectors in a matrix\nmat4=rbind(vec1, vec2)\nmat4\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n########################### Basic data structures ##########################\n# In Python, we use the NumPy library for numerical computations with vectors/matrices (called \"arrays\")\n\nimport numpy as np\n\n#### Vectors\n# Create an empty vector (numpy array) and fill it later\nvec1 = np.empty(3)  # creates an empty array with 3 elements\n\n# Define vectors explicitly using numpy's array function\nvec2 = np.array([1, 2, 3])\nvec3 = np.array([6, 7, 8])\n\n# Use the range operator with numpy for sequences\nvec4 = np.arange(1, 11)  \n\n# Define a sequence with a specific step size using numpy's arange\nvec5 = np.arange(1, 2.1, 0.1)  \nprint(vec5)\n\n# Access specific entries using square brackets (note that Python uses zero-based indexing, \n# i.e. it starts counting the first element of a vector as 0\nprint(vec5[3])  # 4th element (index 3, 0-based indexing)\n\n# Access multiple elements at once\nprint(vec5[[3, 0]])  # accessing the 4th and 1st elements using numpy\n\n#### Matrices\n# Define a matrix: 3 rows and 2 columns, all elements equal to 0\nmat1 = np.zeros((3, 2))  # creates a matrix of zeros\nprint(mat1)\n\n# Fill the matrix with specific values\nmat2 = np.array([[1, 2], [3, 4], [5, 6]])  \nprint(mat2)\n\n# Access specific elements (row, column)\nprint(mat2[2, 0])  # 3rd row, 1st column\n\n# Access entire rows or columns\nprint(mat2[:, 0])  # entire first column\nprint(mat2[0, :])  # entire first row\n\n# Access submatrices\nprint(mat2[[0, 1], :])  # access the first two rows\n\n# Combine two column vectors in a matrix (equivalent to cbind in R)\nmat3 = np.column_stack((vec1, vec2))\nprint(mat3)\n\n# Combine two row vectors in a matrix (equivalent to rbind in R)\nmat4 = np.row_stack((vec1, vec2))\nprint(mat4)\n\n\n\n\nExercise 3: vectors and matrices\nWrite a loop which calculates \\(x_i=\\frac{1}{i^2}\\), where \\(i=1,2,..,10\\), and saves each element \\(x_i\\) in a vector.\n\n\n\n\n\n\nR solution\n\n\n\n\n\n\n#Define empty vector of length 10 where we save results\nx = vector(length = 10)\n\n# then define loop \nfor (i in 1:10){\n    x[i] = 1/i^2 \n}\n\n# Print result\nx\n\n [1] 1.00000000 0.25000000 0.11111111 0.06250000 0.04000000 0.02777778\n [7] 0.02040816 0.01562500 0.01234568 0.01000000\n\n\n\n\n\n\n\n\n\n\n\nPython solution\n\n\n\n\n\n\nimport numpy as np\n\n## Remember that in Python indexing starts with 0, which needs to be taken into account here\n\n# Define a zero vector with and index running from 0 to 9\nx = np.zeros(10)\n\n# Then define the loop, where you have two options to adjust for the zero-based indexing\n\n# Option 1: set range of loop from 1 to 10, and deduct 1 in the index on the LHS\nfor i in range(1, 11):  \n    x[i-1] = 1 / (i**2)\n\nprint(x)\n\n[1.         0.25       0.11111111 0.0625     0.04       0.02777778\n 0.02040816 0.015625   0.01234568 0.01      ]\n\n# Option 2: set range of loop from 2 to 10, and add 1 in the index on the RHS\nfor i in range(0, 10):  \n    x[i] = 1 / ((i+1)**2)\n\nprint(x)\n\n[1.         0.25       0.11111111 0.0625     0.04       0.02777778\n 0.02040816 0.015625   0.01234568 0.01      ]\n\n\n\n\n\nNext, write a second loop which calculates \\(x_i=\\frac{1}{i^3}\\), where \\(i=1,2,..,10\\), and saves each element \\(x_i\\) in a vector. Combine both vectors in a matrix.\n\n\n\n\n\n\nR solution\n\n\n\n\n\n\n#Define empty vectors of length 10 where we save results\nx = vector(length = 10)\ny = vector(length = 10)\n\n# then define loop \nfor (i in 1:10){\n  x[i] = 1/i^2 \n  y[i]= 1/i^3\n}\n\n# Combine vectors in a matrix\nmat=cbind(x,y)\n\n# Print result\nmat\n\n               x           y\n [1,] 1.00000000 1.000000000\n [2,] 0.25000000 0.125000000\n [3,] 0.11111111 0.037037037\n [4,] 0.06250000 0.015625000\n [5,] 0.04000000 0.008000000\n [6,] 0.02777778 0.004629630\n [7,] 0.02040816 0.002915452\n [8,] 0.01562500 0.001953125\n [9,] 0.01234568 0.001371742\n[10,] 0.01000000 0.001000000\n\n\n\n\n\n\n\n\n\n\n\nPython solution\n\n\n\n\n\n\n# Define an empty vector of length 10 where we save results\nx = np.zeros(10)\ny = np.zeros(10)\n\n# Then define the loop\nfor i in range(1, 11):  \n    x[i-1] = 1 / (i**2)\n    y[i-1] = 1 / (i**3)\n\n# Combine vectors in a matrix\nmat = np.column_stack((x, y))\n\nmat\n\narray([[1.        , 1.        ],\n       [0.25      , 0.125     ],\n       [0.11111111, 0.03703704],\n       [0.0625    , 0.015625  ],\n       [0.04      , 0.008     ],\n       [0.02777778, 0.00462963],\n       [0.02040816, 0.00291545],\n       [0.015625  , 0.00195312],\n       [0.01234568, 0.00137174],\n       [0.01      , 0.001     ]])",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#coming-up-next",
    "href": "how_to_use.html#coming-up-next",
    "title": "1  Getting Started",
    "section": "Coming up next",
    "text": "Coming up next\nYou have now successfully covered the elementary coding skills necessary to simulate macroeconomic models. Proceed to Chapter 2 for a general introduction to model simulation with a final exercise.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_use.html#footnotes",
    "href": "how_to_use.html#footnotes",
    "title": "1  Getting Started",
    "section": "",
    "text": "We are grateful to Rafael Wildauer for permission to reproduce a slightly modified version of his learning materials. In addition, some of the material below is taken from here.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html",
    "href": "how_to_simulate.html",
    "title": "2  How to Simulate Economic Models",
    "section": "",
    "text": "Introduction: economic models\nWhy do we build formal economic models? Because they help us think carefully about the causal mechanisms that generate certain economic outcomes (e.g. unemployment). Models are especially useful when the variables of interest are inherently quantitative (e.g. the interest rate and unemployment) and when several of these quantitative variables interact with each other. More specifically, models provide a precise formal representation of a set of interlinked causal mechanisms that are often difficult to analyse informally.\nEvery economic model essentially consist of three things:\nThe solution to the model, its ‘equilibrium’, will pin down values for the endogenous variables of the model for a given set of parameters and exogenous variables. Thus, the endogenous variables, e.g. unemployment, are determined within the system, while exogenous variables are determined outside of the system and often reflect policy variables, such as the central bank interest rate. The equations connect the variables of the system. They typically express:\nEquations may be linear or nonlinear. If a model contains nonlinear relationships between the endogenous variables, it may admit more than one solution (often called multiple equilibria).\nEconomic models can be either static or dynamic. In a static model, time plays no role and all endogenous variables are determined simultaneously. In a dynamic model, time matters and the endogenous variables adjust gradually over time.\nThe endogenous variables are typically interrelated: e.g. \\(x\\) determines \\(y\\), but \\(y\\) also determines \\(x\\). These interrelationships can be:\nUnlike static models, dynamic models describe what happens out of equilibrium.1 Note that dynamic models may contain both simultaneous and recursive relationships.\nWhether the relationships between the variables is simultaneous or recursive has implications for how the model can be solved. In general, simple economic models can often be solved analytically without a computer. If the model contains simultaneous relationships, it needs to be solved as a simultaneous system by solving for the endogenous variables through repeated substitution. This means going from the so-called ‘structural form’, i.e. the full set of equations, to the so-called ‘reduced form’, where the right-hand side of the equations only contains exogenous variables and parameters. If the system is linear, techniques from linear algebra such as matrix inversion or Cramer’s rule can be used (see Chiang and Wainwright (2005), chaps. 4-5). If the system contains recursive relationships, the equilibrium solution can be found by setting \\(x_{t+i}=x_{t-i}=x_{t}\\) for all \\(x\\) and then solving the resulting simultaneous system (more on this Chapter 9).\nHowever, often a complete analytical solution is difficult to come by. Common challenges are:\nIn these cases, numerical solution by means of computer simulation becomes useful. A key advantage is that it allows you to study much more complex models than the analytical approach does. A key disadvantage is that numerical solution requires the choice of a (possibly arbitrary) set of numerical values for the models’ parameters. It is thus less general than analytical solution – a limitation which should be borne in mind. We think that both analytical and numerical approaches are useful. Correspondingly, we supplement the numerical simulations with analytical model solutions where possible.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#introduction-economic-models",
    "href": "how_to_simulate.html#introduction-economic-models",
    "title": "2  How to Simulate Economic Models",
    "section": "",
    "text": "a set of \\(N\\) equations\na set of \\(N\\) endogenous variables\na set of exogenous or fixed coefficients (‘parameters’) and exogenous variables\n\n\n\neconomic (accounting) identities (e.g. that in a closed economy without government, saving is income that is not consumed: \\(S=Y-C\\))\nbudget constraints (e.g. that business investment can be financed out of retained profits and new debt, \\(I=\\Pi+\\Delta D\\))\nbehavioural functions (e.g. that households consume a constant proportion of their income, \\(C=c_1Y\\)), which often contain key parameters of the model (e.g. the marginal propensity to consume \\(c_1\\))\nequilibrium conditions (e.g. that demand must be equal to supply)\n\n\n\n\n\nsimultaneous: \\(x\\) and \\(y\\) determine each other simultaneously (within the same period)\nrecursive: \\(x\\) affects \\(y\\) only in \\(t+1\\) (or vice versa)\n\n\n\n\n\na model has more than 3 dimensions (\\(N&gt;3\\)): then it’s very tedious to compute analytical solutions\na model has nonlinearities that preclude the computation of analytical solutions\na model is dynamic and you want to examine the dynamic adjustment of the endogenous variables (which is tedious to do analytically)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#solving-economic-models-numerically",
    "href": "how_to_simulate.html#solving-economic-models-numerically",
    "title": "2  How to Simulate Economic Models",
    "section": "Solving economic models numerically",
    "text": "Solving economic models numerically\nIf a (dynamic) model exclusively contains recursive relationships, it can be solved iteratively by sequentially updating the endogenous variables from (arbitrarily set) initial conditions. This is easy to do with a computer. By contrast, if interrelationships are simultaneous, solving the system for the endogenous variables as described above is less trivial for a computer (finding the solution for \\(x\\) requires the solution of \\(y\\), but the latter requires in turn the solution for \\(x\\)). One approach is to use linear algebra: cast the system in matrix form (\\(b=Ax\\)) and let the computer find \\(x^*=A^{-1}b\\) through some algorithm (e.g. the Gauss-Seidel method).\nWe will use an approach that is simpler and based on iteration:\n\nchoose a set of numerical parameter values (e.g. \\(c_1=0.8\\))\nchoose (arbitrary but non-zero) initial values for the endogenous variables (e.g. \\(C_0=1)\\)\nthen solve the system of equations many times using a for loop\n\nIn this way, the solution gets approximated successively.\nA limitation of the method of iteration is that it will only converge to the solution of the simultaneous component of a model if the equilibrium is stable (more on stability in Chapter 9). For most static models, stability is required for the model to be economically meaningful. In that sense, if the iterative approach does not yield a solution, this is a sign that the model and/or parameterisation needs to be reconsidered. In dynamic models, stability is a key question that should be addressed in any case. Therefore, this limitation of the method of iteration may not be too restrictive in practice.\nSolving economic models numerically: examples\nA static model\nConsider a two-dimensional simultaneous system represented by a simple Keynesian goods market model:\n\\[\nY= C + I_0\n\\] \\[\nC = c_0 + c_1Y\n\\] In a closed economy without government, aggregate demand is composed of consumption \\(C\\) and investment \\(I\\), with the latter assumed to be exogenous. Goods market equilibrium requires aggregate demand to be equal to aggregate income \\(Y\\). Consumption is assumed to be determined by an autonomous component \\(c_0\\) and a marginal propensity to consume out of income \\(c_1\\).\nSuppose the parameters are given by \\(c_0=3\\) and \\(c_1=0.8\\). You are interested in how a change in investment from \\(I_0=5\\) to \\(I_0=6\\) affects the solution of the system. Through the method of substitution, we can easily derive that \\(Y^*=\\frac{c_0+I_0}{1-c_1}\\). The code below shows how to find this solution via simulation.\n\n### Simulate Keynesian goods market model via iteration\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of parameterisations that will be considered\nS=2\n\n# Set fixed parameter values\nc0=3\nc1=0.8\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_eq=vector(length=S)\nC_eq=vector(length=S)\n\n#Create vector with parameter that will change \nI0=vector(length=S)\nI0[1]=5\nI0[2]=6\n\n# Initialise endogenous variables at arbitrary positive value \nY=C=1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  for (iteration in 1:1000){\n  Y = C + I0[i]\n  C = c0 + c1*Y\n  } # close iterations loop\n  \n#Save results for different parameterisations in vector\nY_eq[i]=Y\nC_eq[i]=C\n} # close parameterisations loop\n\n# Display solutions\nY_eq\n\n[1] 40 45\n\nC_eq\n\n[1] 35 39\n\n# Verify solutions for Y\n(c0+I0[])/(1-c1)\n\n[1] 40 45\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Simulate Keynesian goods market model via iteration\n\n# Load NumPy library\nimport numpy as np\n\n# Set the number of parameterisations that will be considered\nS = 2\n\n# Set fixed parameter values\nc0 = 3\nc1 = 0.8\n\n# Create numpy arrays in which equilibrium solutions from different parameterisations will be stored\nY_eq = np.zeros(S)\nC_eq = np.zeros(S)\n\n# Create a numpy array with the parameter that will change\nI0 = np.zeros(S)\nI0[0] = 5\nI0[1] = 6\n\n# Initialize endogenous variables at an arbitrary positive value\nY = C = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iteration in range(1000):\n        Y = C + I0[i]\n        C = c0 + c1 * Y\n\n    # Save results for different parameterisations in the numpy arrays\n    Y_eq[i] = Y\n    C_eq[i] = C\n\n# Display solutions\nY_eq\nC_eq\n\n# Verify solutions for Y\n(c0+I0)/(1-c1)\n\n\n\n\nLet’s break this code down a little bit:\n\nset the number of scenarios \\(S\\), define parameter values, and create vectors of length \\(S\\) in which the results for the endogenous variables will be stored\ndefine changes in exogenous variables or parameters (i.e. construct different scenarios)\ninitialise the endogenous variables\nwrite down the equations (solved for the endogenous variables such that every endogenous variable of the system appears on the left-hand side of an equation exactly once)\n\nplace these equations inside a for loop\n\nthe loop says: repeat the segment of code insights the curly brackets 1000 times\n\n\nnest the loop that solves the system in an outer loop that loops through different parameterisations (here for \\(I_0\\))\nafter the iterations loop is finished, save the results for the current pameterisation\n\nWhat happens is the following: in the first iteration, \\(Y\\) and \\(C\\) are calculated based on the initial values and the parameter values. In the second iteration, the values are then overwritten based on the results from the first iteration. This process continues 1000 times. In this way, the correct solution is successively approximated. If you have an analytical solution, you can compare it with the numerical one to double-check your results.\nWhen does the method of iteration fail to provide a solution? In the following code, everything is the same with the only difference that the marginal propensity to consume is now larger than unity (\\(c_1=1.2\\)). Now the numerical simulation fails to find the solution. This is because with \\(c_1&gt;0\\), the so-called Keynesian equilibrium condition is violated and the system happens to be unstable. We will discuss in Chapter 9 the issue of stability and how to analyse it formally. At this point, we simply note that the method of iterations requires static models to be stable to yield equilibrium solutions.\n\n### Parameterisation for which method of iteration fails\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of parameterisations that will be considered\nS=2\n\n# Set fixed parameter values\nc0=3\nc1=1.2\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_eq=vector(length=S)\nC_eq=vector(length=S)\n\n#Create vector with parameter that will change \nI0=vector(length=S)\nI0[1]=5\nI0[2]=6\n\n# Initialise endogenous variables at arbitrary positive value \nY=C=1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  for (iteration in 1:1000){\n  Y = C + I0[i]\n  C = c0 + c1*Y\n  } # close iterations loop\n  \n#Save results for different parameterisations in vector\nY_eq[i]=Y\nC_eq[i]=C\n} # close parameterisations loop\n\n# Display solutions\nY_eq\n\n[1]  5.818655e+80 8.832196e+159\n\n# Verify solutions for Y\n(c0+I0[])/(1-c1)\n\n[1] -40 -45\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Parameterisation for which method of iteration fails\nc1 = 1.2  \n\n# Initialize endogenous variables at an arbitrary positive value\nY = C = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iteration in range(1000):\n        Y = C + I0[i]\n        C = c0 + c1 * Y\n\n    # Save results for different parameterisations in the numpy arrays\n    Y_eq[i] = Y\n    C_eq[i] = C\n\n# Display solutions for Y_eq\nY_eq\n\n# Verify solutions for Y\n(c0+I0)/(1-c1)\n\n\n\n\nA dynamic model (in discrete time)\nConsider now a dynamic version of the Keynesian goods market model that was proposed by Paul Samuelson (1939). In this model, investment (\\(I\\)) becomes endogenous and reacts to the change in consumption. Aggregate demand now also contains government spending (\\(G\\)), which is assumed to be exogenous. Consumption (\\(C\\)) responds to changes in income (\\(Y\\)) with a lag:\n\\[\nY_t = C_t + I_t + G_0\n\\] \\[\nI_t = \\beta(C_t - C_{t-1})\n\\] \\[\nC_t=c_1Y_{t-1}.\n\\] This is a dynamic model, in which the endogenous variables adjust gradually over time. However, the model is not purely recursive as investment reacts to consumption in the same period (and output to consumption and investment). By shifting \\(Y_t=C_t + I_t + G_0\\) one period back, substitution into the consumption, and then investment function, the system can be reduced to two equations that are fully recursive:\n\\[\nC_t= c_1(C_{t-1} + I_{t-1} + G_0)\n\\] \\[\nI_t= \\beta[c_1(C_{t-1} + I_{t-1} + G_0) - C_{t-1}]\n\\] We can find the solution for output analytically by setting \\(x_t=x_{t-1}\\) for all variables and then applying the method of substitution. This yields \\(Y^*=\\frac{G_0}{1-c_1}\\). The code below shows how to find this solution through simulation.\n\n### Simulate Samuelson 1939\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of periods for which you want to simulate\nQ=100\n\n# Set number of parameterisations that will be considered\nS=2\n\n# Set period in which shock or shift in an will occur\ns=15\n\n# Set fixed parameter values\nc1=0.8\nbeta=0.6\n\n# Construct (S x Q) matrices in which values for different periods will be stored; initialise at 1\nC=matrix(data=1, nrow=S, ncol=Q)\nI=matrix(data=1, nrow=S, ncol=Q)\n\n#Construct matrices for exogenous variable or parameter that will change over time to capture different scenarios\nG0=matrix(data=5, nrow=S, ncol=Q)\n\n# Set parameter values for different scenarios\nG0[2,s:Q]=6     # scenario: permanent increase in government spending from I0=5 to I0=6 from period s=15 onwards\n\n#Solve this system recursively based on the initialisation\nfor (i in 1:S){\n  for (t in 2:Q){\n    C[i,t] = c1*(C[i,t-1] + I[i,t-1] + G0[i,t])\n    I[i,t] = beta*(c1*(C[i,t-1] + I[i,t-1] + G0[i,t]) - C[i,t-1])\n  } # close time loop\n}   # close scenarios loop\n\n# Calculate output\nY=C+G0+I\n\n# Display solution\nY[,Q]\n\n[1] 25 30\n\n# Verify solutions for Y\n(G0[,Q])/(1-c1)\n\n[1] 25 30\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Simulate Samuelson 1939\n\n# Set the number of periods for which you want to simulate\nQ = 100\n\n# Set the number of parameterisations that will be considered\nS = 2\n\n# Set the period in which a shock or shift in 'an' will occur\ns = 15\n\n# Set fixed parameter values\nc1 = 0.8\nbeta = 0.6\n\n# Construct (S x Q) matrices in which values for different periods will be stored; initialize at 1\nC = np.ones((S, Q))\nI = np.ones((S, Q))\n\n# Construct matrices for exogenous variables or parameters that will change \n# over time to capture different scenarios, initialise at 5\nG0 = np.ones((S, Q))*5 \n\n# Set parameter values for different scenarios\nG0[1, s:Q] = 6  # scenario: permanent increase in government spending from I0=5 to I0=6 from period s=15 onwards\n\n# Solve this system recursively based on the initialization\nfor i in range(S):\n    for t in range(1, Q):\n        C[i, t] = c1 * (C[i, t - 1] + I[i, t - 1] + G0[i, t])\n        I[i, t] = beta * (c1 * (C[i, t - 1] + I[i, t - 1] + G0[i, t]) - \n                          C[i, t - 1])\n\n# Calculate output\nY = C + G0 + I\n\n# Display the solutions at time Q\nY[:, Q - 1]\n\n# Verify solutions for Y\n(G0[:,Q - 1])/(1-c1)\n\n\n\n\nThe code solves the recursive system numerically through iteration. Let’s again break down what the code does:\n\nset the number of periods for which we want to simulate the model (here \\(Q=100\\)), set the number of scenarios \\(S\\) and the period \\(s\\) in which a change in the scenario should occur\nset the parameter values and create \\((S \\times Q)\\) matrices in which the results for the endogenous variables will be stored, such that the columns represent time and the rows represent different scenarios; initialise the endogenous variables\ndefine changes in exogenous variables or parameters (i.e. construct different scenarios)\nwrite down the equations (solved for the endogenous variables such that every endogenous variable of the system appears on the left-hand side of an equation exactly once)\n\nplace these equations inside a for loop that runs from \\(t=2\\) to \\(Q\\)\n\nthe loop says: repeat the segment of code insights the curly brackets, each time with the index number \\(t\\) shifted by \\(+1\\) until \\(t=Q\\)\n\n\n\nnest the loop that solves the system in an outer loop that loops through different parameterisations (here for \\(G_0\\))\n\nNote that due to the exclusive presence of recursive equations, no loop is need that iterates the equations within every period. However, many dynamic models contain both simultaneous and recursive equations. In this case, a third loop inside the time loop is needed that iterates the equations within each period so as to solve the simultaneous equations. Otherwise, the approach to solving dynamic systems is not fundamentally different from the one for static systems.\nAt the end of the simulation run, we can again compare the results from the numerical simulation with the analytical solution. However, what is perhaps more interesting is to trace the dynamic adjustment of the endogenous variables towards equilibrium. The best way to examine this is by plotting the results.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#how-to-plot-the-results-of-a-model",
    "href": "how_to_simulate.html#how-to-plot-the-results-of-a-model",
    "title": "2  How to Simulate Economic Models",
    "section": "How to plot the results of a model",
    "text": "How to plot the results of a model\nWe will consider two main ways to plot model outputs: bar charts for static models and time series charts for dynamic models. Bar charts compare the equilibrium values of \\(Y_t\\) for different parameterisations:\n\n# Bar chart of different equilibrium solutions of Samuelson (1939) model\nbarplot(Y[,Q], ylab=\"Y\", main=\"Output\", names.arg=c(\"Baseline\", \"Increase in G0\"))\n\n\n\n\n\n\n\nNext, we show a basic version of a time series chart that displays the dynamics of \\(Y_t\\):\n\n# Time series chart of output dynamics in Samuelson (1939) model\nplot(Y[1, 1:100],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Output\", cex=0.8)\n\n\n\n\n\n\n\nAs you can see, there are many settings you can fiddle around with to adjust the appearance of the graph to your liking (run ‘?plot’ to find information about the different options.) If we want to plot the dynamics for the two different parameterisations, we can do the following:\n\n# Time series chart of output dynamics for different scenarios in Samuelson (1939) model\nplot(Y[1, 1:100],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\", ylim=range(min(Y[1,], Y[2,]), max(Y[1,], Y[2,]))) \ntitle(main=\"Output under different scenarios\", cex=0.8)\nlines(Y[2, 1:100],lty=2)\nlegend(\"bottomright\", legend=c(\"Baseline\", \"Increase in G0\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nNote that we have adjusted the range of the y-axis to make sure the graph captures the minimum and maximum values from both parameterisations.\nFinally, consider a plot for \\(C_t\\) and \\(I_t\\) with two separate axes:\n\n# Time series chart of Samuelson (1939) model with separate axes for consumption and investment\nplot(C[1, 1:100], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Consumption and Investment\", cex=0.8)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(I[1, 1:100], type=\"l\", col=1, lwd=2, lty=2, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(I[1, 1:100]), cex=0.8)\naxis(side = 4, at=pretty(range(I[1, 1:100])))  \nmtext(\"I\", side = 4, line = 3)\nlegend(\"right\", legend=c(\"C\", \"I\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#### Plots\n\n# Load matplot library\nimport matplotlib.pyplot as plt\n\n# Bar chart of different equilibrium solutions of Samuelson (1939) model\nscenario_labels = [\"Baseline\", \"Increase in G0\"]\nplt.bar(scenario_labels, Y[:, Q - 1])\nplt.xlabel(\"Scenario\")\nplt.ylabel(\"Y\")\nplt.title(\"Output\")\nplt.show()\n\n# Time series chart of output dynamics in Samuelson (1939) model\nplt.plot(range(1, Q), Y[0, 0:Q - 1], color='black', linewidth=2, linestyle='-')\nplt.xlabel(\"Time\")\nplt.ylabel(\"Y\")\nplt.title(\"Output\", fontsize=10)\nplt.show()\n\n# Time series chart of output dynamics for different scenarios in Samuelson \n#(1939) model\nplt.plot(range(1, Q), Y[0, 0:Q - 1], color='black', linewidth=1, linestyle='-')\nplt.plot(range(1, Q), Y[1, 0:Q - 1], color='black', linewidth=1, linestyle='--')\nplt.xlabel(\"Time\")\nplt.ylabel(\"Y\")\nplt.title(\"Output under different scenarios\", fontsize=10)\nplt.legend([\"Baseline\", \"Increase in G0\"], loc='lower right')\nplt.show()\n\n# Time series chart of Samuelson (1939) model with separate axes for consumption \n# and investment\nfig, ax1 = plt.subplots()\nax1.plot(range(1, Q), C[0, 0:Q - 1], color='black', linewidth=2, linestyle='-', \n         label='C')\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(\"C\", color='black')\nax1.tick_params(axis='y', labelcolor='black')\nax2 = ax1.twinx()\nax2.plot(range(1, Q), I[0, 0:Q - 1], color='black', linewidth=2, linestyle='--',\n         label='I')\nax2.set_ylabel(\"I\", color='black')\nax2.tick_params(axis='y', labelcolor='black')\nplt.title(\"Consumption and Investment\", fontsize=10)\nlines, labels = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc='right')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#how-to-create-a-directed-graph-of-a-model",
    "href": "how_to_simulate.html#how-to-create-a-directed-graph-of-a-model",
    "title": "2  How to Simulate Economic Models",
    "section": "How to create a directed graph of a model",
    "text": "How to create a directed graph of a model\nAnother perspective on a model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\nThe directed graph can be derived from the model’s Jacobian matrix.2 Let \\(x\\) be the vector containing the model’s endogenous variables and \\(f(x)\\) the system of equations making up the model. The Jacobian matrix is then given by \\(J=\\frac{\\partial f()}{\\partial x}\\). As we often also want to display exogenous variables in the directed graph, it can be useful to expand the Jacobian matrix by adding rows and columns for those exogenous variables.\nNext, construct an ‘auxiliary’ Jacobian matrix \\(M\\) in which all the non-zero elements of the Jacobian are replaced by ones, whereas zero elements remain unchanged, i.e.\n\\[\nM_{ij} =\n\\begin{cases}\n1 & \\text{if }  J_{ij} \\neq 0, \\\\\n0 & \\text{otherwise.}\n\\end{cases}\n\\]\nFinally, taking the transpose of this `auxiliary’ Jacobian matrix yields the adjacency matrix \\(A=M^T\\), which is a binary matrix whose elements (\\(A_{ji}\\)) indicate whether there is a directed edge from a node \\(x_j\\) to node \\(x_i\\). From the adjacency matrix, the directed graph is constructed.\nThe code below shows this for the example of the Samuelson (1939) model.3\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 4 variables: \n  # endogenous: (1) Y, (2) C, (3) I\n  # exogenous: (4) G0\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\n            #  Y  C  I G0\nM_mat=matrix(c(0, 1, 1, 1, # Y\n               1, 0, 0, 0, # C\n               0, 1, 0, 0, # I\n               0, 0, 0, 0),# G0 \n               4, 4, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(G[0]))\n\n# Plot directed graph matrix\nplot(dg, main=\"Directed graph of Samuelson model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Construct auxiliary Jacobian matrix for 4 variables\n  # endogenous: (1) Y, (2) C, (3) I\n  # exogenous: (4) G0\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are\n# unchanged\nM_mat = np.array([[0, 1, 1, 1],\n         [1, 0, 0, 0],\n         [0, 1, 0, 0],\n         [0, 0, 0, 0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"Y\", 1: \"C\", 2: \"I\", 3: \"$G_0$\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=42)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=500, node_color='lightblue', font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.title(\"Directed graph of Samuelson model\", fontsize=12)\nplt.axis('off')\nplt.show()\n\n\n\n\nBroadly speaking, three types of nodes are possible:\n\nnodes from which arrows only point away represent exogenous variables (\\(G_0\\))\nnodes towards which some arrows point, but from which arrows also point away, represent endogenous variables that also have a causal impact on other variables (\\(Y\\), \\(C\\), and \\(I\\))\nnodes arrows only point towards represent endogenous variables that are residuals\n\n\nIt can thus be seen that the key exogenous variable in the Samuelson (1939) model is government spending \\(G_0\\), which determines aggregate income, which in turn feeds into consumption. Consumption then feeds into investment, which feeds back into income yielding the multiplier-accelerator effect.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#exercise-simulating-and-visualising-a-simple-model",
    "href": "how_to_simulate.html#exercise-simulating-and-visualising-a-simple-model",
    "title": "2  How to Simulate Economic Models",
    "section": "Exercise: simulating and visualising a simple model",
    "text": "Exercise: simulating and visualising a simple model\n\ntake the code for the static Keynesian goods market from Section 2.2.1.1 above\nadd exogenous government spending \\(G_0\\) to aggregate demand\nset \\(G_0 = 2\\)\n\ncreate a third scenario where \\(G_0\\) increases to \\(G_0=5\\)\n\nplot equilibrium output \\(Y^*\\) for the three scenarios in a bar chart\n\n\n\n\n\n\n\nR solution\n\n\n\n\n\n\n### Add government spending to Keynesian goods market model\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of parameterisations that will be considered\nS=3\n\n# Set fixed parameter values\nc0=3\nc1=0.8\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_eq=vector(length=S)\nC_eq=vector(length=S)\n\n#Create vectors with parameters that will change \nI0=vector(length=S)\nI0[]=5 # set I0=5 across all scenarios\nI0[2]=6\n# adding government spending\nG0=vector(length=S)\nG0[]=2  # set G0=2 across all scenarios\nG0[3]=5 # set G0=5 in third scenario\n\n# Initialise endogenous variables at arbitrary positive value \nY=C=1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  for (iteration in 1:1000){\n  Y = C + I0[i] + G0[i]            # add government spending to aggregate demand\n  C = c0 + c1*Y\n  } # close iterations loop\n  \n#Save results for different parameterisations in vector\nY_eq[i]=Y\nC_eq[i]=C\n} # close parameterisations loop\n\n# Bar chart of different scenarios for output\nbarplot(Y_eq, ylab=\"Y\", main=\"Output\", names.arg=c(\"Baseline\", \"Increase in I0\", \"Increase in G0\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Solution\n\n\n\n\n\n\n### Add government spending to Keynesian goods market model\n\n# Set the number of parameterisations that will be considered\nS = 3\n\n# Set fixed parameter values\nc0 = 3\nc1 = 0.8\n\n# Create numpy arrays in which equilibrium solutions from different parameterisations will be stored\nY_eq = np.zeros(S)\nC_eq = np.zeros(S)\n\n# Create a numpy array with the parameter that will change\nI0 = np.zeros(S)\nI0[:] = 5 # set I0=5 across all scenarios\nI0[1] = 6\n# adding government spending\nG0 = np.zeros(S)\nG0[:] = 2 # set G0=2 across all scenarios\nG0[2] = 5 # set G0=5 in third scenario\n\n# Initialize endogenous variables at an arbitrary positive value\nY = C = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iteration in range(1000):\n        Y = C + I0[i] + G0[i]   # add government spending to aggregate demand\n        C = c0 + c1 * Y\n\n    # Save results for different parameterisations in the numpy arrays\n    Y_eq[i] = Y\n    C_eq[i] = C\n\n# Load matplot library\nimport matplotlib.pyplot as plt\n\n# Bar chart of different scenarios for output\nscenario_labels = [\"Baseline\", \"Increase in I0\", \"Increase in G0\"]\nplt.bar(scenario_labels, Y_eq)\nplt.xlabel(\"Scenario\")\nplt.ylabel(\"Y\")\nplt.title(\"Output\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#sec-sim-continuous",
    "href": "how_to_simulate.html#sec-sim-continuous",
    "title": "2  How to Simulate Economic Models",
    "section": "Appendix: How to simulate dynamic model in continuous time",
    "text": "Appendix: How to simulate dynamic model in continuous time\nSometimes, dynamic economic models are written in continuous time where the time increment is assumed to be infinitesimally small. Consider, for example, a continuous-time version of the Keynesian goods market model:\n\\[\n\\dot{Y}= k(C + I_0 - Y)\n\\]\n\\[\nC = c_0 + c_1Y,\n\\] where \\(\\dot{Y}=\\frac{dY}{dt}\\). To simulate this model, we have to approximate the differential equation for \\(\\dot{Y}\\) by a difference equation for \\(Y_t\\) and let the time increment \\(\\Delta t\\) become very small. More specifically, we write:\n\\[\nY(t+\\Delta t)=Y_t + \\dot{Y} \\Delta t =Y_t + [k(C + I_0 - Y)]\\Delta t.\n\\] This approach is also called the Euler forward method. The code below shows to implement that method. We use \\(\\Delta t = 0.01\\). Note that we need to raise the time horizon \\(Q\\) and set the adjustment speed \\(k\\) relatively high to make sure that the system has effectively converged to the equilibrium by \\(Q\\).\n\n### Simulate continuous time version of Keynesian goods market model\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set number of periods for which you want to simulate\nQ=800\n\n# Set number of parameterisations that will be considered\nS=1\n\n# Set fixed parameter values\nc0=3\nc1=0.8\nk=8\ndelta=0.01\n\n# Construct matrices in which values for different periods will be stored; initialise at 1\nY=matrix(data=1, nrow=S, ncol=Q)\nC=matrix(data=1, nrow=S, ncol=Q)\n\n#Construct matrices for exogenous variable \nI0=matrix(data=5, nrow=S, ncol=Q)\n\n#Solve this system recursively based on the initialisation\n  for (t in 2:Q){\n    for (iterations in 1:1000){\n    Y[1,t] = Y[1,t-1] + delta*(k*(C[1,t-1] + I0[1,t-1] - Y[1,t-1]))\n    C[1,t] = c0 + c1*Y[1,t]\n    } # close within-period loop\n  } # close time loop\n\n\n# Verify solutions for Y\n(c0+I0[1,Q])/(1-c1)\n\n[1] 40\n\nY[1,Q]\n\n[1] 39.9999\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Simulate continuous time version of Keynesian goods market model\n\n# Load NumPy\nimport numpy as np\n\n# Set number of periods for which you want to simulate\nQ = 800\n\n# Set number of parameterizations that will be considered\nS = 1\n\n# Set fixed parameter values\nc0 = 3\nc1 = 0.8\nk = 8\ndelta = 0.01\n\n# Initialize matrices to store values for different periods\nY = np.ones((S, Q))\nC = np.ones((S, Q))\n\n# Initialize the matrix for the exogenous variable\nI0 = np.full((S, Q), 5)\n\n# Solve this system recursively based on the initialization\nfor t in range(1, Q):\n    for iterations in range(1000):\n        Y[0, t] = Y[0, t - 1] + delta * (k * (C[0, t - 1] + I0[0, t - 1] - Y[0, t - 1]))\n        C[0, t] = c0 + c1 * Y[0, t]\n\n# Verify the solution for Y at time Q\n(c0 + I0[0, Q - 1]) / (1 - c1)\n\nY[0,Q - 1]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#references",
    "href": "how_to_simulate.html#references",
    "title": "2  How to Simulate Economic Models",
    "section": "References",
    "text": "References\n\n\n\n\nChiang, Alpha C, and Kevin Wainwright. 2005. Fundamental Methods of Mathematical Economics. 4th ed. New York: McGraw-Hill Education.\n\n\nFennell, Peter G., David J. P. O’Sullivan, Antoine Godin, and Stephen Kinsella. 2015. “Is It Possible to Visualise Any Stock Flow Consistent Model as a Directed Acyclic Graph?” Computational Economics 48 (2): 307–16. https://doi.org/10.1007/s10614-015-9521-8.\n\n\nSamuelson, Paul A. 1939. “Interactions between the Multiplier Analysis and the Principle of Acceleration.” The Review of Economics and Statistics 21 (2): 75–78. https://doi.org/10.2307/1927758.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "how_to_simulate.html#footnotes",
    "href": "how_to_simulate.html#footnotes",
    "title": "2  How to Simulate Economic Models",
    "section": "",
    "text": "That raises the question of whether an equilibrium is stable or unstable, which is discussed in Chapter 9.↩︎\nSee Fennell et al. (2015) for a neat exposition.↩︎\nTo create the directed graph, we rely on external libraries which you may have to install first. In R, this can be accomplished with install.packages(\"igraph\") and in Python with pip install networkx. Once that library is installed, you only need to activate it in each session before you use it. In R, you can do this by executing library(igraph) and in Python through import networkx.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>How to Simulate Economic Models</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html",
    "href": "a_neoclassical_macro_model.html",
    "title": "3  A Neoclassical Macro Model",
    "section": "",
    "text": "Overview\nThis model captures some key features of neoclassical macroeconomics. The model is based on the optimising behaviour of firms and households that interact in perfect markets. Households choose between labour and leisure as well as current and future consumption. They form (rational) expectations about their future income that impact their consumption decisions today. Firms are owned by households and maximise profits using a constant returns to scale technology (with diminishing marginal returns to factors of production). Markets are competitive and clear instantaneously through flexible prices. The most important market is the labour market, in which the equilibrium between firms’ demand and households’ supply of labour is established by a flexible real wage. The level of employment established on the labour market then determines aggregate supply via the production function. Aggregate demand always accommodates to aggregate supply via a flexible real interest rate that establishes an equilibrium between investment and saving (often interpreted as the market for loanable funds). The money supply is exogenous in this model and only impacts the price level but not the real economy – the so-called Classical Dichotomy (or neutrality of money). Government expenditures do influence the real economy but they crowd out private expenditures (through a mechanism called Ricardian Equivalence).\nIn this short- to medium-run version of the model, prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is thus static. However, expectations about future income and government spending will impact current consumption of households that intertemporally maximise utility. The model is adapted from Garín, Lester, and Sims (2021).",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#the-model",
    "href": "a_neoclassical_macro_model.html#the-model",
    "title": "3  A Neoclassical Macro Model",
    "section": "The Model",
    "text": "The Model\n\\[\nY=AK^aN^{1-a}, \\quad a\\in (0,1)\n\\tag{3.1}\\]\n\\[\nw=(1-a)AK^aN^{-a}\n\\tag{3.2}\\]\n\\[\nN= 1-\\frac{b_1}{w}, \\quad b_1&gt;0\n\\tag{3.3}\\]\n\\[\nC=c_1\\left[Y- G +\\frac{Y^f-G^f}{1+r} -c_2\\ln\\left(\\frac{b_1}{w}\\right)\\right]\n\\tag{3.4}\\]\n\\[\nI =\\left(\\frac{aAN^{1-a}}{r}\\right)^{\\frac{1}{1-a}}\n\\tag{3.5}\\]\n\\[\nG= G_0\n\\tag{3.6}\\]\n\\[\nY= C(r) + I(r) + G\n\\tag{3.7}\\]\n\\[\nr_n= r + \\pi^f\n\\tag{3.8}\\]\n\\[\nM_s=M_0\n\\tag{3.9}\\]\n\\[\nM_d=\\frac{b_3(1+r_n)PC}{r_n}\n\\tag{3.10}\\]\n\\[\nM = M_d(P)= M_s\n\\tag{3.11}\\]\nwhere \\(Y\\), \\(K\\), \\(N\\), \\(w\\), \\(C\\), \\(G\\), \\(r\\), \\(I\\), \\(r_n\\), \\(\\pi\\), \\(M_s\\), \\(M_d\\), and \\(P_t\\) are real output, the capital stock, employment, the real wage, consumption, government expenditures, the real interest rate, investment, the nominal interest rate, inflation, the money supply, money demand, and the price level, respectively. The \\(f\\)-superscript denotes (expected) future values. For simplicity, expected future variables will be treated as exogenous.\nBy Equation 3.1, output is determined by a Cobb-Douglass production function with constant returns to scale and diminishing marginal returns to each factor (capital and labour). Equation 3.2 is the labour demand of firms solved for the real wage. Profit maximising firms will hire workers until the real wage is equal to the marginal product of labour \\(\\left(\\frac{\\partial Y}{\\partial N}=(1-a)AK^aN^{-a}\\right)\\).1 Equation 3.3 specifies households’ labour supply, which is positively related to the real wage. By Equation 3.4, consumption is positively related to the real wage, current and (expected) future income,2 and negatively related to the real interest rate. The composite parameters \\(c_1= \\left(\\frac{1}{1+b_2+b_3}\\right)\\) and \\(c_2= b_1(b_2+b_3)\\) stem from the weights in the household’s utility function (see analytical discussion below). The consumption function implies that for a higher real interest rate, households increase their saving (the supply of loanable funds). Furthermore, consumption is negatively related to current and future government expenditures. This is an implication of consumption smoothing: as households know that governments will have to repay its debts in the future through higher taxes, an increase in government expenditures today is perceived as an increase in taxes (regardless of whether the government finances its current expenditures through taxes or debt, a result that is also called ‘Ricardian Equivalence’).3 Equation 3.5 specifies investment as a negative function of the real interest rate and a positive function of productivity. By Equation 3.6, government expenditures are exogenous. Equation 3.7 is the goods market equilibrium condition, which pins down the equilibrium real interest rate through the market for loanable funds. Equation 3.8 specifies the nominal interest rate using the well-known Fisher equation. Equation 3.9 says that the money supply is exogenous. By Equation 3.10, households’ money demand is negatively related to the nominal interest rate and positively related to consumption (capturing the transaction demand for money). Finally, Equation 3.11 is the equilibrium condition for the money market, which pins down the price level.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#simulation",
    "href": "a_neoclassical_macro_model.html#simulation",
    "title": "3  A Neoclassical Macro Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenarios 2 and 3 are a monetary expansion (increase in the exogenous money supply \\(M_0\\)) and fiscal expansion (increase in \\(G_0\\)), respectively. Scenario 4 is an improvement in total factor productivity (\\(A\\)) and scenario 5 a fall in expected future income (\\(Y^f\\)). Finally, scenario 6 is a shift in household preferences towards more leisure (\\(b_1\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(A\\)\n\\(a\\)\n\\(b_{1}\\)\n\\(b_{2}\\)\n\\(b_{3}\\)\n\\(G_{0}\\)\n\\(Y^{f}\\)\n\\(M_{0}\\)\n\\(K\\)\n\\(\\pi_{f}\\)\n\n\n\n1: baseline\n2\n0.3\n0.4\n0.9\n0.6\n1\n1\n5\n5\n0.02\n\n\n2: monetary expansion (\\(M_{0}\\))\n2\n0.3\n0.4\n0.9\n0.6\n1\n1\n6\n5\n0.02\n\n\n3: fiscal expansion (\\(G_{0}\\))\n2\n0.3\n0.4\n0.9\n0.6\n2\n1\n6\n5\n0.02\n\n\n4: productivity boost (\\(A\\))\n2.5\n0.3\n0.4\n0.9\n0.6\n1\n1\n5\n5\n0.02\n\n\n5: lower expected future income (\\(Y^{f}\\))\n2\n0.3\n0.4\n0.9\n0.6\n1\n0.2\n5\n5\n0.02\n\n\n6: increased preference for leisure (\\(b_{1}\\))\n2\n0.3\n0.8\n0.9\n0.6\n1\n1\n5\n5\n0.02\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S) # Income/output\nw_star=vector(length=S) # Real wage\nC_star=vector(length=S) # Consumption\nI_star=vector(length=S) # Investment\nr_star=vector(length=S) # Real interest rate\nrn_star=vector(length=S) # Nominal interest rate\nN_star=vector(length=S) # Employment\nP_star=vector(length=S) # Price level\n\n# Create and parameterise exogenous variables/parameters that will be shifted\nM0=vector(length=S) # money supply\nG0=vector(length=S) # government expenditures\nA=vector(length=S)  # productivity\nYf=vector(length=S) # expected future income\nb1=vector(length=S) # household preference for leisure\nM0[]=5\nG0[]=1\nA[]=2\nYf[]=1\nb1[]=0.4\n\n# Set parameter values for different scenarios\nM0[2]=6   # scenario 2: monetary expansion \nG0[3]=2   # scenario 3: fiscal expansion\nA[4]=2.5  # scenario 4: productivity boost\nYf[5]=0.2 # scenario 5: lower expected future income\nb1[6]=0.8 # scenario 6: increased preference for leisure\n\n#Set constant parameter values\na=0.3  # Capital elasticity of output\nb2=0.9 # discount rate\nb3=0.6 # household preference for money\nK=5    # Exogenous capital stock\npe=0.02 # Expected rate of inflation\nGf=1  # Future government spending\n\n# Initialise endogenous variables at arbitrary positive value\nw = C = I = Y = r = N = P = 1 \n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  \nfor (iterations in 1:1000){\n  \n  #Model equations\n  \n  #(1) Cobb-Douglass production function  \n  Y = A[i]*(K^a)*N^(1-a)\n  \n  #(2) Labour demand \n  w = A[i]*(1-a)*(K^a)*N^(-a) \n  \n  #(3) Labour supply\n  N = 1 - (b1[i])/w\n  \n  #(4) Consumption demand\n  C = (1/(1+b2+b3))*(Y - G0[i] + (Yf[i]-Gf)/(1+r) -b1[i]*(b2+b3)*log(b1[i]/w))\n   \n  #(5) Investment demand, solved for r\n  r=(I^(a-1))*a*A[i]*N^(1-a) \n   \n  #(6) Goods market equilibrium condition, solved for I\n  I = Y - C - G0[i]\n  \n  #(7) Nominal interest rate\n  rn = r + pe\n  \n  #(8) Price level\n  P = (M0[i]*rn)/((1+rn)*b3*C) \n\n}\n  \n#Save results for different parameterisations in vector\nY_star[i]=Y\nw_star[i]=w\nC_star[i]=C\nI_star[i]=I\nr_star[i]=r\nN_star[i]=N\nP_star[i]=P\nrn_star[i]=rn\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions from different parameterizations\nY_star = np.empty(S)  # Income/output\nw_star = np.empty(S)  # Real wage\nC_star = np.empty(S)  # Consumption\nI_star = np.empty(S)  # Investment\nr_star = np.empty(S)  # Real interest rate\nrn_star = np.empty(S)  # Nominal interest rate\nN_star = np.empty(S)  # Employment\nP_star = np.empty(S)  # Price level\n\n# Create and parameterize exogenous variables/parameters that will be shifted\nM0 = np.zeros(S)  # Money supply\nG0 = np.zeros(S)  # Government expenditures\nA = np.zeros(S)   # Productivity\nYf = np.zeros(S)  # Expected future income\nb1 = np.zeros(S)  # Household preference for leisure\n\n# Baseline parameterisation\nM0[:] = 5\nG0[:] = 1\nA[:] = 2\nYf[:] = 1\nb1[:] = 0.4\n\n# Set parameter values for different scenarios\nM0[1] = 6   # Scenario 2: monetary expansion\nG0[2] = 2   # Scenario 3: fiscal expansion\nA[3] = 2.5  # Scenario 4: productivity boost\nYf[4] = 0.2  # Scenario 5: lower expected future income\nb1[5] = 0.8  # Scenario 6: increased preference for leisure\n\n# Set constant parameter values\na = 0.3  # Capital elasticity of output\nb2 = 0.9  # Discount rate\nb3 = 0.6  # Household preference for money\nK = 5  # Exogenous capital stock\npe = 0.02  # Expected rate of inflation\nGf = 1  # Future government spending\n\n# Initialize endogenous variables at arbitrary positive values\nw = C = I = Y = r = N = P = 1 \n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # Model equations\n\n        # (1) Cobb-Douglas production function\n        Y = A[i] * (K**a) * N**(1-a)\n\n        # (2) Labour demand\n        w = A[i] * (1-a) * (K**a) * N**(-a)\n\n        # (3) Labour supply\n        N = 1 - (b1[i]) / w\n\n        # (4) Consumption demand\n        C = (1 / (1 + b2 + b3)) * (Y - G0[i] + (Yf[i] - Gf) / (1 + r) - b1[i] * (b2 + b3) * np.log(b1[i] / w))\n\n        # (5) Investment demand, solved for r\n        r = (I**(a-1)) * a * A[i] * N**(1-a)\n\n        # (6) Goods market equilibrium condition, solved for I\n        I = Y - C - G0[i]\n\n        # (7) Nominal interest rate\n        rn = r + pe\n\n        # (8) Price level\n        P = (M0[i] * rn) / ((1 + rn) * b3 * C)\n\n    # Save results for different parameterizations in the arrays\n    Y_star[i] = Y\n    w_star[i] = w\n    C_star[i] = C\n    I_star[i] = I\n    r_star[i] = r\n    N_star[i] = N\n    P_star[i] = P\n    rn_star[i] = rn\n\n\n\n\nPlots\nFigures Figure 3.1 - Figure 3.3 depicts the model economy’s real activity under different scenarios. Monetary expansions (scenario 2) have no effects on output and employment, capturing the idea of money neutrality (Classical Dichotomy). However, the monetary expansion does raise the price level (see Figure 3.2 ), capturing the key idea of the Quantity Theory of Money that inflation is driven by a growing money supply.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.1: Output\n\n\n\n\n\nbarplot(P_star, ylab=\"P\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.2: Price level\n\n\n\n\nAn increase in government spending (by one unit) in scenario 3 does not raise employment and real output as these are fully determined by the supply side rather than aggregate demand.4 Looking at Figures Figure 3.4 and Figure 3.5, it can be seen that government spending crowds out private spending (consumption and investment). The decrease in consumption is a result of consumption smoothing via the Euler equation: the household anticipates higher taxes in the future and reduces current consumption somewhat to smooth out the impact. The increase in government expenditures also raises demand for loanable funds, which pushes up the real interest rate (see Figure 3.6) and reduces investment (Figure 3.5) and consumption. There is also an inflationary effect linked to the higher real interest rate, which raises the nominal interest rate and reduces the demand for money.\n\nbarplot(N_star, ylab=\"N\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.3: Employment\n\n\n\n\nImprovements to the supply-side are captured by an increase in productivity (scenario 4), which raises real output, employment, and aggregate demand. In contrast to expansionary government policy, the price level falls.\n\nbarplot(C_star, ylab=\"C\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.4: Consumption\n\n\n\n\n\nbarplot(I_star, ylab=\"I\",  names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.5: Investment\n\n\n\n\nA decrease in expected future income (scenario 5) has a small expansionary effect on aggregate output. This is because households will reduce some of their current consumption (see Figure 3.4 ) and supply more labour to smooth their consumption over time. The increase in saving reduces the real interest rate (see Figure 3.6 ) and is compensated by an increase in investment (see Figure 3.5 ).\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\",\"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 3.6: Interest rate\n\n\n\n\nFinally, an increase in the preference for leisure (scenario 6) reduces labour supply and thereby output.\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here for output only)\nimport matplotlib.pyplot as plt\n\nscenario_names = [\"1: Baseline\", \"2: Increase in M0\", \"3: Increase in G0\", \n                  \"4: Increase in A\", \"5: Decrease in Yf\", \"6: Increase in b1\"]\n\n# Output\nplt.bar(scenario_names , Y_star)\nplt.ylabel('Y')\nplt.xticks(rotation=45, ha=\"right\")  # Rotate x-axis labels for better readability\nplt.tight_layout()  # Ensure the labels fit within the plot area\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#directed-graph",
    "href": "a_neoclassical_macro_model.html#directed-graph",
    "title": "3  A Neoclassical Macro Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 13 variables: \n# Y w   N   C   I   r   P   rn M0   G0 A Yf Md\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,0,1,0,0,0,0,0,0,0,1,0,0,\n              0,0,1,0,0,0,0,0,0,0,1,0,0,\n              0,1,0,0,0,0,0,0,0,0,0,0,0,\n              1,1,0,0,0,1,0,0,0,1,0,1,0,\n              0,0,1,0,0,1,0,0,0,0,0,0,0,\n              1,0,0,1,1,0,0,0,0,1,0,0,0,\n              0,0,0,0,0,0,0,0,1,0,0,0,1,\n              0,0,0,0,0,1,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,1,0,0,1,1,0,0,0,0,0), 13, 13, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\",\"w\",\"N\",\"C\",\"I\",\"r\",\"P\", expression(r[n]), expression(M[0]),expression(G[0]),\"A\",expression(Y^f), expression(M[d]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 3.7: Directed graph\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Construct the auxiliary Jacobian matrix\nM_mat = np.array([\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0],\n    [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0]\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {\n    0: \"Y\",\n    1: \"w\",\n    2: \"N\",\n    3: \"C\",\n    4: \"I\",\n    5: \"r\",\n    6: \"P\",\n    7: r\"$r_n$\",\n    8: r\"$M_0$\",\n    9: r\"$G_0$\",\n    10: \"A\",\n    11: r\"$Y^f$\",\n    12: r\"$M_d$\"\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=42)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 3.7 , it can be seen that productivity (\\(A\\)), future income (\\(Y^f\\)), the money supply (\\(M_0\\)), and government spending (\\(G_0\\)) are the key exogenous variables of the model. All other variables are endogenous, and many of them form a closed loop (or cycle) within the system. The left part of the graph captures the supply side: the labour market simultaneously pins down the real wage and employment, which together with the exogenously level of productivity determine output. The part in the middle embodies the demand side: aggregate demand (consumption, investment, and government spending) together with a given level of output determine the real interest rate. The right part captures the nominal side of the model given by the money market, which determines the price level. Notably, while the real side of the model feeds into the money market via the nominal interest rate (\\(r_n\\)), there is not causal effect from the money market to the real side reflecting the Classical Dichotomy.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#analytical-discussion-derivation-of-behavioural-functions",
    "href": "a_neoclassical_macro_model.html#analytical-discussion-derivation-of-behavioural-functions",
    "title": "3  A Neoclassical Macro Model",
    "section": "Analytical discussion: derivation of behavioural functions",
    "text": "Analytical discussion: derivation of behavioural functions\nThe firm’s problem: profit maximisation\nThe firm’s profit equation is given by:\n\\[\n\\Pi=Y-w N-r k\n\\tag{3.12}\\]\n\\[\n=A K^a N^{1-a}-w N-r k .\n\\tag{3.13}\\]\nThe firm’s optimisation problem is to maximise profits using employment and capital as choice variables:5\n\\[\n\\max _{N, K} \\Pi=A K^a N^{1-a}-w N-r k .\n\\tag{3.14}\\]\nThe first-order conditions are given by:\n\\[\n(1-a) A K^a N^{-a}-w=0\n\\tag{3.15}\\]\n\\[\na A K^{a-1} N^{1-a}-r=0 .\n\\tag{3.16}\\]\nFrom Equation 3.15, Equation 3.2 for labour demand can be derived. While the capital stock is pre-determined in every period, the firm can adjust the capital stock through investment. We thus use the first-order condition for capital Equation 3.16 to derive Equation 3.5 for investment demand.\nThe government’s budget constraint\nThe government’s current and future budget constraints are given by:\n\\[\nG=T+B\n\\tag{3.17}\\]\n\\[\nG^f=T^f-(1+r) B\n\\tag{3.18}\\] where \\(T\\) is tax revenues and \\(B\\) is government debt.\nA crucial assumption here is that the government must repay its debts in the future (it cannot permanently roll over its debts). The underlying assumption is that the government will eventually ‘die’ and will do so without savings nor debt.\nCombining the two budget constraints to an intertemporal budget constraint yields:\n\\[\nG+\\frac{G^f}{1+r}=T+\\frac{T^f}{1+r}\n\\tag{3.19}\\]\nThus, while the government’s budget need not be balanced in every period, it will be balanced over time (in a present value sense).6\nThe household’s problem: intertemporal utility maximisation and Ricardian Equivalence\nThe household derives utility from current consumption, leisure (\\(1-N\\)), future consumption \\(C^f\\), and from holding real money balances \\(\\left(\\frac{M}{P}\\right)\\). We use the following log utility function that is non-separable in consumption and leisure:7\n\\[\nU=\\ln [C+ b_1 \\ln (1-N)]+b_2 \\ln \\left(C^f\\right)+b_3 \\ln \\left(\\frac{M}{P}\\right), \\quad b_2\\in (0,1); b_1, b_3&gt;0\n\\tag{3.20}\\]\nThe household’s current budget constraint is given by:8\n\\[\nC=Y-T-S-\\frac{M}{P}\n\\tag{3.21}\\]\nThe income that is not consumed can either be saved (\\(S\\)) at nominal interest rate (\\(r_n\\)) or held as money on which no return is earned.\nThe future budget constraint (assuming that households do not save in the future) is given by:\n\\[\nC^f = Y^f - T^f + (1+r_n)\\frac{PS}{P^f} + \\frac{M}{P^f}.\n\\tag{3.22}\\]\nUsing the Fisher equation \\((1+r)=(1+r_n)\\frac{P}{P^f}\\), the future budget constraint can be rewritten as:\n\\[\nC^f = Y^f  - T^f + (1+r)S + \\frac{(1+r)M}{(1+r_n)P}\n\\tag{3.23}\\]\nFinally, the two budget constraints can be combined to yield an intertemporal budget constraint:\n\\[\nC^f = (Y-C-T)(1+r)+Y^f -T^f - (1+r)\\frac{r_nM}{(1+r_n)P}.\n\\tag{3.24}\\]\nSubstituting the government’s intertemporal budget constraint, the household’s intertemporal budget constraint can also be written as:\n\\[\nC^f = (Y-C-G)(1+r)+Y^f -G^f - (1+r)\\frac{r_nM}{(1+r_n)P}\n\\tag{3.25}\\]\nThe fact that current and future tax payments are now replaced by current and future government spending means that it does not matter for the real economy how government spending is financed: the private sector will react to expenditures that are financed out of debt in the same way it reacts to expenditures financed out of taxation. This result is also known as Ricardian Equivalence. Put differently, Ricardian Equivalence means the household behaves as if the government balances its budget in every period.\nWith these ingredients, the household’s optimisation problem can be written as:\n\\[\n\\begin{array}{ll}\n\\max _{C, N, M} & U=\\ln (C+b_1 \\ln (1-N))+b_2 \\ln \\left(C^f\\right)+b_3 \\ln \\left(\\frac{M}{P}\\right), \\\\\n\\text { s.t. } & C^f= (Y-C-G)(1+r)+Y^f -G^f - (1+r)\\frac{r_nM}{(1+r_n)P} .\n\\end{array}\n\\]\nSubstituting the constraint Equation 3.25 for \\(C^f\\) in the utility function, and making use of the identity \\(Y=\\Pi+rK+Nw\\), allows to obtain the following first-order conditions:\n\\[\nC=\\frac{C^f}{b_2(1+r)} - b_1\\ln(1-N)\n\\tag{3.26}\\]\n\\[\n\\left(\\frac{b_1}{1-N}\\right)\\left(\\frac{1}{C+b_1\\ln(1-N)} \\right)=\\frac{b_2(1+r)w}{C^f}\n\\tag{3.27}\\]\n\\[\nM=\\frac{b_3PC^f(1+r_n)}{b_2(1+r)r_n} .\n\\tag{3.28}\\]\nSubstituting Equation 3.26, which is often also called the Euler equation, into Equation 3.27 and Equation 3.28 yields Equation 3.3 for labour supply and Equation 3.10 for money demand, respectively. Finally, using Equation 3.25 and Equation 3.28 in the Euler Equation 3.26 yields the consumption function Equation 3.4.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#references",
    "href": "a_neoclassical_macro_model.html#references",
    "title": "3  A Neoclassical Macro Model",
    "section": "References",
    "text": "References\n\n\n\n\nGarín, Julio, Robert Lester, and Eric Sims. 2021. Intermediate Macroeconomics. Draft Version 3.0.1. https://juliogarin.com/files/textbook/GLS_Intermediate_Macro.pdf.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_macro_model.html#footnotes",
    "href": "a_neoclassical_macro_model.html#footnotes",
    "title": "3  A Neoclassical Macro Model",
    "section": "",
    "text": "See the analytical discussion below for a derivation of equations Equation 3.2 -Equation 3.5 and Equation 3.10 from optimising microfoundations.↩︎\nHouseholds are assumed to form rational expectations. In a deterministic setting, this implies perfect foresight so that expected and actual future income coincide.↩︎\nSee the analytical discussion below for more details on Ricardian Equivalence.↩︎\nThis result is partly driven by the use of a non-separable utility function, see analytical discussion below. With a separable utility function, the increase in government spending would increase labour supply and thereby have effects on employment and output.↩︎\nSee Garín, Lester, and Sims (2021, chap. 12) for a more elaborate version where the firm maximises its lifetime value. The resulting investment function is very similar.↩︎\nSee Garín, Lester, and Sims (2021, chap. 13) for a more detailed discussion of the government’s budget constraints.↩︎\nSee Garín, Lester, and Sims (2021), pp.280-289), on the differences between a separable and a non-separable preference specification. Note also that for simplicity, the utility function omits the utility from future leisure.↩︎\nSee Garín, Lester, and Sims (2021, chap. 14) for a more detailed discussion of the household’s budget constraints.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A Neoclassical Macro Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html",
    "href": "an_IS_LM_model.html",
    "title": "4  An IS-LM Model",
    "section": "",
    "text": "Overview\nThe IS-LM model was developed by John R. Hicks (1937) to formalise some key ideas of John Maynard Keynes’ 1936 book The General Theory of Employment, Interest and Money. The model contains two equilibrium relationships: a goods market equilibrium between investment and saving (IS) and a money market equilibrium between money demand and money supply (LM). In the goods market, aggregate supply adjusts to the level of aggregate demand given by the expenditure decisions of households, firms, and the government. Households form their consumption demand based on a constant marginal propensity to consume out of income. Firms take investment decisions based on the rate of interest. Money demand is determined by aggregate income (transactions demand) and the interest rate on bonds (speculative demand). The money supply is assumed to be exogenous and under the control of the central bank. The two markets pin down equilibrium output and the interest rate. The goods market equilibrium may well coincide with involuntary unemployment. Adverse shocks to autonomous investment (‘animal spirits’) or autonomous money demand (‘liquidity preference’) reduce output and raise unemployment. The government can use monetary policy, fiscal spending, and income taxes to stimulate economic activity and achieve full employment.\nIn this short-run model, prices and the capital stock are fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is static. We consider a version with linear functions, adapted from Blanchard and Johnson (2013, chap. 5).",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#the-model",
    "href": "an_IS_LM_model.html#the-model",
    "title": "4  An IS-LM Model",
    "section": "The Model",
    "text": "The Model\n\\[\nY=C+I+G\n\\tag{4.1}\\]\n\\[\nC=c_{0}+c_{1}(Y-T), \\quad c_{1} \\in(0,1)\n\\tag{4.2}\\]\n\\[\nI=i_{0}-i_{1} r, \\quad i_{1}&gt;0\n\\tag{4.3}\\]\n\\[\nG=G_{0}\n\\tag{4.4}\\]\n\\[\nT=T_{0}\n\\tag{4.5}\\]\n\\[\nM_{s}=M_{0}\n\\tag{4.6}\\]\n\\[\nM_{d}=m_{0}+m_{1} Y-m_{2} r, \\quad m_{1}&gt;0\n\\tag{4.7}\\]\n\\[\nM=M_{d}=M_{s}\n\\tag{4.8}\\]\n\\[\nN=a Y, \\quad a&gt;0\n\\tag{4.9}\\]\n\\[\nU=1-\\frac{N}{N^{f}}\n\\tag{4.10}\\]\nwhere \\(Y\\), \\(C\\), \\(I\\), \\(G\\), \\(T\\), \\(r\\), \\(M_{d}\\), \\(M_{s}\\), \\(N\\), \\(U\\) and \\(N^{f}\\) are output, consumption, investment, government spending, taxes, the interest rate on bonds, money demand, money supply, employment, the unemployment rate, and the labour force, respectively. The constant price level has been normalised to unity.\nEquation 4.1 is the goods market equilibrium condition. Aggregate supply \\((Y)\\) accommodates to the level of aggregate demand which is the sum of consumption, investment, and government spending. Equation 4.2 is the consumption function consisting of autonomous consumption demand \\(\\left(c_{0}\\right)\\) and a marginal propensity to consume \\(\\left(c_{1}\\right)\\) out of disposable income \\((Y-T)\\). Investment demand in Equation 4.3 has an autonomous component \\(\\left(i_{0}\\right)\\) capturing Keynesian animal spirits and a component that is negatively related to the rate of interest on bonds. By equations Equation 4.4 and Equation 4.5, government spending and taxation are exogenous. Similarly, the money supply in Equation 4.6 is assumed to be exogenous. By Equation 4.7, households’ money demand is positively related to income (capturing the transaction demand for money) and negatively related to the interest rate on bonds (capturing speculative demand). There is also an autonomous term \\(\\left(m_{0}\\right)\\) capturing Keynesian liquidity preference. Equation 4.9 is a fixed-coefficient production function through which employment is determined. In conjunction with an exogenously given labour force \\(\\left(N^{f}\\right)\\), the level of employment can be used to obtain an unemployment rate in Equation 4.10.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#simulation",
    "href": "an_IS_LM_model.html#simulation",
    "title": "4  An IS-LM Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenarios 2 and 3 model a switch towards pessimistic sentiments: a fall in animal spirits \\(\\left(i_{0}\\right)\\) and an increase in liquidity preference \\(\\left(m_{0}\\right)\\). Scenarios 4 to 6 consider three different government policies to stimulate the economy: a monetary expansion \\(\\left(M_{0}\\right)\\), a tax cut \\(\\left(T_{0}\\right)\\), and a fiscal expansion \\(\\left(G_{0}\\right)\\).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(c_{0}\\)\n\\(c_{1}\\)\n\\(i_{0}\\)\n\\(i_{1}\\)\n\\(m_{0}\\)\n\\(m_{1}\\)\n\\(m_{2}\\)\n\\(M_{0}\\)\n\\(T_{0}\\)\n\\(G_{0}\\)\n\\(a\\)\n\\(N^{f}\\)\n\n\n\n1: baseline\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n5\n1\n1\n1.5\n18\n\n\n2: fall in animal spirits (\\(i_{0}\\))\n2\n0.6\n1\n0.1\n6\n0.2\n0.4\n5\n1\n1\n1.5\n18\n\n\n3: increased liquidity preference (\\(m_{0}\\))\n2\n0.6\n2\n0.1\n7\n0.2\n0.4\n5\n1\n1\n1.5\n18\n\n\n4: monetary expansion (\\(M_{0}\\))\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n6\n1\n1\n1.5\n18\n\n\n5: tax cut (\\(T_{0}\\))\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n5\n0\n1\n1.5\n18\n\n\n6: fiscal expansion (\\(G_{0}\\))\n2\n0.6\n2\n0.1\n6\n0.2\n0.4\n5\n1\n2\n1.5\n18\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S) # Income/output\nC_star=vector(length=S) # Consumption\nI_star=vector(length=S) # Investment\nr_star=vector(length=S) # Real interest rate\nN_star=vector(length=S) # Employment\nU_star=vector(length=S) # Unemployment rate\n\n# Set exogenous variables that will be shifted\ni0=vector(length=S) # autonomous investment\nm0=vector(length=S) # Autonomous demand for money\nM0=vector(length=S) # money supply\nG0=vector(length=S) # government spending\nT0=vector(length=S) # taxes\ni0[]=2\nm0[]=6\nM0[]=5   \nG0[]=1   \nT0[]=1\n\n## Construct scenarios\n# scenario 2: fall in animal spirits\ni0[2]=1\n \n#scenario 3: increase in liquidity preference\nm0[3]=7\n\n# scenario 4: monetary expansion \nM0[4]=6\n\n# scenario 5: reduction in tax rate\nT0[5]=0  \n\n# scenario 6: fiscal expansion\nG0[6]=2 \n\n#Set constant parameter values\nc0=2   # Autonomous consumption\nc1=0.6 # Sensitivity of consumption with respect to the income (marginal propensity to consume)\ni1=0.1 # Sensitivity of investment with respect to the interest rate\nm1=0.2 # Sensitivity of money demand with respect to income\nm2=0.4 # Sensitivity of money demand with respect to interest rate\na=1.5  # labour coefficient\nNf=18  # Full employment/labour force\n\n# Initialise endogenous variables at some arbitrary positive value \nY = C = I =r = N = U = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\n\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #Model equations\n    \n    # Goods market equilibrium\n    Y = C + I + G0[i]\n    \n    # Consumption demand\n    C = c0 + c1*(Y-T0[i])\n    \n    # Investment demand\n    I = i0[i] - i1*r\n    \n    # Money market, solved for interest rate\n    r = (m0[i] - M0[i])/m2 + m1*Y/m2\n    \n    # Employment\n    N = a*Y \n    \n    #Unemployment rate\n    U = (1 - N/Nf)\n    \n  }\n  #Save results for different parameterisations in vector\n  Y_star[i]=Y\n  C_star[i]=C\n  I_star[i]=I\n  r_star[i]=r\n  N_star[i]=N\n  U_star[i]=U\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions from different parameterizations\nY_star = np.empty(S)  # Income/output\nC_star = np.empty(S)  # Consumption\nI_star = np.empty(S)  # Investment\nr_star = np.empty(S)  # Real interest rate\nN_star = np.empty(S)  # Employment\nU_star = np.empty(S)  # Unemployment rate\n\n# Set exogenous variables that will be shifted\ni0 = np.zeros(S)  # Autonomous investment\nm0 = np.zeros(S)  # Autonomous demand for money\nM0 = np.zeros(S)  # Money supply\nG0 = np.zeros(S)  # Government spending\nT0 = np.zeros(S)  # Taxes\n\n# Baseline parameterisation\ni0[:] = 2\nm0[:] = 6\nM0[:] = 5\nG0[:] = 1\nT0[:] = 1\n\n# Construct scenarios\n# scenario 2: fall in animal spirits\ni0[1] = 1\n\n# scenario 3: increase in liquidity preference\nm0[2] = 7\n\n# scenario 4: monetary expansion\nM0[3] = 6\n\n# scenario 5: reduction in tax rate\nT0[4] = 0\n\n# scenario 6: fiscal expansion\nG0[5] = 2\n\n# Set constant parameter values\nc0 = 2  # Autonomous consumption\nc1 = 0.6  # Sensitivity of consumption with respect to income (marginal propensity to consume)\ni1 = 0.1  # Sensitivity of investment with respect to the interest rate\nm1 = 0.2  # Sensitivity of money demand with respect to income\nm2 = 0.4  # Sensitivity of money demand with respect to the interest rate\na = 1.5  # labor coefficient\nNf = 18  # Full employment/labor force\n\n# Initialize endogenous variables at some arbitrary positive value\nY = C = I =r = N = U = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # Model equations\n\n        # Goods market equilibrium\n        Y = C + I + G0[i]\n\n        # Consumption demand\n        C = c0 + c1 * (Y - T0[i])\n\n        # Investment demand\n        I = i0[i] - i1 * r\n\n        # Money market, solved for interest rate\n        r = (m0[i] - M0[i]) / m2 + m1 * Y / m2\n\n        # Employment\n        N = a * Y\n\n        # Unemployment rate\n        U = 1 - N / Nf\n\n    # Save results for different parameterizations in the arrays\n    Y_star[i] = Y\n    C_star[i] = C\n    I_star[i] = I\n    r_star[i] = r\n    N_star[i] = N\n    U_star[i] = U\n    \n\n\n\n\nPlots\nFigure 18.2 and Figure 4.2 depict the response of the model’s key endogenous variables, output and the interest rate, to various shifts. A fall in animal spirits (scenario 2) and an increase in liquidity preference (scenario 3) both have contractionary effects. While the fall in animal spirits directly reduces aggregate demand and thereby output (despite a fall in the interest rate), the rise in liquidity preference depresses output through its positive effect on the interest rate. Both scenarios raise the unemployment rate (Figure 4.3). Scenarios 4 to 6 assess three different macroeconomic policy tools to stimulate output. It can be seen in Figure 18.2 that fiscal policy is more effective than monetary policy for the parameterisation in Table 1.1 Direct fiscal stimulus is more effective than tax cuts due to the constant marginal propensity to consume. The effect on output is a multiple of the one-unit stimulus thanks to the multiplier effect. However, it can also be seen that fiscal policy raises the interest rate, which crowds out some of the expansionary effect.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.1: Output\n\n\n\n\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.2: Interest rate\n\n\n\n\n\nbarplot(U_star*100, ylab=\"U (%)\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                              \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.3: Unemployment\n\n\n\n\nFigure 4.4 and Figure 4.5 further show that monetary policy mostly stimulates investment, whereas fiscal policy boost consumption.\n\nbarplot(I_star, ylab=\"I\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.4: Investment\n\n\n\n\n\nbarplot(C_star, ylab=\"C\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                                      \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.5: Consumption\n\n\n\n\n\nbarplot(N_star, ylab=\"N\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\", \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 4.6: Employment\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for output)    \nimport matplotlib.pyplot as plt\n\nscenario_names = [\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise liq. pref.\",\n                  \"4:Monetary exp.\", \"5:Tax cut\", \"6:Fiscal exp.\"]\n\nplt.bar(scenario_names, Y_star)\nplt.ylabel('Y')\nplt.xticks( scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#directed-graph",
    "href": "an_IS_LM_model.html#directed-graph",
    "title": "4  An IS-LM Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_{1}\\) to node \\(x_{2}\\) indicates a causal impact of \\(x_{1}\\) on \\(x_{2}\\).\n\n# Construct auxiliary Jacobian matrix for 11 variables: Y, C, I, G, T, r, M0, N, i0, m0, Md\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,1,1,1,0,0,0,0,0,0,0,\n              1,0,0,0,1,0,0,0,0,0,0,\n              0,0,0,0,0,1,0,0,1,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,1,0,0,0,1,\n              0,0,0,0,0,0,0,0,0,0,0,\n              1,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              0,0,0,0,0,0,0,0,0,0,0,\n              1,0,0,0,0,1,0,0,0,1,0), 11, 11, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(G[0]), expression(T[0]), \"r\", expression(M[0]), \"N\", expression(i[0]), expression(m[0]), expression(M[d]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 4.7: Directed graph of IS-LM model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the auxiliary Jacobian matrix\nM_mat = np.array([\n    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n\n# Define node labels\nnodelabs = {\n    0: \"Y\",\n    1: \"C\",\n    2: \"I\",\n    3: r\"$G_0$\",\n    4: r\"$T_0$\",\n    5: \"r\",\n    6: r\"$M_0$\",\n    7: \"N\",\n    8: r\"$i_0$\",\n    9: r\"$m_0$\",\n    10: r\"$M_d$\"\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#analytical-discussion",
    "href": "an_IS_LM_model.html#analytical-discussion",
    "title": "4  An IS-LM Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo obtain the IS-curve, substitute Equation 4.2 - Equation 4.5 into Equation 4.1 and solve for \\(Y\\):\n\\[\nY=\\left(\\frac{1}{1-c_1}\\right)(c_0 + i_0 + G_0 - i_1r - c_1 T_0).\n\\tag{4.11}\\]\nTo obtain the LM-curve, substitute Equation 4.6 - Equation 4.7 into Equation 4.8 and solve for \\(r\\):\n\\[\nr=\\left(\\frac{1}{m_2}\\right)(m_0 - M_0 + m_1Y).\n\\tag{4.12}\\]\nFinally, to obtain equilibrium solutions for \\(Y\\) and \\(r\\), substitute Equation 4.12 into Equation 4.11 and vice versa:\n\\[\nY^*=\\left[\\frac{m_2}{(1-c_1)m_2+i_1m_1}\\right](c_0 + i_0 + G_0 - c_1 T_0) + \\left[\\frac{i_1}{(1-c_1)m_2+i_1m_1}\\right](M_0-m_0)\n\\]\n\\[\nr^*= \\left[\\frac{1-c_1}{(1-c_1)m_2+i_1m_1}\\right](m_0-M_0)+\\left[\\frac{m_1}{(1-c_1)m_2+i_1m_1}\\right](c_0+i_0+G_0-c_1T_0).\n\\]\nFrom this, the following results can be obtained:\n\nThe equilibrium effects of a change in taxes are smaller than those from a change in government spending (since \\(c_1\\) is smaller than one).\nGovernment spending is more effective than monetary expansion if \\(m_2 &gt; i_1\\) (which is the case for the parameterisation in Table 1.\nThe equilibrium multiplier \\(\\left[\\frac{m_2}{(1-c_1)m_2+i_1m_1}\\right]\\) is smaller than the aggregate demand multiplier \\(\\left(\\frac{1}{1-c_1}\\right)\\) due to the positive effect on the interest rate and the corresponding negative effect investment (\\(i_1m_1\\)). This is the crowding out mechanism.\n\nCalculate equilibrium fiscal multiplier\n\nY_star[6]-Y_star[1] # numerical approach\n\n[1] 2.222222\n\nm2/((1-c1)*m2+i1*m1) # analytical approach\n\n[1] 2.222222\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nY_star[5]-Y_star[0] # numerical approach\n\nm2/((1-c1)*m2+i1*m1) # analytical approach",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#references",
    "href": "an_IS_LM_model.html#references",
    "title": "4  An IS-LM Model",
    "section": "References",
    "text": "References\n\n\n\n\nBlanchard, Olivier, and David R. Johnson. 2013. Macroeconomics, 6th Edition. Pearson.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "an_IS_LM_model.html#footnotes",
    "href": "an_IS_LM_model.html#footnotes",
    "title": "4  An IS-LM Model",
    "section": "",
    "text": "The analytical discussion below shows formally that fiscal policy is more effective than monetary policy if \\(m_{2}&gt;i_{2}\\).↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>An IS-LM Model</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "",
    "text": "Overview\nThe Neoclassical Synthesis was developed in the 1940s and 1950s by Franco Modigliani, Paul Samuelson and others. It introduced neoclassical components into the Keynesian IS-LM model that had been proposed by John R. Hicks (1937) to formalise some key ideas of John Maynard Keynes’ 1936 book The General Theory of Employment, Interest and Money. The IS-LM model, which is analysed in detail in Chapter 4, contains two equilibrium relationships: a goods market equilibrium between investment and saving (IS) and a money market equilibrium between money demand and money supply (LM). In the goods market, aggregate supply adjusts to the level of aggregate demand given by the expenditure decisions of households, firms, and the government. Money demand is determined by aggregate income and the interest rate on bonds. The money supply is assumed to be exogenous. The two markets pin down equilibrium output and the interest rate.\nThe Neoclassical Synthesis adds a neoclassical labour market with Keynesian frictions to the IS-LM model. Following the discussion in Froyen (2005), chap. 9, we consider a labour market in which firms have perfect information about the real wage, whereas workers need to form expectations about the price level. Price expectations are assumed to be exogenous in the short run. Workers thus suffer from `money illusion’: an increase in the actual price levels reduces the real wage but leaves their labour supply unchanged. This gives rise to an upward-sloping aggregate supply (AS) (or Phillips) curve. By contrast, the aggregate demand (AD) curve is downward-sloping as a higher price level increases the demand for real money balances, which pushes up the interest rate.\nIn this short-run model, prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is static. We consider a version with a Cobb-Douglass production function and otherwise linear behavioural functions, based on the graphical analysis in Froyen (2005), chap. 9.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#the-model",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#the-model",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "The Model",
    "text": "The Model\n\\[\nY=C+I+G_0\n\\tag{5.1}\\]\n\\[\nC=c_0+c_1(Y-T_0), \\quad c_1 \\in (0,1)\n\\tag{5.2}\\]\n\\[\nI= i_0 - i_1r,  \\quad i_1 &gt; 0\n\\tag{5.3}\\]\n\\[\nM_s=M_0\n\\tag{5.4}\\]\n\\[\n\\frac{M_d}{P}=m_0 + m_1Y -m_2r, \\quad m_1, m_2 &gt; 0\n\\tag{5.5}\\]\n\\[\nM_d(r)=M_s\n\\tag{5.6}\\]\n\\[\nw=(1-a)AK^aN^{-a} ,\\quad a\\in (0,1)\n\\tag{5.7}\\]\n\\[\nW=\\frac{P^ebC}{1-\\frac{N}{N^f}},  \\quad b \\in (0,1)\n\\tag{5.8}\\]\n\\[\nP=\\frac{W}{w}\n\\tag{5.9}\\]\n\\[\nN=\\left( \\frac{Y}{AK^{a}}\\right)^{\\frac{1}{1-a}}\n\\tag{5.10}\\]\n\\[\nU=1-\\frac{N}{N^f}\n\\tag{5.11}\\]\nwhere \\(Y\\), \\(C\\), \\(I\\), \\(G_0\\), \\(T_0\\), \\(r\\), \\(M_s\\), \\(M_d\\), \\(w\\), \\(A\\), \\(K\\), \\(N\\), \\(W\\), \\(P^e\\) \\(N^f\\), \\(P\\), and \\(U\\) are output, consumption, investment, (exogenous) government spending, (exogenous) taxes, the real interest rate on bonds, nominal money supply, nominal money demand, the real wage, productivity, the capital stock, employment, the nominal wage, the price level expected by workers, the labour force (or total available time for work), the actual price level, and the unemployment rate, respectively.\nEquation 5.1 is the goods market equilibrium condition. Aggregate supply (\\(Y\\)) accommodates to the level of aggregate demand which is the sum of consumption, investment, and government spending. Equation 5.2 is the consumption function consisting of autonomous consumption demand (\\(c_0\\)) and a marginal propensity to consume (\\(c_1\\)) out of disposable income (\\(Y-T_0\\)). Investment demand in Equation 5.3 has an autonomous component (\\(i_0\\)) capturing Keynesian animal spirits and a component that is negatively related to the rate of interest on bonds. Government spending and taxation are exogenous. Similarly, the nominal money supply (\\(M_0\\)) in Equation 5.4 is assumed to be exogenous. By Equation 5.5, households’ real money demand is positively related to income (capturing the transaction demand for money) and negatively related to the interest rate on bonds (capturing speculative demand). There is also an autonomous term (\\(m_0\\)) capturing Keynesian liquidity preference. Equilibrium in the money market Equation 5.6 yields an equation for the interest rate.\nIn Equation 5.7, the real wage is determined by the marginal product of labour implied by a Cobb-Douglass production function (\\(Y=AK^aN^{1-a}\\)). This means the real wage is always consistent with firms’ demand for labour based on profit-maximisation.1 Equation 5.8 specifies the nominal wage as implied by households’ labour supply curve. Optimising households supply labour based on their work-leisure trade-off (with the parameter \\(b\\) capturing their preference for leisure, \\(1-\\frac{N}{N^f}\\)). Since they don’t have knowledge of the current real wage, they base their decisions on the expected price level \\(P^e\\), which is exogenous in the short run. The actual price level is then given by the ratio of the nominal wage to the real wage Equation 5.9. In other words, firms set prices such that the nominal wage they pay to workers are consistent with their own desired real wage. Equation 5.10 pins down employment as implied by the Cobb-Douglass production function. In conjunction with an exogenously given labour force \\(N^f\\) (or total available labour time), the level of employment can be used to obtain an unemployment rate in Equation 5.11.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#simulation",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#simulation",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenario 2 is a switch towards pessimistic sentiments in the form of a fall in animal spirits (\\(i_0\\)). In scenario 3, productivity (\\(A\\)) increases. Scenario 4 considers a rise in the price level expected by workers (\\(P^e\\)). Scenarios 5 and 6 consider two different government policies to stimulate the economy: a monetary expansion (\\(M_0\\)) and a fiscal expansion (\\(G_0\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(c_0\\)\n\\(c_1\\)\n\\(i_0\\)\n\\(i_1\\)\n\\(A\\)\n\\(P^e\\)\n\\(m_0\\)\n\\(m_1\\)\n\\(m_2\\)\n\\(M_0\\)\n\\(G_0\\)\n\\(T_0\\)\n\\(N^f\\)\n\\(a\\)\n\\(b\\)\n\n\n\n1: baseline\n2\n0.6\n2\n0.1\n2\n1\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n2: fall in animal spirits (\\(i_0\\))\n2\n0.6\n1.5\n0.1\n2\n1\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n3: rise in productivity (\\(A\\))\n2\n0.6\n2\n0.1\n3\n1\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n4: rise in expected price level (\\(P^e\\))\n2\n0.6\n2\n0.1\n2\n1.5\n6\n0.2\n0.4\n5\n1\n1\n7\n0.3\n0.4\n\n\n5: monetary expansion (\\(M_0\\))\n2\n0.6\n2\n0.1\n2\n1\n6\n0.2\n0.4\n6\n1\n1\n7\n0.3\n0.4\n\n\n6: fiscal expansion (\\(G_0\\))\n2\n0.6\n2\n0.1\n2\n1\n6\n0.2\n0.4\n5\n2\n1\n7\n0.3\n0.4\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S) # Income/output\nC_star=vector(length=S) # Consumption\nI_star=vector(length=S) # Investment\nr_star=vector(length=S) # Real interest rate\nN_star=vector(length=S) # Employment\nU_star=vector(length=S) # Unemployment rate\nP_star=vector(length=S) # Price level\nw_star=vector(length=S) # Real wage\nW_star=vector(length=S) # Nominal wage\n\n# Set exogenous variables that will be shifted\ni0=vector(length=S) # autonomous investment (animal spirits)\nM0=vector(length=S) # money supply\nG0=vector(length=S) # government spending\nP0=vector(length=S) # expected price level\nA=vector(length=S)  # Exogenous productivity\n\n### Construct different scenarios\n# baseline \nA[]=2  \ni0[]=2\nM0[]=5   \nG0[]=1   \nP0[]=1\n\n# scenario 2: fall in animal spirits\ni0[2]=1.5\n\n# scenario 3: increase in productivity\nA[3]=3\n\n# scenario 4: increase in expected price level\nP0[4]=1.5  \n   \n# scenario 5: monetary expansion \nM0[5]=6\n\n# scenario 6: fiscal expansion\nG0[6]=2  \n    \n#Set constant parameter values\nc0=2   # Autonomous consumption\nc1=0.6 # Sensitivity of consumption with respect to the income (marginal propensity to consume)\ni1=0.1 # Sensitivity of investment with respect to the interest rate\nm1=0.2 # Sensitivity of money demand with respect to income\nm2=0.4 # Sensitivity of money demand with respect to interest rate\nNf=5   # Full employment/labour force\nK=4    # Exogenous capital stock\na=0.3  # Capital elasticity of output\nb=0.4  # household preference for leisure\nT0=1   # tax revenues\nm0=6   # liquidity preference\n\n# Initialise endogenous variables at some arbitrary positive value \nY = C = I = r = P = w = N = W = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\n\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #Model equations\n    \n    # Goods market equilibrium\n    Y = C + I + G0[i]\n    \n    # Consumption demand\n    C = c0 + c1*(Y-T0)\n    \n    # Investment demand\n    I = i0[i] - i1*r\n    \n    # Money market, solved for interest rate\n    r = (m0 - (M0[i]/P))/m2 + m1*Y/m2\n    \n    #Unemployment rate\n    U = (1 - N/Nf)\n    \n    #Real wage \n    w = A[i]*(1-a)*(K^a)*N^(-a)\n    \n    #Nominal wage \n    W= (P0[i]*b*C)/(1- (N/Nf))\n    \n    #Price level \n    P = W/w\n    \n    #Employment \n    N = (Y/(A[i]*(K^a)))^(1/(1-a))\n\n}\n  \n  #Save results for different parameterisations in vector\n  Y_star[i]=Y\n  C_star[i]=C\n  I_star[i]=I\n  r_star[i]=r\n  N_star[i]=N\n  U_star[i]=U\n  P_star[i]=P\n  w_star[i]=w\n  W_star[i]=W\n\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions from different parameterizations\nY_star = np.empty(S)  # Income/output\nC_star = np.empty(S)  # Consumption\nI_star = np.empty(S)  # Investment\nr_star = np.empty(S)  # Real interest rate\nN_star = np.empty(S)  # Employment\nU_star = np.empty(S)  # Unemployment rate\nP_star = np.empty(S)  # Price level\nw_star = np.empty(S)  # Real wage\nW_star = np.empty(S)  # Nominal wage\n\n# Set exogenous variables that will be shifted\ni0 = np.zeros(S)  # Autonomous investment (animal spirits)\nM0 = np.zeros(S)  # Money supply\nG0 = np.zeros(S)  # Government spending\nP0 = np.zeros(S)  # Expected price level\nA = np.empty(S)  # Exogenous productivity\n\n# Construct different scenarios\n# baseline\nA[:] = 2\ni0[:] = 2\nM0[:] = 5\nG0[:] = 1\nP0[:] = 1\n\n# scenario 2: fall in animal spirits\ni0[1] = 1.5\n\n# scenario 3: increase in productivity\nA[2] = 3\n\n# scenario 4: increase in expected price level\nP0[3] = 1.5\n\n# scenario 5: monetary expansion\nM0[4] = 6\n\n# scenario 6: fiscal expansion\nG0[5] = 2\n\n# Set constant parameter values\nc0 = 2  # Autonomous consumption\nc1 = 0.6  # Sensitivity of consumption with respect to income (marginal propensity to consume)\ni1 = 0.1  # Sensitivity of investment with respect to the interest rate\nm1 = 0.2  # Sensitivity of money demand with respect to income\nm2 = 0.4  # Sensitivity of money demand with respect to interest rate\nNf = 5  # Full employment/labor force\nK = 4  # Exogenous capital stock\na = 0.3  # Capital elasticity of output\nb = 0.4  # Household preference for leisure\nT0 = 1  # Tax revenues\nm0 = 6  # Liquidity preference\n\n# Initialize endogenous variables at some arbitrary positive value\nY = C = I = r = P = w = N = W = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # Model equations\n\n        # Goods market equilibrium\n        Y = C + I + G0[i]\n\n        # Consumption demand\n        C = c0 + c1 * (Y - T0)\n\n        # Investment demand\n        I = i0[i] - i1 * r\n\n        # Money market, solved for interest rate\n        r = (m0 - (M0[i] / P)) / m2 + m1 * Y / m2\n\n        # Unemployment rate\n        U = 1 - N / Nf\n\n        # Real wage\n        w = A[i] * (1 - a) * (K ** a) * (N ** (-a))\n\n        # Nominal wage\n        W = (P0[i] * b * C) / (1 - (N / Nf))\n\n        # Price level\n        P = W / w\n\n        # Employment\n        N = (Y / (A[i] * (K ** a))) ** (1 / (1 - a))\n\n    # Save results for different parameterizations in the arrays\n    Y_star[i] = Y\n    C_star[i] = C\n    I_star[i] = I\n\n\n\n\nPlots\nFigures Figure 18.2 - Figure 5.5 depict the response of the model’s key endogenous variables to various shifts. A fall in animal spirits (scenario 2) reduces aggregate demand and thereby output and employment (despite a fall in the interest rate). This reduces workers’ nominal wage demands and thus the price level. An increase in productivity (scenario 3) has expansionary effects on output but adverse effects on employment. Higher productivity means that fewer workers need to be hired to produce the same level of output. However, the corresponding reduction in employment also reduces the price level, which lowers the (real) demand for money and thus lowers the interest rate. This has expansionary effects on output.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.1: Output\n\n\n\n\n\nbarplot(P_star, ylab=\"P\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.2: Price level\n\n\n\n\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.3: Interest rate\n\n\n\n\nA rise in the expected price level (scenario 4) raises nominal wages and thereby the actual price level. This raises the interest rate, which exerts a (small) contractionary effect on output and employment. Scenarios 5 and 6 assess two different macroeconomic policy tools to stimulate output. A monetary expansion lowers the interest rate and increases output but also the price level. Similar results arise for a fiscal expansion. The main difference is that the monetary expansion lowers the interest rate, whereas the fiscal expansion increases it. \\\n\nbarplot(U_star*100, ylab=\"U (%)\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                              \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.4: Unemployment rate\n\n\n\n\n\nbarplot(W_star, ylab=\"W\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.5: Nominal wage\n\n\n\n\n\nbarplot(w_star, ylab=\"w\", names.arg=c(\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                                      \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 5.6: Real wage\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for output) \nimport matplotlib.pyplot as plt\n   \nscenario_names = [\"1:Baseline\", \"2:Fall animal spirits\", \"3:Rise product.\",\n                  \"4:Rise exp. price\", \"5:Monetary expan.\", \"6:Fiscal expan.\"]\n\nplt.bar(scenario_names, Y_star)\nplt.ylabel('Y')\nplt.xticks(scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#directed-graph",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#directed-graph",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 15 variables: Y, C, I, G, T, r, w, W, P, M0, N, i0, A, P0, Md\n\nM_mat=matrix(c(0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,\n               0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,\n               0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,\n               0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,1,0,0,1,0,0,0,0,0,0), 15, 15, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(G[0]), expression(T[0]), \"r\", \"w\", \"W\", \"P\", expression(M[0]), \"N\", expression(i[0]), \"A\", expression(P[0]), expression(M[d]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 5.7: Directed graph of Neoclassical Synthesis model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the Jacobian matrix\nM_mat = np.array([\n    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n\n# Define node labels\nnodelabs = {\n    0: \"Y\",\n    1: \"C\",\n    2: \"I\",\n    3: r\"$G_0$\",\n    4: r\"$T_0$\",\n    5: \"r\",\n    6: \"w\",\n    7: \"W\",\n    8: \"P\",\n    9: r\"$M_0$\",\n    10: \"N\",\n    11: r\"$i_0$\",\n    12: \"A\",\n    13: r\"$P_0$\",\n    14: r\"$M_d$\",\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 5.7, it can be seen that productivity (\\(A\\)), taxes (\\(T_0\\)), government spending (\\(G_0\\)), animal spirits (\\(i_0\\)), the money supply (\\(M_0\\)), and the expected price level (\\(P_0\\)) are the key exogenous variables of the model. All other variables are endogenous and form a closed loop (or cycle) within the system. The lower-left part of the graph captures the goods market (IS): aggregate demand (consumption, investment, and government spending) determines output. The upper part of the graph contains the labour market, which determines the price level. Finally, the lower-right part of the graph represents the money market (LM), which determines the interest rate. There is a two-way feedback between the goods market and the money market as output impacts the demand for money, and the interest rate affects investment. There is also a feedback from output into the labour market through employment. The labour market feeds into the money market via its effect on prices and thus money demand, which then also feeds into the goods market through the interest rate.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#analytical-discussion",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#analytical-discussion",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nIn the first step, we will reduce the system to three equations: an IS-curve, an LM-curve, and an AS-curve (or Phillips curve). In the second step, the IS-curve and the LM-curve are combined to yield an AD-curve.\nTo obtain the IS-curve, substitute Equation 5.2 -Equation 5.3 into Equation 5.1 and solve for \\(Y\\): \\[\\begin{align}\\label{eq:IS-AS_AD}\\tag{IS}\nY&=\\left(\\frac{1}{1-c_1}\\right)(c_0 + i_0 + G_0 - i_1r - c_1 T_0).\n\\end{align}\\]\nTo obtain the LM-curve, substitute Equation 5.4 - Equation 5.5 into Equation 5.6 and solve for \\(r\\):\n\\[\\begin{align}\\label{eq:LM-AS_AD}\\tag{LM}\nr&=\\left(\\frac{1}{m_2}\\right)(m_0 - \\frac{M_0}{P} + m_1Y).\n\\end{align}\\]\nTo obtain the AS-curve, substitute Equation 5.7, Equation 5.8, Equation 5.10, and Equation 5.2 into Equation 5.9:\n\\[\\begin{align}\\label{eq:AS}\\tag{AS}\nP&=\\frac{b(c_0-c_1T_0)+ P^ebc_1Y}{(1-a)\\left[\\left(AK^aY^{-a}\\right)^{\\frac{1}{1-a}} - \\frac{Y}{N^f}\\right]}.\n\\end{align}\\]\nIt can readily be seen that the AS-curve is upward-sloping in the \\((Y, P)\\)-space (recall that \\(a \\in (0,1)\\)).\nFinally, to obtain the AD-curve, substitute the LM-equation into the IS-equation:\n\\[\\begin{align}\\tag{AD}\nY&=\\left[\\frac{m_2(c_0 + i_0 + G_0 - c_1 T_0) + i_1(\\frac{M_0}{P}-m_0)}{(1-c_1)m_2+i_1m_1}\\right]\n\\end{align}\\]\nIt can readily be seen that the AD-curve is downward-sloping in the \\((Y, P)\\)-space.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#references",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#references",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "References",
    "text": "References\n\n\n\n\nFroyen, Richard T. 2005. Macroeconomics. Theories and Policies. 8th Edition. Pearson Education.\n\n\nHicks, A. R. 1937. “Mr. Keynes and the \"Classics\": A Suggested Interpretation.” Econometrica 5 (2): 147. https://doi.org/10.2307/1907242.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#footnotes",
    "href": "a_neoclassical_synthesis_model_IS_LM_AS_AD.html#footnotes",
    "title": "5  A Neoclassical Synthesis Model (IS-LM-AS-AD)",
    "section": "",
    "text": "See the notes on the Classical Model for a formal derivation of the labour demand and supply curves from optimisation. A minor modification is that here we work with a normalisation of the term for leisure in the household’s log-utility function, \\(\\ln(1-\\frac{N}{N^f})\\), to allow \\(N\\) to be larger than unity.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Neoclassical Synthesis Model (IS-LM-AS-AD)</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html",
    "title": "6  A Post-Keynesian Macro Model with Endogenous Money",
    "section": "",
    "text": "Overview\nPost-Keynesian Economics is an economic paradigm that was developed in the 1930s and 1940s by Joan Robinson, Nicholas Kaldor and others.1 The early post-Keynesian economists sought to develop further key ideas of John Maynard Keynes. They were critical of the Neoclassical Synthesis that introduced neoclassical elements into the Keynesian framework. Among many other points, post-Keynesians argued that money is created by commercial banks. Money creation is determined by the demand for credit rather than being under the control of the central bank, and should thus be considered endogenous. Post-Keynesians further assigned a key role to financial factors in the determination of economic activity, but also considered finance as a source of instability. They abandoned the neoclassical approach of deriving labour demand and supply from optimising behaviour and instead assumed oligopolistic market structures. Firms set prices by charging a mark-up on costs and workers set nominal wages based on their bargaining power.\nFontana and Setterfield (2009) present a simple model that could be regarded as a post-Keynesian alternative to the Neoclassical Synthesis. The model highlights the endogenous money creation process. Money is being created when commercial banks make loans to accommodate the demand for credit by creditworthy borrowers. The demand for credit is driven by aggregate demand. The interest rate on loans is determined by the base rate, set by the central bank, on which commercial banks charge a mark-up. Although credit creation is demand-driven, some borrowers will be credit constrained. In times of financial crises, banks tighten credit constraints, which can depress economic activity.\nIn this short-run model, prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. As all endogenous variables adjust instantaneously, the model is static. We consider a version of the model due to Fontana and Setterfield (2009) with linear functions.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#the-model",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#the-model",
    "title": "6  A Post-Keynesian Macro Model with Endogenous Money",
    "section": "The Model",
    "text": "The Model\n\\[\nY=ND+cD\n\\tag{6.1}\\]\n\\[\nND=bY, \\quad b \\in (0,1)\n\\tag{6.2}\\]\n\\[\nD= d_0 - d_1r, \\quad d_1 &gt; 0\n\\tag{6.3}\\]\n\\[\ni=i_0 + i_1P, \\quad i_1 &gt; 0\n\\tag{6.4}\\]\n\\[\nr=(1+m)i, \\quad m &gt; 0\n\\tag{6.5}\\]\n\\[\ndL=cD\n\\tag{6.6}\\]\n\\[\ndM=dL\n\\tag{6.7}\\]\n\\[\ndR=kdM, \\quad k \\in (0,1)\n\\tag{6.8}\\]\n\\[\nP=(1+n)aW, \\quad a,n &gt; 0\n\\tag{6.9}\\]\n\\[\nW=W_0 - hU, \\quad h &gt; 0\n\\tag{6.10}\\]\n\\[\nw=\\frac{1}{(1+n)a}\n\\tag{6.11}\\]\n\\[\nN=aY\n\\tag{6.12}\\]\n\\[\nU=1-\\frac{N}{N^f}\n\\tag{6.13}\\]\nwhere \\(Y\\), \\(ND\\), \\(D\\), \\(r\\), \\(i\\), \\(P\\), \\(dL\\), \\(dM\\), \\(dR\\), \\(W\\), \\(w\\), \\(N\\), \\(U\\), and \\(N^f\\) are output, the not debt-financed component of aggregate demand, the desired debt-financed component of aggregate demand, the lending rate, the policy rate, the price level, the change in loans, the change in money (bank deposits), the change in bank reserves, the nominal wage, the real wage, employment, the unemployment rate, and full employment (or total labour supply), respectively.\nEquation 6.1 is the goods market equilibrium condition. Aggregate supply (\\(Y\\)) accommodates to the level of aggregate demand which is the sum of a not debt-financed component (\\(ND\\)) and a (desired) debt-financed component (\\(D\\)). The coefficient \\(c\\) is the proportion of loan applications that are deemed creditworthy and thus captures credit rationing by banks. By Equation 6.2, the not debt-financed component of aggregate demand is a function of current income. In Equation 6.3, the debt-financed component of aggregate demand has an autonomous component (\\(d_0\\))2 and is otherwise negatively related to the lending rate \\(r\\). Equation 6.4 specifies the monetary policy rule, where it is assumed that the central bank raises the policy rate \\(i\\) when the price level increases.^[This specification is somewhat unrealistic given that most modern central banks target a positive rate of inflation. However, it allows for an AS-AD representation of the model, which facilitates the comparison with the Neoclassical Synthesis model (Chapter 5) The lending rate in Equation 6.5 is given by a mark-up \\(m\\) that banks charge on the policy rate (which is the rate at which they can borrow reserves). The change in loans in Equation 6.6 is equal to the creditworthy demand for loans (\\(cD\\)). This captures the demand-driven nature of credit creation. The changes in loans translates one-to-one into a change in money, which are bank deposits in this model (Equation 6.7). This reflects the endogenous money creation process where commercial banks create new deposits when they make new loans. By Equation 6.8, banks obtain new reserves from the central bank to maintain a constant reserve-to-deposit ratio \\(k\\). Thus, the causality in this model runs from debt-financed demand to loans, to deposits, and finally to reserves.\nBy Equation 6.9, the price level is set by firms based on a mark-up (\\(n\\)) on unit labour cost (which are the product of the nominal wage \\(W\\) and the labour coefficient \\(a\\)). Nominal wages are set by workers based on their bargaining power, which is declining in the unemployment rate (Equation 6.13). The real wage in Equation 6.11 is derived from the pricing Equation 6.9, i.e. through their price setting power, firms ultimately determine the real wage. The level of employment in Equation 6.12 is determined residually based on economic activity and a constant-coefficient production function \\((Y=\\frac{N}{a})\\). Finally, the level of employment in conjunction with an exogenously given labour force \\(N^f\\) (or total available labour time) can be used to obtain an unemployment rate in Equation 6.13.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#simulation",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#simulation",
    "title": "6  A Post-Keynesian Macro Model with Endogenous Money",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), five further scenarios will be considered. Scenario 2 is a rise in credit rationing in the form of a fall in \\(c\\). In scenario 3, autonomous credit-financed demand (\\(d_0\\)) increases. Scenarios 4 and 5 consider a rise in the interest rate (or bank) mark-up (\\(m\\)) and in the price (or firm) mark-up (\\(n\\)), respectively. Scenario 6 considers a rise in productivity reflected in a fall of the labour coefficient \\(a\\).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(b\\)\n\\(c\\)\n\\(d_0\\)\n\\(d_1\\)\n\\(i_0\\)\n\\(i1\\)\n\\(m\\)\n\\(k\\)\n\\(n\\)\n\\(W_0\\)\n\\(h\\)\n\\(a\\)\n\\(N^f\\)\n\n\n\n1: baseline\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n2: rise in credit rationing (\\(c\\))\n0.5\n0.4\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n3: rise in autonomous demand (\\(d_0\\))\n0.5\n0.8\n10\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n4: rise in bank mark-up (\\(m\\))\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.3\n0.3\n0.15\n2\n0.8\n0.8\n12\n\n\n5: rise in firm mark-up (\\(n\\))\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.3\n2\n0.8\n0.8\n12\n\n\n6: rise in productivity (\\(a\\))\n0.5\n0.8\n5\n0.8\n0.01\n0.5\n0.15\n0.3\n0.15\n2\n0.8\n0.4\n12\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baseline)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nY_star=vector(length=S)  # income/output\nD_star=vector(length=S)  # (notional) credit-financed aggregate demand\nND_star=vector(length=S) # income-financed aggregate demand\nr_star=vector(length=S)  # lending rate\nN_star=vector(length=S)  # employment\nU_star=vector(length=S)  # unemployment\nP_star=vector(length=S)  # price level\nw_star=vector(length=S)  # real wage\nW_star=vector(length=S)  # nominal wage\ni_star=vector(length=S)  # central bank rate\ndL_star=vector(length=S) # change in loans\ndM_star=vector(length=S) # change in bank deposits \ndR_star=vector(length=S) # change in bank reserves\n\n# Set exogenous variables that will be shifted\nc=vector(length=S) # share of credit demand that is accommodated\nd0=vector(length=S)# autonomous component of debt-financed aggregate demand\nm=vector(length=S) # mark-up on lending rate\nn=vector(length=S) # mark-up on prices\na=vector(length=S) # productivity\n\n# Baseline parameterisation\nc[]=0.8 \nd0[]=5\nm[]=0.15\nn[]=0.15  \na[]=0.8 \n\n## Construct scenarios\n\n# scenario 2: increase in credit rationing\nc[2]=0.4\n\n# scenario 3: increase in autonomous demand\nd0[3]=10\n\n# scenario 4: increase in interest rate mark-up\nm[4]=0.3\n\n# scenario 5: increase in price mark-up\nn[5]=0.3\n\n# scenario 6: increase in productivity\na[6]=0.4\n\n\n#Set constant parameter values\nb=0.5   # propensity to spend out of income\nd1=0.8  # sensitivity of demand with respect to the interest rate\ni0=0.01 # discretionary component of central bank rate\ni1=0.5  # sensitivity of central bank rate with respect to price level\nNf=12   # full employment/labour force\nh=0.8   # sensitivity of nominal wage with respect to unemployment\nk=0.3   # desired reserve ratio\nW0=2    # exogenous component of nominal wage\n\n# Initialise endogenous variables at some arbitrary positive value \nY = D = ND = r = N = U = P = w = W = i = dL = dR = dM = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (j in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #Model equations\n    \n    # (1) Goods market\n    Y = ND + c[j]*D\n    \n    # (2) Not-debt financed component of aggregate demand\n    ND = b*Y\n    \n    # (3) Debt-financed component of aggregate demand\n    D= d0[j] - d1*r\n    \n    # (4) Policy rate\n    i = i0 + i1*P\n    \n    # (5) Lending rate\n    r = (1+m[j])*i\n    \n    # (6) Change in loans\n    dL = c[j]*D\n    \n    # (7) Change in deposits\n    dM = dL\n    \n    # (8) Change in reserves\n    dR = k*dM\n    \n    # (9) Price level\n    P = (1+n[j])*a[j]*W\n    \n    # (10) Nominal wage\n    W = W0 - h*(U)\n    \n    # (11) Real wage\n    w = 1/((1+n[j])*a[j])\n    \n    # (12) Employment\n    N = a[j]*Y\n    \n    # (13) Unemployment rate\n    U = (Nf - N)/Nf\n    \n  }\n\n  #Save results for different parameterisations in vector\n  Y_star[j]=Y\n  D_star[j]=D\n  ND_star[j]=ND\n  r_star[j]=r\n  N_star[j]=N\n  U_star[j]=U\n  P_star[j]=P\n  w_star[j]=w\n  W_star[j]=W\n  i_star[j]=i\n  dL_star[j]=dL\n  dM_star[j]=dM\n  dR_star[j]=dR  \n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load NumPy library\nimport numpy as np\n\n# Set the number of scenarios (including baseline)\nS = 6\n\n# Create arrays to store equilibrium solutions\nY_star = np.zeros(S)  # income/output\nD_star = np.zeros(S)  # (notional) credit-financed aggregate demand\nND_star = np.zeros(S)  # income-financed aggregate demand\nr_star = np.zeros(S)  # lending rate\nN_star = np.zeros(S)  # employment\nU_star = np.zeros(S)  # unemployment\nP_star = np.zeros(S)  # price level\nw_star = np.zeros(S)  # real wage\nW_star = np.zeros(S)  # nominal wage\ni_star = np.zeros(S)  # central bank rate\ndL_star = np.zeros(S)  # change in loans\ndM_star = np.zeros(S)  # change in bank deposits\ndR_star = np.zeros(S)  # change in bank reserves\n\n# Set exogenous variables that will be shifted\nc = np.zeros(S)  # share of credit demand that is accommodated\nd0 = np.zeros(S)  # autonomous component of debt-financed aggregate demand\nm = np.zeros(S)  # mark-up on lending rate\nn = np.zeros(S)  # mark-up on prices\na = np.zeros(S)  # productivity\n\n# Baseline parameterisation\nc[:] = 0.8\nd0[:] = 5\nm[:] = 0.15\nn[:] = 0.15\na[:] = 0.8\n\n# Construct scenarios\n# Scenario 2: increase in credit rationing\nc[1] = 0.4\n\n# Scenario 3: increase in autonomous demand\nd0[2] = 10\n\n# Scenario 4: increase in interest rate mark-up\nm[3] = 0.3\n\n# Scenario 5: increase in price mark-up\nn[4] = 0.3\n\n# Scenario 6: increase in productivity\na[5] = 0.4\n\n# Set constant parameter values\nb = 0.5  # propensity to spend out of income\nd1 = 0.8  # sensitivity of demand with respect to the interest rate\ni0 = 0.01  # discretionary component of central bank rate\ni1 = 0.5  # sensitivity of central bank rate with respect to the price level\nNf = 12  # full employment/labour force\nh = 0.8  # sensitivity of nominal wage with respect to unemployment\nk = 0.3  # desired reserve ratio\nW0 = 2  # exogenous component of nominal wage\n\n# Initialize endogenous variables at some arbitrary positive value\nY = D = ND = r = N = U = P = w = W = i = dL = dR = dM = 1\n\n# Iterate through the system\nfor j in range(S):\n    for iteration in range(1000):\n        # Model equations\n        Y = ND + c[j] * D\n        ND = b * Y\n        D = d0[j] - d1 * r\n        i = i0 + i1 * P\n        r = (1 + m[j]) * i\n        dL = c[j] * D\n        dM = dL\n        dR = k * dM\n        P = (1 + n[j]) * a[j] * W\n        W = W0 - h * U\n        w = 1 / ((1 + n[j]) * a[j])\n        N = a[j] * Y\n        U = (Nf - N) / Nf\n\n    # Save results for different parameterizations in the vectors\n    Y_star[j] = Y\n    D_star[j] = D\n    ND_star[j] = ND\n    r_star[j] = r\n    N_star[j] = N\n    U_star[j] = U\n    P_star[j] = P\n    w_star[j] = w\n    W_star[j] = W\n    i_star[j] = i\n    dL_star[j] = dL\n    dM_star[j] = dM\n    dR_star[j] = dR\n\n\n\n\nPlots\nFigures Figure 6.1 - Figure 6.7 depict the response of the model’s key endogenous variables to various shifts.\n\nbarplot(Y_star, ylab=\"Y\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.1: Output\n\n\n\n\nAn increase in credit rationing (scenario 2) reduces deposit money creation as well as actual (as opposed to desired) aggregate demand. This drags down output and employment. The rise in unemployment reduces workers’ nominal wage demands and thus the price level. The lending rate falls as the central bank reduces the policy rate.\n\nbarplot(P_star, ylab=\"P\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.2: Price level\n\n\n\n\nAn increase in (debt-financed) autonomous demand (scenario 3) has expansionary effects on output and employment. The money stock accommodates through increased loan creation. The increase in workers’ bargaining power leads to higher nominal wages and prices. The central bank reacts by raising the policy rate but this does not completely offset the expansionary effect.\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.3: Lending rate\n\n\n\n\n\nbarplot(dM_star, ylab=\"dM\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                        \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.4: Deposit money creation\n\n\n\n\nIn scenarios 4 and 5, the interest rate (or bank) mark-up and the price (or firm) mark-up increase, respectively. The increase in the bank mark-up raises the lending rate, which has a contractionary effect. The increase in the firm mark-up raises the price level, which has a contractionary effect through the monetary policy response. Notably, the rise in the price mark-up reduces the real wage.\n\nbarplot(U_star*100, ylab=\"U (%)\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                              \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.5: Unemployment rate\n\n\n\n\n\nbarplot(W_star, ylab=\"W\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.6: Nominal wage\n\n\n\n\nFinally, an increase in productivity (scenario 6) reduces the price level, which induces a lower policy rate, leading to a small expansionary effect. However, it increases the unemployment rate as fewer workers are needed to produce the same level of output. This reduces the nominal wage, but raises the real wage.\n\nbarplot(w_star, ylab=\"w\", names.arg=c(\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\",\n                                      \"4:rise bank markup\",\"5:rise firm markup\", \"6:rise product.\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 6.7: Real wage\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here for output only)\nimport matplotlib.pyplot as plt\n\nscenario_names = [\"1:baseline\", \"2:rise credit rat.\", \"3:rise AD\", \"4:rise bank markup\", \"5:rise firm markup\", \"6:rise product\"]\n\n# Create a bar plot\nplt.bar(scenario_names, Y_star)\nplt.ylabel(\"Y\")\nplt.xticks(rotation=45, ha=\"right\")  # Rotate x-axis labels for better readability\nplt.tight_layout()  # Ensure the labels fit within the plot area\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#directed-graph",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#directed-graph",
    "title": "6  A Post-Keynesian Macro Model with Endogenous Money",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph \n# Construct auxiliary Jacobian matrix for 18 variables: \n# r, Y, ND, D, i, P, W, w, N, U, dl, dM, dR, d0, c, m, a, n \n\nM_mat=matrix(c(0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,\n               0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n               0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,\n               0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,\n               0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,\n               0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n               0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,\n               0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0), 18, 18, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"Y\", \"ND\", \"D\", \"i\", \"P\", \"W\", \"w\", \"N\", \"U\", \"dL\", \"dM\", \"dR\", expression(d[0]), \"c\", \"m\", \"a\", \"n\")\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 6.8: Directed graph of post-Keynesian endogenous money model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Construct auxiliary Jacobian matrix for 18 variables\n#    r  Y ND  D  i  P  W  w  N  U  dL dM dR d0 c  m  a  n\n\nM_mat = np.array([[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0],\n               [0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0],\n               [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],\n               [0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],\n               [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],\n               [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\n               [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],\n               [0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])\n\n    \n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", 1: \"Y\", 2: \"ND\", 3: \"D\", 4: \"i\", 5:\"P\", 6: \"W\", 7: \"w\", \n            8: \"N\", 9: \"U\", 10: \"dL\", 11: \"dM\", 12: \"dR\", 13: \"d0\", 14: \"c\", \n            15: \"m\", 16: \"a\", 17: \"n\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=42)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure Figure 6.8, it can be seen that credit rationing (\\(c\\)), productivity (\\(a\\)), the price mark-up (\\(n\\)), the interest rate mark-up (\\(m\\)), and autonomous demand (\\(d_0\\)), are the key exogenous variables of the model. All other variables are endogenous, and many of them form a closed loop (or cycle) within the system. The lower-right part of the graph captures the goods market: debt- and not debt-financed aggregate demand determine output. The outer right part depicts the endogenous money creation process: creditworthy debt-financed demand determines credit creation, which translates into deposit money creation. Bank reserves are a residual. The lower-left part of the graph represents the labour market. The goods market feeds into the labour market via employment, which determines nominal wages and the price level. The real wage is a residual. The price level feeds into interest rate determination in the upper part of the model, which establishes a causal feedback link from the labour market to the goods market.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#analytical-discussion",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#analytical-discussion",
    "title": "6  A Post-Keynesian Macro Model with Endogenous Money",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nLike the Neoclassical Synthesis model, the post-Keynesian macro model can be represented as an AS-AD model. First, we will derive an IS and an interest-rate (IR) curve in the \\((Y, r)\\)-space, the latter representing monetary policy and bank lending instead of the money market (the conventional LM curve). Then we obtain the AS-AD representation of the model in the \\((Y,P)\\)-space. Finally, we obtain equilibrium solutions for \\(Y\\) and \\(P\\).\nTo obtain the IS-curve, substitute Equation 6.2 and Equation 6.3 into Equation 6.1 and solve for \\(Y\\): \\[\\begin{align}\\label{eq:IS}\\tag{IS}\nY&=\\left(\\frac{1}{1-b}\\right)\\Bigl[c(d_0 -d_1r)\\Bigr].\n\\end{align}\\]\nTo obtain the IR-curve, substitute Equation 6.4, Equation 6.9, Equation 6.10, Equation 6.12, and Equation 6.13 into Equation 6.5 : \\[\\begin{align}\\label{eq:IR}\\tag{IR}\nr&=\\left(1+m\\right)\\Bigl[i_0+i_1(1+n)a[W_0-h\\bigl(1-\\frac{aY}{N^f}\\bigr)]\\Bigr].\n\\end{align}\\]\nIt can readily be seen that the IS-curve is downward-sloping and the IR-curve is upward-sloping in the \\((Y, r)\\)-space\nTo obtain the AD-curve, substitute Equation 6.5 and Equation 6.4 into the IS-curve:\n\\[\\begin{align}\\label{eq:AD}\\tag{AD}\nY&=\\left(\\frac{1}{1-b}\\right)\\Bigl[c(d_0 -d_1(1+m)(i_0+i_1P))\\Bigr].\n\\end{align}\\]\nFinally, to obtain the AS-curve, substitute Equation 6.10 and Equation 6.13 into Equation 6.9:\n\\[\\begin{align}\\label{eq:AS}\\tag{AS}\nP&=\\left(1+n\\right)a\\Bigl[W_0-h\\bigl(1-\\frac{aY}{N^f}\\bigr)\\Bigr].\n\\end{align}\\]\nIt can readily be seen that the AD-curve is downward-sloping in the \\((Y, P)\\)-space, whereas the AS-curve is upward-sloping.\nFinally, by substituting the AS and AD curves into each other, we obtain the following equilibrium solutions for output and the price level:\n\\[\\begin{align*}\nY^*&=\\frac{c\\{d_0-d_1(1+m)[i_0+i_1(1+n)a(W_0-h)]\\}}{1-b+cd_1(1+m)i_1(1+n)a^2h(N^f)^{-1}} \\\\\nP^*&=\\frac{(1+n)a[(1-b)(W_0-h)+ha(N^f)^{-1}c(d_0-d_1(1+m)i_0)]}{1-b+cd_1(1+m)i_1(1+n)a^2h(N^f)^{-1}}.\n\\end{align*}\\]\nConfirm analytical solutions numerically\n\n### Confirm equilibrium solution for Y*  (baseline)\n# Analytical solution\n(c[1]*(d0[1] -d1*(1+m[1])*(i0+i1*(1+n[1])*a[1]*(W0-h))))/(1-b +c[1]*d1*(1+m[1])*i1*(1+n[1])*(a[1]^2)*h*(Nf^-1))\n\n[1] 6.922735\n\n# Numerical solution\nY_star[1]\n\n[1] 6.922735\n\n### Confirm equilibrium solution for P*  (baseline)\n# Analytical solution\n((1+n[1])*a[1]*((W0-h)*(1-b)+(Nf^-1)*h*a[1]*c[1]*(d0[1]-d1*(1+m[1])*i0[1])))/(1-b +c[1]*d1*(1+m[1])*i1*(1+n[1])*(a[1]^2)*h*(Nf^-1))\n\n[1] 1.443676\n\n# Numerical solution\nP_star[1]\n\n[1] 1.443676",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#references",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#references",
    "title": "6  A Post-Keynesian Macro Model with Endogenous Money",
    "section": "References",
    "text": "References\n\n\n\n\nFontana, Giuseppe, and Mark Setterfield. 2009. “A Simple (and Teachable) Macreconomic Model with Endogenous Money.” In Macroeconomic Theory and Macroeconomic Pedagogy, edited by Giuseppe Fontana and Mark Setterfield, 144–68. Basingstoke ; New York: Palgrave Macmillan.\n\n\nHein, Eckhard. 2014. Distribution and Growth After Keynes: A Post-Keynesian Guide. Cheltenham: Edward Elgar.\n\n\nLavoie, Marc. 2006. Introduction to Post-Keynesian Economics. Palgrave Macmillan.\n\n\n———. 2014. Post-Keynesian Economics: New Foundations. Cheltenham; Northampton, MA: Edward Elgar.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_post_keynesian_macro_model_with_endogenous_money.html#footnotes",
    "href": "a_post_keynesian_macro_model_with_endogenous_money.html#footnotes",
    "title": "6  A Post-Keynesian Macro Model with Endogenous Money",
    "section": "",
    "text": "See Lavoie (2006), chap.1 and Exploring Economics for introductions. Lavoie (2014) and Hein (2014) provide more advanced treatments.↩︎\nFor simplicity, it is assumed that all autonomous demand is debt-financed, i.e. there is no spending out of wealth.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A Post-Keynesian Macro Model with Endogenous Money</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html",
    "href": "a_Kaldor-Robinson_model.html",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "",
    "text": "Overview\nIn the 1950s and 1960s in Cambridge UK, Nicholas Kaldor and Joan Robinson developed a theory of growth that aimed to apply John Maynard Keynes’ principle of effective demand to the long run.1 The main Keynesian assumption retained by Kaldor and Robinson was that investment and saving are independent, and that a change in investment may lead to an adjustment in saving. However, unlike Keynes, Kaldor and Robinson assumed a fixed level of capacity utilisation, which they considered a key feature of a long-run equilibrium. As a result, goods market clearing cannot be established via output adjustment. Instead, Kaldor and Robinson assumed price adjustment, which would translate into a change in income distribution. Changes in the distribution of income then affect consumption (and saving), as workers tend to have a higher marginal propensity to consume than capital owners. For example, an increase in investment demand due to improved animal spirits would then lead to excess demand, which raises the price level. For a given level of nominal wages, the rise in the price level lowers real wages, leading to a redistribution of income towards profits. The resulting rise in the profit share increases aggregate saving, thereby leading to an adjustment of saving to investment. Taken together, the Kaldor-Robinson approach highlights the relevance of supply constraints in the long run that can lead to inflationary outcomes of demand shocks.\nWe consider a simple version of the model proposed in Hein (2014), chap. 4.4. This is a model of long-run steady state growth. In the steady state, all endogenous variables grow at the same rate.2 Changes in parameters or exogenous variables lead to an instantaneous adjustment of the model’s variables, so that the model can be analysed like a static one. The key question addressed by this model is a how changes in aggregate demand affects income distribution and the rate of growth.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#the-model",
    "href": "a_Kaldor-Robinson_model.html#the-model",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "The Model",
    "text": "The Model\n\\[\nr=h \\frac{u_n}{v}\n\\tag{7.1}\\]\n\\[\ns=s_\\Pi r,  \\quad  s_\\Pi \\in (0,1)\n\\tag{7.2}\\]\n\\[\nc= \\frac{u_n}{v}-s\n\\tag{7.3}\\]\n\\[\ng=g_0+g_1r, \\quad g_1 &gt; 0\n\\tag{7.4}\\]\n\\[\nh=\\frac{vg_0}{u_n(s_\\Pi-g_1)}\n\\tag{7.5}\\]\nwhere \\(r\\), \\(s\\), \\(c\\), \\(g\\), and \\(h\\) are the profit rate, the saving rate, the consumption rate, the investment rate, and the profit share, respectively.\nEquation 7.1 decomposes the profit rate into the product of the profit share \\(h\\) (total profits over total output), the normal rate of capacity utilisation (\\(u_n\\)), and the inverse of \\(v\\) (the capital-potential output ratio). Let \\(Y\\) be output, \\(K\\) be the capital stock, and \\(Y^P\\) be potential output, then the decomposition can also be written as \\(r=\\frac{\\Pi}{K}=\\frac{\\Pi}{Y}\\frac{Y}{Y^P}\\frac{Y^P}{K}\\). The normal rate of capacity utilisation and the capital-potential output ratio are taken to be exogenous in this model. Note also that the wage share is given by \\(1-h\\). By Equation 7.2, the economy-wide saving rate is given by saving out of profits (\\(s_\\Pi r\\)). It is assumed that workers don’t save, i.e. have a higher marginal propensity to consume than capital owners. Equation 7.3 simply states that consumption is income not saved. According to Equation 7.3, investment is determined by an autonomous component \\(g_0\\) that may capture Keynesian ‘animal spirits’ and by the profit rate. The profit rate may stimulate investment if firms use adaptive expectations and predict higher future profits in response to an increase in the current profit rate. Finally, Equation 7.5 is the goods market equilibrium condition \\(g=s\\) solved for the profit share, reflecting the fact that prices are assumed to clear the goods market which translates into an adjustment of the profit share.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#simulation",
    "href": "a_Kaldor-Robinson_model.html#simulation",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. We will consider three different parameterisations. Besides a baseline scenario (labelled as scenario 1), we will consider an increase in animal spirits (\\(g_0\\)) and an increase in the propensity to save out of profits (\\(s_\\Pi\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(v\\)\n\\(s_\\Pi\\)\n\\(g_0\\)\n\\(g_1\\)\n\\(u_n\\)\n\n\n\n1: baseline\n3\n0.6\n0.02\n0.3\n0.9\n\n\n2: rise in animal spirits (\\(g_0\\))\n3\n0.6\n0.04\n0.3\n0.9\n\n\n3: rise in saving propensity (\\(s_\\Pi\\))\n3\n0.9\n0.02\n0.3\n0.9\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baselines)\nS=3\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nh_star=vector(length=S) # profit share\ng_star=vector(length=S) # growth rate of capital stock\ns_star=vector(length=S) # saving rate\nc_star=vector(length=S) # consumption rate\nr_star=vector(length=S) # profit rate\n\n# Set constant parameter values\nv=3    # capital-to-potential output ratio\ng1=0.3 # sensitivity of investment with respect to profit rate \nun=0.9 # normal rate of capacity utilisation\n\n# Set exogenous variables whose parameterisation changes across regimes \ng0=vector(length=S) # animal spirits\nsp=vector(length=S) # propensity to save out of profits\n\n### Construct different scenarios \n\n# scenario 1: baseline \ng0[]=0.02\nsp[]=0.6\n\n#scenario 2: increase in animal spirits\ng0[2]=0.04\n\n# scenario 3: increase in propensity to save out of profits\nsp[3]=0.9\n\n#Check  stability condition for all scenarios\nfor (i in 1:S){\n  print(sp[i]&gt;g1)\n}\n\n[1] TRUE\n[1] TRUE\n[1] TRUE\n\n# Initialise endogenous variables at some arbitrary positive value \ng = r = s = c = h = 1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #(1) Profit rate\n    r=(h*un)/v\n    \n    #(2) Saving\n    s = sp[i]*r\n    \n    #(3) Consumption\n    c= un/v - s\n    \n    #(4) Investment\n    g = g0[i]+g1*r\n    \n    #(5) Goods market equilibrium profit share\n    h=(v/un)*(g0[i]/(sp[i]-g1))\n    \n  }\n  \n  #Save results for different parameterisations in vector\n  h_star[i]=h\n  g_star[i]=g\n  r_star[i]=r\n  s_star[i]=s\n  c_star[i]=c\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Clear the environment (not necessary in Python)\n# Set number of scenarios (including baselines)\nS = 3\n\n# Create arrays to store equilibrium solutions for different parameterizations\nh_star = np.empty(S)  # profit share\ng_star = np.empty(S)  # growth rate of capital stock\ns_star = np.empty(S)  # saving rate\nc_star = np.empty(S)  # consumption rate\nr_star = np.empty(S)  # profit rate\n\n# Set constant parameter values\nv = 3    # capital-to-potential output ratio\ng1 = 0.3  # sensitivity of investment with respect to profit rate \nun = 0.9  # normal rate of capacity utilization\n\n# Set exogenous variables whose parameterization changes across regimes\ng0 = np.empty(S)  # animal spirits\nsp = np.empty(S)  # propensity to save out of profits\n\n# Construct different scenarios\n# Scenario 1: baseline\ng0[:] = 0.02\nsp[:] = 0.6\n\n# Scenario 2: increase in animal spirits\ng0[1] = 0.04\n\n# Scenario 3: increase in propensity to save out of profits\nsp[2] = 0.9\n\n# Check stability condition for all scenarios\nfor i in range(S):\n    print(sp[i] &gt; g1)\n\n\n\n# Initialize endogenous variables at some arbitrary positive value\ng = r = s = c = h = 1\n\n# Solve this system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # (1) Profit rate\n        r = (h * un) / v\n\n        # (2) Saving\n        s = sp[i] * r\n\n        # (3) Consumption\n        c = un / v - s\n\n        # (4) Investment\n        g = g0[i] + g1 * r\n\n        # (5) Goods market equilibrium profit share\n        h = (v / un) * (g0[i] / (sp[i] - g1))\n\n    # Save results for different parameterizations in arrays\n    h_star[i] = h\n    g_star[i] = g\n    r_star[i] = r\n    s_star[i] = s\n    c_star[i] = c\n\n\n\n\nPlots\nFigures Figure 7.1 - Figure 7.3 depict the response of the model’s key endogenous variables to changes in aggregate demand. A rise in animal spirits (scenario 2) raises the profit share. This reduces consumption. However, the effect on capital accumulation and thus growth is positive. In that sense, long-run growth is demand-driven, despite the fixed rate of capacity utilisation.\n\nbarplot(h_star, ylab=\"h\", names.arg=c(\"1: baseline\", \"2: rise animal spirits\", \"3:rise savings propensity\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 7.1: Profit share\n\n\n\n\nIn the second scenario, the saving propensity of capital owners increases. This constitutes a reduction in aggregate demand, leading to a fall in the profit share, and a fall in the growth rate. Since \\(g=s\\), the effect reflects the Keynesian ‘paradox of saving’: a rise in the saving propensity leads to a fall in the aggregate saving rate.\n\nbarplot(c_star, ylab=\"c\", names.arg=c(\"1: baseline\", \"2: rise animal spirits\", \"3:rise savings propensity\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 7.2: Rate of consumption\n\n\n\n\n\nbarplot(g_star, ylab=\"g\", names.arg=c(\"1: baseline\", \"2: rise animal spirits\", \"3:rise savings propensity\"), cex.names = 0.6)\n\n\n\n\n\n\nFigure 7.3: Rate of growth\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for profit share) \nimport matplotlib.pyplot as plt\n\n# Scenario labels\nscenario_names = [\"1: baseline\", \"2: rise animal spirits\", \"3: rise savings propensity\"]\n\n# Bar plot for h_star\nplt.bar(scenario_names, h_star)\nplt.ylabel('h')\nplt.xticks(scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#directed-graph",
    "href": "a_Kaldor-Robinson_model.html#directed-graph",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph \n# Construct auxiliary Jacobian matrix for 7 variables: \n             # r,h,s,g,g0,sp,un\nM_mat=matrix(c(0,1,0,0,0, 0, 1,\n               0,0,1,1,0, 0, 1,\n               1,0,0,0,0, 1, 0,\n               1,0,0,0,1, 0, 0,\n               0,0,0,0,0, 0, 0,\n               0,0,0,0,0, 0, 0,\n               0,0,0,0,0, 0, 0), 7, 7, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"h\", \"s\", \"g\", expression(g[0]), expression(s[Pi]), expression(u[n]))\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 7.4: Directed graph of Kaldor-Robinson growth model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the Jacobian matrix\nM_mat = np.array([[0, 1, 0, 0, 0, 0, 1],\n                  [0, 0, 1, 1, 0, 0, 1],\n                  [1, 0, 0, 0, 0, 1, 0],\n                  [1, 0, 0, 0, 1, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", 1: \"h\", 2: \"s\", 3: \"g\", 4: r\"$g_0$\", 5: r\"$s_p$\", 6: r\"$u_n$\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure Figure 7.4, it can be seen that animal spirits (\\(g_0\\)), the propensity to save out of profits (\\(s_\\Pi\\)), and the normal rate of capacity utilisation (\\(u_n\\)) are the key exogenous variable of the model. Saving (\\(s\\)), investment (\\(g\\)), the rate of profit (\\(r\\)), and the profit share (\\(h\\)) are endogenous and form a closed loop (or cycle) within the system.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#analytical-discussion",
    "href": "a_Kaldor-Robinson_model.html#analytical-discussion",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the equilibrium solution for the profit share (Equation 7.5), substitute Equation 7.1, Equation 7.4 and Equation 7.2 and into \\(g=s\\) and solve for \\(h\\).\nThe equilibrium solution for \\(h\\) can then be substituted into Equation 7.1 to find: \\[\\begin{align}\nr^* = \\frac{g_0}{s_\\Pi-g_1}\n\\end{align}\\]\nSimilarly, substituting the equilibrium solution for \\(r\\) into Equation 7.4 yields: \\[\\begin{align}\ng^* = \\frac{s_\\Pi g_0}{s_\\Pi-g_1}.\n\\end{align}\\]\nThe Kaldor-Robinson stability condition requires \\(s_\\Pi-g_1&gt;0\\), i.e. saving needs to react more strongly to the profit rate than investment.\nFurther analytical results can be found in Hein (2014), chap. 4.4.\nCalculate analytical solutions numerically\n\n# Profit rate\nfor (i in 1:S){\n  print((g0[i])/(sp[i]-g1))\n}\n\n[1] 0.06666667\n[1] 0.1333333\n[1] 0.03333333\n\n# Growth rate\nfor (i in 1:S){\n  print((sp[i]*g0[i])/(sp[i]-g1))\n}\n\n[1] 0.04\n[1] 0.08\n[1] 0.03\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Profit rate\nfor i in range(S):\n    print(g0[i] / (sp[i] - g1))\n\n# Growth rate\nfor i in range(S):\n    print((sp[i] * g0[i]) / (sp[i] - g1))",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#references",
    "href": "a_Kaldor-Robinson_model.html#references",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nHein, Eckhard. 2014. Distribution and Growth After Keynes: A Post-Keynesian Guide. Cheltenham: Edward Elgar.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor-Robinson_model.html#footnotes",
    "href": "a_Kaldor-Robinson_model.html#footnotes",
    "title": "\n7  A Kaldor-Robinson Distribution and Growth Model\n",
    "section": "",
    "text": "See Hein (2014), chap. 4 for a detailed treatment.↩︎\nAll variables are normalised by the capital stock and thus rendered stationary.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A Kaldor-Robinson Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html",
    "href": "a_post_kaleckian_distribution_and_growth_model.html",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "",
    "text": "Overview\nThe post-Kaleckian growth model was developed by Bhaduri and Marglin (1990) and others to synthesise Marxian and Keynesian ideas about the effects of income distribution on economic growth.1 According to the Marxian view, capital accumulation is driven by profits. By contrast, Michal Kalecki and post-Keynesians such as Nicholas Kaldor argued that a redistribution of income towards profit-earners is likely to reduce consumption, as workers tend to have a higher marginal propensity to consume than capital owners. The post-Kaleckian growth model integrates these two mechanisms in a Keynesian framework in which aggregate demand and growth are demand-determined. It allows for wage-led as well as profit-led demand and growth regimes. In a wage-led regime, a redistribution of income towards workers has expansionary effects on aggregate demand (and possibly growth) as the expansionary effect on consumption outweighs the negative effect on investment. In a profit-led regime, the effect is contradictory as investment falls by more than consumption rises. Whether a regime is wage- or profit-led depends on the relative size of the propensities to consume and the propensity to invest.\nThis is a model of long-run steady state growth. In the steady state, all endogenous variables grow at the same rate.2 Changes in parameters or exogenous variables lead to an instantaneous adjustment of the model’s variables, so that the model can be analysed like a static one. We consider a version of the model with linear functions based on Hein (2014), chap. 7.2.2.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#the-model",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#the-model",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "The Model",
    "text": "The Model\n\\[\nr=h \\frac{u}{v}\n\\tag{8.1}\\]\n\\[\ns=[s_W + (s_\\Pi - s_W)h]\\frac{u}{v}, \\quad 0 \\geq s_W &gt; s_\\Pi \\geq 1\n\\tag{8.2}\\]\n\\[\nc= \\frac{u}{v}-s\n\\tag{8.3}\\]\n\\[\ng=g_0+g_1u+g_2h, \\quad g_i &gt; 0\n\\tag{8.4}\\]\n\\[\nu=v(c+g)\n\\tag{8.5}\\]\nwhere \\(r\\), \\(s\\), \\(c\\), \\(g\\), and \\(u\\) are the profit rate, the saving rate, the consumption rate, the investment rate, and the rate of capacity utilisation, respectively.\nEquation 8.1 decomposes the profit rate into the product of the profit share \\(h\\) (total profits over total output), the rate of capacity utilisation (actual output over potential output), and the inverse of \\(v\\) (the capital-potential output ratio). Let \\(Y\\) be output, \\(K\\) be the capital stock, and \\(Y^P\\) be potential output, the decomposition can also be written as \\(r=\\frac{\\Pi}{K}=\\frac{\\Pi}{Y}\\frac{Y}{Y^P}\\frac{Y^P}{K}\\). The profit share and the capital-potential output ratio are taken to be exogenous in this model. Note also that the wage share is given by \\(1-h\\). By Equation 8.2, the economy-wide saving rate is given by the sum of saving out of wages (\\(s_W(1-h)\\frac{u}{v}\\)) and saving out of profits (\\(s_\\Pi h\\frac{u}{v}\\)). It is assumed that workers have a higher marginal propensity to consume than capital owners (\\(s_W&gt;s_\\Pi\\)). Equation 8.3 simply states that consumption is income not saved. According to Equation 8.3, investment is determined by an autonomous component \\(g_0\\) that may capture Keynesian `animal spirits’, by the rate of capacity utilisation, and by the profit share. While the rate of capacity utilisation is a signal of (future) demand, the profit share may stimulate investment as internal funds are typically the cheapest source of finance. Finally, Equation 8.5 is an equilibrium condition that assumes that the rate of capacity utilisation adjusts to clear the goods market.\nThe key question addressed by this model is a how a change in the profit share affects the rate of capacity utilisation and the rate of growth.3 As shown formally in the analytical discussion below, there is no unambiguous answer to this question as the model encompasses different regimes. Three main regimes can be identified. First, a regime in which both the rate of utilisation and the rate of growth are negatively affected by an increase in the profit share. We will call this a wage-led demand and growth regime (WLD/WLG). Second, a regime in which the rate of utilisation is negatively affected and the rate of growth is positively affected by an increase in the profit share. We will call this a wage-led demand regime and profit-led growth regime (WLD/PLG). Third, a regime in which both the rate of utilisation and the rate of growth are positively affected by an increase in the profit share. We will call this a profit-led demand and growth regime (PLD/PLG).",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#simulation",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#simulation",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. We will consider three different parameterisations that represent the three regimes outlined above. For each of these regimes, there is a baseline scenario and a scenario in which the profit share (\\(h\\)) rises. This allows to assess the effects on the model’s endogenous variables for the different regimes.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(v\\)\n\\(s_W\\)\n\\(s_\\Pi\\)\n\\(g_0\\)\n\\(g_1\\)\n\\(g_2\\)\n\\(h\\)\n\n\n\n1a: baseline WLD/WLG\n3\n0.3\n0.9\n0.02\n0.1\n0.1\n0.2\n\n\n1b: rise in profit share (\\(h\\))\n3\n0.3\n0.9\n0.02\n0.1\n0.1\n0.3\n\n\n2a: baseline WLD/PLG\n3\n0.3\n0.9\n0.02\n0.08\n0.1\n0.2\n\n\n2b: rise in profit share (\\(h\\))\n3\n0.3\n0.9\n0.02\n0.08\n0.1\n0.3\n\n\n3a: baseline PLD/PLG\n3\n0.3\n0.9\n-0.01\n0.1\n0.1\n0.2\n\n\n3b: rise in profit share (\\(h\\))\n3\n0.3\n0.9\n-0.01\n0.1\n0.1\n0.3\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of scenarios (including baselines)\nS=6\n\n#Create vector in which equilibrium solutions from different parameterisations will be stored\nu_star=vector(length=S) # utilisation rate\ng_star=vector(length=S) # growth rate of capital stock\ns_star=vector(length=S) # saving rate\nc_star=vector(length=S) # consumption rate\nr_star=vector(length=S) # profit rate\n\n# Set exogenous variables whose parameterisation changes across regimes \ng0=vector(length=S) # animal spirits\nsw=vector(length=S) # propensity to save out of wages \nh=vector(length=S)  # profit share\ng1=vector(length=S) # sensitivity of investment with respect to utilisation\n\n### Construct different scenarios across 3 regimes: (1) WLD/WLG, (2) WLD/PLG, (3) PLD/PLG \n\n# baseline WLD/WLG\ng0[1]=0.02\ng1[1]=0.1\nh[1]=0.2\n\n# increase in profit share in WLD/WLG regime\ng0[2]=0.02\ng1[2]=0.1\nh[2]=0.3\n\n# baseline WLD/PLG\ng0[3]=0.02\ng1[3]=0.08\nh[3]=0.2\n\n# increase in profit share in WLD/PLG regime\ng0[4]=0.02\ng1[4]=0.08\nh[4]=0.3\n  \n# baseline PLD/PLG\ng0[5]=-0.01\ng1[5]=0.1\nh[5]=0.2\n\n# increase in profit share in PLD/PLG regime\ng0[6]=-0.01\ng1[6]=0.1\nh[6]=0.3\n\n#Set constant parameter values\nv=3    # capital-to-potential output ratio\ng2=0.1 # sensitivity of investment with respect to profit share\nsp=0.9 # propensity to save out of profits\nsw=0.3 # propensity to save out of wages\n\n#Check Keynesian stability condition for all scenarios\nfor (i in 1:S){\nprint(((sw+(sp-sw)*h[i])*(1/v) -g1[i])&gt;0)\n}\n\n[1] TRUE\n[1] TRUE\n[1] TRUE\n[1] TRUE\n[1] TRUE\n[1] TRUE\n\n# Check demand and growth regime for 3 baseline scenarios\nfor (i in c(1,3,5)){\nprint(paste(\"Parameterisation\", i, \"yields:\"))   \nif(g2*(sw/v - g1[i])-g0[i]*(sp-sw)/v&lt;0){\n  print(\"wage-led demand regime\")\n  } else{\n   print(\"profit-led demand regime\")\n  }\nif(g1[i]*(g2*(sw/v - g1[i])-g0[i]*(sp-sw)/v)+g2*(((sw+(sp-sw)*h[i])*v^(-1)-g1[i])^2)&lt;0){\n  print(\"wage-led growth regime\")\n  } else{\n  print(\"profit-led growth regime\")\n  }  \n} \n\n[1] \"Parameterisation 1 yields:\"\n[1] \"wage-led demand regime\"\n[1] \"wage-led growth regime\"\n[1] \"Parameterisation 3 yields:\"\n[1] \"wage-led demand regime\"\n[1] \"profit-led growth regime\"\n[1] \"Parameterisation 5 yields:\"\n[1] \"profit-led demand regime\"\n[1] \"profit-led growth regime\"\n\n# Initialise endogenous variables at some arbitrary positive value \ng=1\nr=1\nc=1\nu=1\ns=1\n\n#Solve this system numerically through 1000 iterations based on the initialisation\nfor (i in 1:S){\n  \n  for (iterations in 1:1000){\n    \n    #(1) Profit rate\n    r = (h[i]*u)/v\n    \n    #(2) Saving\n    s = (sw+(sp-sw)*h[i])*(u/v)\n    \n    #(3) Consumption\n    c= u/v-s\n    \n    #(4) Investment\n    g = g0[i]+g1[i]*u+g2*h[i]\n    \n    #(5) Rate of capacity utilisation\n    u = v*(c+g)\n  }\n  \n  #Save results for different parameterisations in vector\n  u_star[i]=u\n  g_star[i]=g\n  r_star[i]=r\n  s_star[i]=s\n  c_star[i]=c\n}\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of scenarios (including baselines)\nS = 6\n\n# Create arrays to store equilibrium solutions for different parameterizations\nu_star = np.zeros(S)\ng_star = np.zeros(S)\ns_star = np.zeros(S)\nc_star = np.zeros(S)\nr_star = np.zeros(S)\n\n# Set exogenous variables whose parameterization changes across regimes\ng0 = np.zeros(S)\nsw = np.zeros(S)\nh = np.zeros(S)\ng1 = np.zeros(S)\n\n# Construct different scenarios across 3 regimes\n# Regime 1: WLD/WLG\ng0[0] = 0.02\ng1[0] = 0.1\nh[0] = 0.2\n\n# Regime 2: Increase in profit share in WLD/WLG regime\ng0[1] = 0.02\ng1[1] = 0.1\nh[1] = 0.3\n\n# Regime 3: WLD/PLG\ng0[2] = 0.02\ng1[2] = 0.08\nh[2] = 0.2\n\n# Regime 4: Increase in profit share in WLD/PLG regime\ng0[3] = 0.02\ng1[3] = 0.08\nh[3] = 0.3\n\n# Regime 5: PLD/PLG\ng0[4] = -0.01\ng1[4] = 0.1\nh[4] = 0.2\n\n# Regime 6: Increase in profit share in PLD/PLG regime\ng0[5] = -0.01\ng1[5] = 0.1\nh[5] = 0.3\n\n# Set constant parameter values\nv = 3    # capital-to-potential output ratio\ng2 = 0.1 # sensitivity of investment with respect to profit share\nsp = 0.9 # propensity to save out of profits\nsw = 0.3 # propensity to save out of wages\n\n# Check Keynesian stability condition for all scenarios\nfor i in range(S):\n    print(((sw + (sp - sw) * h[i]) * (1 / v) - g1[i]) &gt; 0)\n    \n# Check demand and growth regime for 3 baseline scenarios\nfor i in [0, 2, 4]:\n    print(f\"Parameterization {i+1} yields:\")\n    \n    # Check demand regime\n    if g2 * (sw / v - g1[i]) - g0[i] * (sp - sw) / v &lt; 0:\n        print(\"Wage-led demand regime\")\n    else:\n        print(\"Profit-led demand regime\")\n    \n    # Check growth regime\n    if g1[i] * (g2 * (sw / v - g1[i]) - g0[i] * (sp - sw) / v) + g2 * (((sw + (sp - sw) * h[i]) * v**(-1) - g1[i])**2) &lt; 0:\n        print(\"Wage-led growth regime\")\n    else:\n        print(\"Profit-led growth regime\")\n\n# Initialize endogenous variables at an arbitrary positive value\ng = r = c = u = s = 1\n\n# Solve the system numerically through 1000 iterations based on the initialization\nfor i in range(S):\n    for iterations in range(1000):\n        # (1) Profit rate\n        r = (h[i] * u) / v\n\n        # (2) Saving\n        s = (sw + (sp - sw) * h[i]) * (u / v)\n\n        # (3) Consumption\n        c = u / v - s\n\n        # (4) Investment\n        g = g0[i] + g1[i] * u + g2 * h[i]\n\n        # (5) Rate of capacity utilization\n        u = v * (c + g)\n\n    # Save results for different parameterizations in vectors\n    u_star[i] = u\n    g_star[i] = g\n    r_star[i] = r\n    s_star[i] = s\n    c_star[i] = c\n\n\n\n\nPlots\nFigures Figure 8.1 - Figure 8.4 depict the response of the model’s key endogenous variables to changes in the profit share. In the first case of a wage-led demand and growth regime (WLD/WLG), investment is equally sensitive to a change in the rate of capacity utilisation (\\(g_1\\)) and a change in the profit share (\\(g_2\\)). A rise in the profit share reduces consumption, which reduces the rate of capacity utilisation and the rate of growth. This is despite a positive effect on the profit rate.4\n\nbarplot(u_star, ylab=\"u\", names.arg=c(\"1a:baseline WLD/WLG\", \"1b:rise prof share\", \"2a:baseline WLD/PLG\", \"2b:rise prof share\", \"3a:baseline PLD/PLG\", \"3b: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.1: Rate of capacity utilisation\n\n\n\n\nIn the second case where the demand regime is wage-led but the growth regime is profit-led (WLD/PLG), investment is slightly less sensitive to a change in the rate of capacity utilisation compared to a change in the profit share. The rise in the profit share reduces consumption and the rate of utilisation, but the ultimate effect on investment is positive because investment reacts more strongly to the rise in the profit share than to the fall in demand.\n\nbarplot(g_star, ylab=\"g\", names.arg=c(\"1:baseline WLD/WLG\", \"2:rise prof share\", \"3:baseline WLD/PLG\",\n                                      \"4:rise prof share\", \n                                      \"5:baseline PLD/PLG\", \"6: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.2: Rate of growth\n\n\n\n\nFinally, in the third case where the demand regime and the growth regime are profit-led, investment is again equally sensitive to a change in the rate of capacity utilisation and to a change in the profit share, but now animal spirits are negative. A rise in the profit share now has strong positive effects on investment, which raises the rate of capacity utilisation and consumption.\n\nbarplot(c_star, ylab=\"c\", names.arg=c(\"1:baseline WLD/WLG\", \"2:rise prof share\", \"3:baseline WLD/PLG\",\n                                      \"4:rise prof share\", \n                                      \"5:baseline PLD/PLG\", \"6: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.3: Rate of consumption\n\n\n\n\n\nbarplot(r_star, ylab=\"r\", names.arg=c(\"1:baseline WLD/WLG\", \"2:rise prof share\", \"3:baseline WLD/PLG\",\n                                     \"4:rise prof share\", \n                                     \"5:baseline PLD/PLG\", \"6: rise prof share\"), cex.names = 0.5)\n\n\n\n\n\n\nFigure 8.4: Rate of profit\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plot results (here only for rate of capacity utilisation) \nimport matplotlib.pyplot as plt    \n\n# Scenario labels\nscenario_names = [\"1a: baseline WLD/WLG\", \"1b: rise prof share\", \"2a: baseline WLD/PLG\", \"2b: rise prof share\", \"3a: baseline PLD/PLG\", \"3b: rise prof share\"]\n\n# Bar plot for u_star\nplt.bar(scenario_names, u_star)\nplt.ylabel('u')\nplt.xticks(scenario_names, rotation=45, fontsize=6)\nplt.show()",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#directed-graph",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#directed-graph",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph \n# Construct auxiliary Jacobian matrix for 6 variables: \n# r, h, u, s, c, g\n\nM_mat=matrix(c(0,1,1,0,0,0,\n               0,0,0,0,0,0,\n               0,0,0,0,1,1,\n               0,1,1,0,0,0,\n               0,0,1,1,0,0,\n               0,1,1,0,0,0), 6, 6, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create and plot directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"h\", \"u\", \"s\", \"c\", \"g\")\n\n# Plot directed graph\nplot(dg, main=\"\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 8.5: Directed graph of post-Kaleckian growth model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the Jacobian matrix\nM_mat = np.array([[0,1,1,0,0,0],\n                  [0,0,0,0,0,0],\n                  [0,0,0,0,1,1],\n                  [0,1,1,0,0,0],\n                  [0,0,1,1,0,0],\n                  [0,1,1,0,0,0],\n                 ])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", 1: \"h\", 2: \"u\", 3: \"s\", 4: \"c\", 5: \"g\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure Figure 8.5, it can be seen that the profit share (\\(h\\)) is the key exogenous variable of the model.5 Consumption (\\(c\\)), saving (\\(s\\)), investment (\\(g\\)), and the rate of utilisation (\\(u\\)) form a closed loop (or cycle) within the system. The profit share affects both saving and investment, which in turn affect consumption and the rate of capacity utilisation. The profit rate is a residual variable (also called a `sink’) in this model.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#analytical-discussion",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#analytical-discussion",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the equilibrium solutions, substitute Equation 8.2 - Equation 8.4 into Equation 8.5 and solve for \\(u\\): \\[\\begin{align}\nu^* = \\frac{g_0+g_2h}{[s_W + (s_\\Pi - s_W)h]v^{-1}-g_1}.\n\\end{align}\\]\nThe equilibrium solution for \\(u\\) can then be substituted into Equation 8.4 to find: \\[\\begin{align}\ng^* = \\frac{(g_0+g_2h)[s_W + (s_\\Pi - s_W)h]v^{-1}}{[s_W + (s_\\Pi - s_W)h]v^{-1}-g_1}.\n\\end{align}\\]\nThe Keynesian stability condition requires \\([s_W + (s_\\Pi - s_W)h]v^{-1}-g_1&gt;0\\), i.e. saving need to react more strongly to income than investment.\nThe equilibrium solution for \\(r\\) can be found by substituting \\(u^*\\) into Equation 8.1: \\[\\begin{align}\nr^* = \\frac{h(g_0+g_2h)}{[s_W + (s_\\Pi - s_W)h]-vg_1}.\n\\end{align}\\]\nTo assess whether the demand regime is wage- or profit-led, take the derivative of \\(u^*\\) with respect to \\(h\\): \\[\\begin{align}\n\\frac{\\partial u^*}{\\partial h} = \\frac{\\frac{s_W}{v}(g_0+g_2 )-(g_0\\frac{s_\\Pi}{v} + g_1g_2)}{[[s_W + (s_\\Pi - s_W)h]v^{-1}-g_1]^2}.\n\\end{align}\\]\nIt can be seen that, e.g., a higher propensity to save out of wages or negative animal spirits make the regime more likely to be profit-led.\nBy the same token, the sign of the derivative of \\(g^*\\) with respect to \\(h\\) determines whether the growth regime is wage- or profit-led: \\[\\begin{align}\n\\frac{\\partial g^*}{\\partial h} = g_1\\frac{\\partial u^*}{\\partial h}+g_2.\n\\end{align}\\]\nIt can be seen that, e.g., a higher sensitivity of investment with respect to the profit share makes the regime more likely to be profit-led.\nFinally, the effect on the profit rate will depend on the sign of the derivative: \\[\\begin{align}\n\\frac{\\partial r^*}{\\partial h} = \\frac{u^*}{v} + \\frac{h}{v}\\frac{\\partial u^*}{\\partial h},\n\\end{align}\\]\nwhich is likely to be positive but can become negative if the demand regime is strongly wage-led.\nCalculate analytical solutions numerically\n\n# Utilisation rate\nfor (i in 1:S){\nprint((g0[i]+g2*h[i])/((sw+(sp-sw)*h[i])/v-g1[i]))\n}\n\n[1] 1\n[1] 0.8333333\n[1] 0.6666667\n[1] 0.625\n[1] 0.25\n[1] 0.3333333\n\n# Growth rate\nfor (i in 1:S){\n  print(((g0[i]+g2*h[i])*(sw+(sp-sw)*h[i])/v)/((sw+(sp-sw)*h[i])/v-g1[i]))\n}\n\n[1] 0.14\n[1] 0.1333333\n[1] 0.09333333\n[1] 0.1\n[1] 0.035\n[1] 0.05333333\n\n# Profit rate\nfor (i in 1:S){\n  print((g0[i]+g2*h[i])*(h[i]/v)/((sw+(sp-sw)*h[i])/v-g1[i]))\n}\n\n[1] 0.06666667\n[1] 0.08333333\n[1] 0.04444444\n[1] 0.0625\n[1] 0.01666667\n[1] 0.03333333\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Utilisation rate\nfor i in range(S):\n    print((g0[i]+g2*h[i])/((sw+(sp-sw)*h[i])/v-g1[i]))\n\n# Growth rate\nfor i in range(S):\n    print(((g0[i]+g2*h[i])*(sw+(sp-sw)*h[i])/v)/((sw+(sp-sw)*h[i])/v-g1[i]))\n    \n# Profit rate\nfor i in range(S):\n    print((g0[i]+g2*h[i])*(h[i]/v)/((sw+(sp-sw)*h[i])/v-g1[i]))",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#references",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#references",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nBhaduri, Amit, and Stephen Marglin. 1990. “Unemployment and the Real Wage: The Economic Basis for Contesting Political Ideologies.” Cambridge Journal of Economics 14 (4): 375–93.\n\n\nHein, Eckhard. 2014. Distribution and Growth After Keynes: A Post-Keynesian Guide. Cheltenham: Edward Elgar.\n\n\nLavoie, Marc. 2014. Post-Keynesian Economics: New Foundations. Cheltenham; Northampton, MA: Edward Elgar.",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "a_post_kaleckian_distribution_and_growth_model.html#footnotes",
    "href": "a_post_kaleckian_distribution_and_growth_model.html#footnotes",
    "title": "\n8  A Post-Kaleckian Distribution and Growth Model\n",
    "section": "",
    "text": "See Hein (2014), chap. 7 and Lavoie (2014), chap. 6 for detailed treatments.↩︎\nAll variables are normalised by the capital stock and thus rendered stationary.↩︎\nBhaduri and Marglin (1990) further discuss the effects on the profit rate.↩︎\nIf the negative effect on the rate of capacity utilisation was stronger, the profit rate could fall as well. See the analytical discussion for a formal derivation of the condition under which this may happen.↩︎\nOther important exogenous variables or parameters that may shift but are not depicted here are animal spirits (\\(g_0\\)) or the saving propensities (\\(s_W, s_\\Pi\\)). See Hein (2014), chap. 7.2.2, for a detailed discussion of their effects.↩︎",
    "crumbs": [
      "Static Models",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A Post-Kaleckian Distribution and Growth Model</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html",
    "href": "intro_stability_analysis.html",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "",
    "text": "Solution of a single first-order linear difference equation\nConsider a first-order linear difference equation:1\n\\[\ny_t = a_0 + a_1y_{t-1}.\n\\]\nOne way to find a solution is through (manual) iteration:\n\\[y_0,\\] \\[y_1 = a_0 + a_1 y_0,\\] \\[y_2 = a_0 + a_1(a_0 + a_1 y_0) = a_0(a_1+1) + a_1^2y_0 ,\\] \\[y_3 = a_0 + a_1[a_0 + a_1(a_0 +a_1y_0)]= a_0(a_1^2+a_1+1) + a_1^3y_0\\] \\[...,\\] \\[y_t = a_0\\sum^{t-1}_{i=0} a_1^i + a_1^ty_0 \\]\nThis is effectively the same approach we have used before to solve economic models via simulation.\nIf \\(a_1\\neq1\\), the term \\(a_0\\sum^{t-1}_{i=0} a_1^i\\) is a convergent geometric series:\n\\[a_0\\sum^{t-1}_{i=0} a_1^i= a_0\\frac{(1-a_1^t)}{1-a_1}.\\]\nThus, the solution thus takes the form:\n\\[\ny_t = \\frac{a_0(1-a_1^t)}{1-a_1} + a_1^ty_0 =\\frac{a_0}{1-a_1} + a_1^t\\left(y_0 - \\frac{a_0}{1-a_1}\\right).\n\\]\nFrom iteration, we thus know that the solution to a difference equation has two parts:\n\\[\ny_t = \\underbrace{\\frac{a_0}{1-a_1}}_{equilibrium \\: y^*} + \\underbrace{a_1^t\\left(y_0 - \\frac{a_0}{1-a_1}\\right)}_{dynamics}.\n\\]\nThe complementary function tells us about the ‘asymptotic stability’ of the equation: does \\(y_t\\) converge to \\(y^*\\) as \\(t \\rightarrow \\infty\\)?\nFor the case of a first-order difference equation, we can distinguish the following cases:\nTo better understand the last two cases, note that if \\(a_1=1\\), a different (more general) approach to finding the particular solution is required: the so-called method of undetermined coefficients. This method consists of substituting a trial solution that contains undetermined coefficients into the difference equation and then attempting to solve for those coefficients. If the trial solution allows to pin down unique values for the coefficients, it constitute a valid particular solution.\nIn the case above where \\(a_1 \\neq 1\\), we could have used the trial solution \\(y_t=y_{t-1}=y^*\\) and then solve for \\(y\\) to obtain \\(\\frac{a_0}{1-a}\\) as the particular solution. In the case where \\(a_1=1\\) and \\(a_0 \\neq 0\\), we can use the trial solution \\(y^*=kt\\), which is a growing equilibrium. This yields \\(y_t = k(t-1) + a_0\\), which solves for \\(k=a_0\\), so that we can conclude \\(y^*=a_0t\\). This explains why we obtain linear growth. If \\(a_1=1\\) and \\(a_0 =0\\), we have \\(y_t=y_{t-1}\\), so that the equilibrium is given by the initial condition \\(y_0\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#solution-of-a-single-first-order-linear-difference-equation",
    "href": "intro_stability_analysis.html#solution-of-a-single-first-order-linear-difference-equation",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "",
    "text": "a term that captures the long-run equilibrium \\(y^*\\) (the so-called particular solution),\na term that captures the dynamics of \\(y_t\\) (the so-called complementary function).\n\n\n\n\n\nif \\(|a_1|&lt;1\\), then the complementary function will converge to zero and \\(y_t\\) will approach the particular solution \\(y^*\\)\nif \\(|a_1|&gt;1\\), then the complementary function will grow exponentially or decay, and \\(y_t\\) will thus never converge to the particular solution \\(y^*\\)\nif \\(a_1=1\\) and \\(a_0 \\neq0\\), then \\(y_t\\) will grow linearly\nif \\(a_1=1\\) and \\(a_0 =0\\), then \\(y_t\\) will not grow or fall forever, but it will also not approach a unique equilibrium",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#solution-of-a-linear-system-of-difference-equations",
    "href": "intro_stability_analysis.html#solution-of-a-linear-system-of-difference-equations",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Solution of a linear system of difference equations",
    "text": "Solution of a linear system of difference equations\nThe solution approach just introduced can be extended to \\(N\\)-dimensional systems of linear difference equations of the form:\n\\[\ny_t=a_0 + Ay_{t-1},  \n\\]\nwhere \\(y_t\\) is a \\(1 \\times N\\) column vector and \\(A\\) an \\(N \\times N\\) square matrix called the coefficient matrix.\nIf the inverse \\((I-A)^{-1}\\) exists, which requires \\(det(I-A) \\neq 0\\), the solution will be of the form:\n\\[\ny_t= \\underbrace{(I-A)^{-1}a_0}_{y^*} + A^t[y_0- \\underbrace{(I-A)^{-1}a_0}_{y^*}].\n\\]\nThe problem with this generic solution is that it is difficult to assess what is going on: the dynamics of any variable in \\(y_t\\) will depend on a lengthy combination of the parameters in \\(A\\) that result from repeated matrix multiplication (\\(A^t=A\\times A\\times A\\times A...\\)). This makes it is impossible to assess whether the system converges to the particular solution. To address this problem, we can use a tool from linear algebra called matrix diagonalisation. Under certain conditions, a matrix \\(A\\) can be decomposed into the product of three matrices in which the matrix in the middle is diagonal. As we will see, this trick has a useful application to our problem.\nA matrix \\(A\\) is diagonalisable if there is a diagonal matrix \\(D\\) and an invertible matrix \\(P\\) such that \\(A=PDP^{-1}\\). A major advantage of this decomposition is the following property: \\(A^n = (PDP^{-1})^n = PD^nP^{-1}\\).2 Thus, the \\(nth\\) power of the matrix \\(A\\), which typically yields very cumbersome expressions, simplifies to \\(PD^nP^{-1}\\), where the \\(nth\\) power of \\(D\\) is simply applied to each individual element on the main diagonal thanks to \\(D\\) being a diagonal matrix. As a result, diagonalisation allows us to write the complementary function in the solution to a system of difference equations as: \\(PD^tP^{-1}y_0\\). We can further define a vector of arbitrary constants \\(c=P^{-1}y_0\\) so that the complementary function becomes \\(PD^tc\\). The solution then takes the form \\(y_t = y^* + PD^tP^{-1}[y_0- y^*] = y^* + PD^tc\\)\nFor the first variable in the system, the solution would be:\n\\[\ny_{1t}=v_{11}c_1\\lambda_1^t+v_{12}c_2\\lambda_2^t + ...+ y_1^*,\n\\]\nwhere \\(v_j\\) are the column vectors of \\(P\\) and \\(\\lambda_i\\) are the elements on the main diagonal of \\(D\\). The \\(v_j\\) are called the eigenvectors of the matrix \\(A\\) and the \\(\\lambda_i\\) are its eigenvalues (more about them in a second). From this representation of the solution, the nature of the dynamics can easily be determined by looking at the eigenvalue \\(\\lambda\\) that is largest in absolute terms. This is also called the ‘dominant eigenvalue’. Only if the dominant eigenvalue is \\(|\\lambda|&lt;1\\) will the system converge to \\(y^*\\). The elements \\(v_{ij}\\) of the eigenvectors act as multipliers on the eigenvalues and can thus switch off certain eigenvalues (if they happen to be zero) or amplify their dynamics both into the positive and negative domain (depending on their algebraic sign).\nHow can the diagonal matrix \\(D\\) be found? Notice that \\(AP=PD\\) can also be written as \\(Av=\\lambda v\\). We can then write \\(v(A-\\lambda I)=0\\). We want to find the solutions of this linear system other than \\(v = 0\\) (we don’t want the eigenvectors to be zero vectors, otherwise the solution to the dynamic system presented above wouldn’t work). This requires the determinant of the matrix \\(A-\\lambda I\\) to become zero, i.e. \\(det(A-\\lambda I)=0\\). Note that then there will be an infinite number of solutions for the eigenvectors.\nLet’s consider an example. Let \\(a_0=0\\) for simplicity, so that the dynamic system is \\(y_t = Ay_{t-1}\\). Let the matrix \\(A\\) be given by: \\[A=\\begin{bmatrix}7 & -15 \\\\ 2 & -4 \\end{bmatrix}.\\]\nThen\n\\[A-\\lambda I =\\begin{bmatrix}7 - \\lambda & -15 \\\\ 2 & -4 - \\lambda \\end{bmatrix}\\]\nand\n\\[det(A-\\lambda I)=(7-\\lambda)(-4-\\lambda)+30=\\lambda^2 - 3\\lambda +2=0.\\]\nThis second-order polynomial solves for \\(\\lambda_1=2\\) and \\(\\lambda_2=1\\), which will be the elements on the diagonal of \\(D\\).\nTo find \\(v_j\\), substitute the \\(\\lambda_i\\) into \\(v_j(A-\\lambda_iI)=0\\). For \\(\\lambda_1=2\\), we get \\(5v_{11}- 15v_{21}=0\\) and \\(2v_{11}- 6v_{21}=0\\), yielding the eigenvector \\(v_1=\\begin{bmatrix} 3 \\\\ 1\\end{bmatrix}\\). However, any scalar multiple of this eigenvector (other than zero) is admissible. It is thus common to normalise the eigenvectors by dividing through one of its elements. Dividing through by the first element yields the normalised eigenvector \\(v_1=\\begin{bmatrix} 1 \\\\ \\frac{1}{3} \\end{bmatrix}\\).\nFor \\(\\lambda_2=1\\), this yields \\(6v_{12}- 15v_{22}=0\\) and \\(2v_{12}-5v_{22}=0\\) from which we can deduce that \\(v_2=\\begin{bmatrix} 5 \\\\ 2\\end{bmatrix}\\). The normalised eigenvector is \\(v_2=\\begin{bmatrix} 1 \\\\ 0.4 \\end{bmatrix}\\).\nOf course, you can also perform these calculations in R or Python:\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n## Find eigenvalues and eigenvectors of matrix\n# Define matrix\nJ=matrix(c(7, -15,\n           2, -4), 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues and eigenvectors\nev=eigen(J)\n(evals = ev$values)\n\n[1] 2 1\n\n(evecs = ev$vector)\n\n          [,1]      [,2]\n[1,] 0.9486833 0.9284767\n[2,] 0.3162278 0.3713907\n\n# Normalise eigenvectors by dividing through by the first element\nevecs_norm=evecs\nfor (i in 1:2){\n  evecs_norm[,i]=evecs[,i]/evecs[1,i]\n}\nevecs_norm\n\n          [,1] [,2]\n[1,] 1.0000000  1.0\n[2,] 0.3333333  0.4\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Define matrix\nJ = np.array([[7, -15],\n              [2, -4]])\n\n# Obtain eigenvalues and eigenvectors\nevals, evecs = np.linalg.eig(J)\n\n# Print eigenvalues and eigenvectors\nprint(evals)\nprint(evecs)\n\n# Initialize an array to store the normalized eigenvectors\nevecs_norm = np.copy(evecs)\n\n# Normalize the eigenvectors\nfor i in range(2):\n    evecs_norm[:, i] = evecs[:, i] / evecs[0, i]\n\n# Print normalized eigenvectors\nprint(evecs_norm)\n\n\n\n\nWe can now use this solution for the eigenvectors and eigenvalues to write the solution of the dynamic system as:\n\\[\n\\begin{bmatrix} y_{1t} \\\\ y_{2t} \\end{bmatrix}= \\begin{bmatrix} 1 & 1 \\\\ \\frac{1}{3} & 0.4 \\end{bmatrix} \\begin{bmatrix} 2 & 0 \\\\ 0 & 1 \\end{bmatrix}^t \\begin{bmatrix} 1 & 1 \\\\ \\frac{1}{3} & 0.4 \\end{bmatrix}^{-1} \\begin{bmatrix} y_{10} \\\\ y_{20} \\end{bmatrix} = \\begin{bmatrix} 1 & 1 \\\\ \\frac{1}{3} & 0.4 \\end{bmatrix} \\begin{bmatrix} 2 & 0 \\\\ 0 & 1 \\end{bmatrix}^t \\begin{bmatrix} c_{1} \\\\ c_{2} \\end{bmatrix}.\n\\]\nMultiplying the matrices out yields:\n\\[\ny_{1t} = c_{1}2^t + c_{2}1^t\n\\]\n\\[\ny_{2t} = \\frac{1}{3}c_{1}2^t + 0.4c_{2}1^t.\n\\]\nBefore comparing these analytical results with those from a numerical simulation, let’s summarise the information we gain from the eigenvalues, eigenvectors, and arbitrary constants about the dynamics of the system:\n\nsince the dominant eigenvalue \\(\\lambda_1=2\\) is larger than one, we know that the system is unstable\nsince both elements in the dominant eigenvector \\(v_1=\\begin{bmatrix} 1 \\\\ \\frac{1}{3} \\end{bmatrix}\\) are non-zero, both variables in the system will be driven by that dominant eigenvalue\nsince both variables will grow or decay at the same rate, their ratio will be constant as \\(t \\rightarrow \\infty\\) and will approach a value that is given by the ratio of the elements in the dominant eigenvector\n\nTo see the last point, observe that in \\(\\frac{y_{2t}}{y_{1t}}=\\frac{\\frac{1}{3}c_{1}2^t + 0.4c_{2}1^t}{c_{1}2^t + c_{2}1^t}\\) the first terms in the numerator and denominator, respectively, quickly dominate the second terms as \\(t \\rightarrow \\infty\\) (you can show this formally using L’Hopital’s rule). Thus, \\(\\frac{y_{2t}}{y_{1t}}\\) will approach \\(\\frac{1}{3}\\) as \\(t \\rightarrow \\infty\\).\nLet us simulate the system and compare the results for, say, \\(t=10\\) with the analytical solution:\n\n# Set number of periods for which you want to simulate\nQ=100\n\n# Construct matrices in which values for different periods will be stored; initialise at 1\ny1=matrix(data=1, nrow=1, ncol=Q)\ny2=matrix(data=1, nrow=1, ncol=Q)\n\n#Solve this system recursively based on the initialisation\n  for (t in 2:Q){\n    y1[,t] = J[1,1]*y1[, t-1] + J[1,2]*y2[, t-1]\n    y2[,t] = J[2,1]*y1[, t-1] + J[2,2]*y2[, t-1]\n} # close time loop\n\n# Plot dynamics of y1\nplot(y1[1, 1:15],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"y1\") \ntitle(main=\"\", cex=0.8)\n\n\n\n\n\n\n# Find arbitrary constants: c=(P^-1)*y0\nlibrary(matlib)\ny0=c(y1[1,1],y2[1,1])  # create vector with initial conditions y0\nc=inv(evecs_norm)%*%y0\nc\n\n     [,1]\n[1,]   -9\n[2,]   10\n\n## Compute solution manually for y2 at t=10 and compare with simulated solution\nt=10\nevecs_norm[2,1]*c[1,1]*evals[1]^t + evecs_norm[2,1]*c[2,1]*evals[2]^t # analytical solution\n\n[1] -3068.667\n\ny2[,t+1] # simulated solution\n\n[1] -3068\n\n# Plot dynamics of y2/y1\ny2_y1=y2/y1\nplot(y2_y1[, 1:50],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"y2/y1\")\ntitle(main=\"\", cex=0.8)\n\n\n\n\n\n\n# Compare y2/y1 with normalised dominant eigenvector\ny2_y1[,Q]\n\n[1] 0.3333333\n\nevecs_norm[2,1]\n\n[1] 0.3333333\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# Set the number of periods for simulation\nQ = 100\n\n# Initialize arrays to store values for different periods\ny1 = np.ones(Q)\ny2 = np.ones(Q)\n\n# Solve the system recursively based on the initialization\nfor t in range(1, Q):\n    y1[t] = J[0, 0] * y1[t - 1] + J[0, 1] * y2[t - 1]\n    y2[t] = J[1, 0] * y1[t - 1] + J[1, 1] * y2[t - 1]\n\n# Plot dynamics of y1\nplt.plot(range(Q), y1, color='b', linewidth=2)\nplt.xlabel('Time')\nplt.ylabel('y1')\nplt.title('Dynamics of y1')\nplt.show()\n\n\n# Define the initial conditions y0\ny0 = np.array([y1[0], y2[0]])\n\n# Calculate the arbitrary constants c using the normalized eigenvectors\nc = np.linalg.inv(evecs_norm).dot(y0)\nc\n\n## Compute solution manually for y2 at t=10 and compare with simulated solution\nt = 10 +1\nevecs_norm[1, 1] * c[0] * evals[0] ** t + evecs_norm[1, 1] * c[1] * evals[1] ** t\ny2[t-1]\n\n\n# Calculate the ratio y2/y1\ny2_y1 = y2 / y1\n\n# Plot dynamics of y2/y1 for the first 50 periods\nplt.plot(y2_y1[:50], color='black', linewidth=2, linestyle='-')\nplt.xlabel('Time')\nplt.ylabel('y2/y1')\nplt.show()\n\n# Compare y2/y1 with normalised dominant eigenvector\ny2_y1[Q-1]\nevecs_norm[1,0]\n\n\n\n\nIt can be seen that the simulated results are equivalent to the results we obtained analytically. The key takeaway is that by deriving information about the eigenvalues (and possibly eigenvectors) of the coefficient matrix of the system, we are able to deduce knowledge of the dynamic properties of the system even without numerical simulation. However, the more complex the dynamic system, the more difficult this will be, thereby rendering numerical simulation a key tool to supplement formal analysis.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#an-economic-example-samuelsons-1939-multiplier-accelerator-model",
    "href": "intro_stability_analysis.html#an-economic-example-samuelsons-1939-multiplier-accelerator-model",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "An economic example: Samuelson’s (1939) multiplier accelerator model",
    "text": "An economic example: Samuelson’s (1939) multiplier accelerator model\nConsider the multiplier accelerator model by Samuelson (1939) discussed in Chapter 2:\n\\[\nC_t= c_1(C_{t-1} + I_{t-1} + G_0)\n\\]\n\\[\nI_t= \\beta[c_1(C_{t-1} + I_{t-1} + G_0) - C_{t-1}]\n\\]\nThis is a two-dimensional first-order system with state variables \\(C_t\\) and \\(I_t\\).\nThe coefficient matrix of this model is given by:\n\\[\nA = \\begin{bmatrix} \\frac{\\partial C_t}{\\partial C_{t-1}}& \\frac{\\partial C_t}{\\partial I_{t-1}} \\\\ \\frac{\\partial I_t}{\\partial C_{t-1}}  & \\frac{\\partial I_t}{\\partial I_{t-1}}  \\end{bmatrix}=\\begin{bmatrix} c_1 & c_1 \\\\ \\beta(c_1-1) & \\beta c_1 \\end{bmatrix}\n\\]\nThe characteristic polynomial yielding the eigenvalues of \\(A\\) is\n\\[\\lambda^2-\\lambda c_1(1+\\beta)+\\beta c_1=0,\\]\nwhere \\(c_1(1+\\beta) =tr(J)\\) and \\(\\beta c_1 = det(J)\\).\nThus we have\n\\[\n\\lambda_{1,2} = \\frac{c_1(1+\\beta) \\pm \\sqrt{[c_1(1+\\beta)]^2-4\\beta c_1}}{2}.\n\\]\nAssuming \\(c_1=0.8\\) and \\(\\beta=0.3\\), we can compute the eigenvalues:\n\n# Set fixed parameter values\nc1=0.8\nbeta=0.3\n\n## Compute eigenvalues\n# Define coefficient matrix\nA=matrix(c(c1, c1,\n           beta*(c1-1), beta*c1), \n           2, 2, byrow=TRUE)\n\n# Obtain eigenvalues and eigenvectors\nev=eigen(A)\n(evals = ev$values)\n\n[1] 0.694356 0.345644\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Set parameter values\nc1 = 0.8\nbeta = 0.3\n\n# Define the coefficient matrix\nA = np.array([[c1, c1],\n              [beta * (c1 - 1), beta * c1]])\n\n# Calculate eigenvalues and eigenvectors\nevals, evecs = np.linalg.eig(A)\n\nprint(evals)\nprint(evals)\n\n\n\n\nand conclude that since the dominant eigenvalue is smaller than one (in absolute terms), the system is stable.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#complex-eigenvalues-and-cycles",
    "href": "intro_stability_analysis.html#complex-eigenvalues-and-cycles",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Complex eigenvalues and cycles",
    "text": "Complex eigenvalues and cycles\nSo far, we have discussed the case where the eigenvalues \\(\\lambda\\) are real numbers. However, what if the polynomial \\(det(A-\\lambda I)=0\\) does not yield real numbers? Recall that in the case of a second-order polynomial \\(\\lambda^2+b\\lambda+c=0\\), the two roots are given by \\(\\lambda_{1,2} = \\frac{-b \\pm \\sqrt{b^2-4c}}{2}\\). If the term under the root \\(\\Delta=b^2-4c\\), also called discriminant, becomes negative, the solution will be a complex number. More specifically, we can write:\n\\[\n\\lambda_{1,2} = \\frac{-b \\pm \\sqrt{b^2-4c}}{2}=\\frac{-b \\pm \\sqrt{4c-b^2}\\sqrt{-1}}{2} =\\frac{-b \\pm \\sqrt{4c-b^2}i}{2},\n\\]\nwhere \\(i=\\sqrt{-1}\\) is the imaginary number. The expression can also be written as:\n\\[\n\\lambda_{1,2} = \\frac{-b}{2} \\pm \\frac{\\sqrt{4c-b^2}}{2}i = h \\pm mi,\n\\]\nwhich is a pair of conjugate complex numbers containing a real part given by \\(h\\) and an imaginary part given by \\(m\\).\nConsider again the characteristic polynomial of the Samuelson (1939) model:\n\\[\n\\lambda_{1,2} = \\frac{c_1(1+\\beta) \\pm \\sqrt{[c_1(1+\\beta)]^2-4\\beta c_1}}{2}.\n\\]\nThe two eigenvalues will be a pair of complex conjugates if \\([c_1(1+\\beta)]^2-4\\beta c_1 &lt;0\\) or \\(c_1 &lt; \\frac{4\\beta}{(1+\\beta)^2}\\).\nSuppose we have \\(c_1=0.4\\) and \\(\\beta=2\\). Then the discriminant will be negative and the eigenvalues will be complex:\n\n#Clear the environment \nrm(list=ls(all=TRUE))\n\n# Set parameter values\nc1=0.4\nbeta=2\n\n# Check if discriminant is negative\n(c1*(1+beta))^2-4*c1*beta\n\n[1] -1.76\n\n## Find eigenvalues and eigenvectors of matrix\n# Define matrix\nA=matrix(c(c1, c1,\n           beta*(c1-1), beta*c1), \n           2, 2, byrow=TRUE)\n\n# Obtain eigenvalues and eigenvectors\nev=eigen(A)\n(evals = ev$values)\n\n[1] 0.6+0.663325i 0.6-0.663325i\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Set parameter values\nc1 = 0.4\nbeta = 2\n\n# Check if discriminant is negative\n(c1 * (1 + beta))**2 - 4 * c1 * beta\n\n# Define the matrix\nA = np.array([[c1, c1],\n              [beta * (c1 - 1), beta * c1]])\n\n# Calculate eigenvalues and eigenvectors\nevals, evecs = np.linalg.eig(A)\n\nprint(evals)\nprint(evals)\n\n\n\n\nAnother way of understanding the logic behind complex numbers is through a so-called Argand diagram that plots the real part of the eigenvalue on the horizontal and the imaginary part on the vertical axis. By Pythagoras’ theorem, the distance of the eigenvalue from the origin will then be given by \\(R=\\sqrt{h^2+m^2}\\). The value of \\(R\\) (which is always real-valued and positive) is called the modulus (or absolute value) of the complex eigenvalue and will contain important information about the dynamic stability of economic models that exhibit complex eigenvalues.\n\n### Draw Argand diagram\n\n# Save real and imaginary part of complex eigenvalue\nre=Re(evals[1])\nim=Im(evals[1])\n\n# Plot complex eigenvalue\npar(bty=\"l\")\nplot(re,im, type=\"o\", xlim=c(0, 1), ylim=c(0, 1), lwd=2, xlab=\"h\", ylab=\"m\", main=\"Argand diagram of complex eigenvalue\")\n\n# Plot unit circle\nX=seq(0, 1, by=0.001)\nY = sqrt(1 - X^2) \nlines(X,Y, type=\"l\", lty=\"dotted\")\n\n# Plot a ray from the origin to eigenvalue\nsegments(0,0,re,im, lty='solid')\n\n# Add labels\ntext(0.1, 0.025, expression(theta), cex=1)\ntext(0.1, 0.25, expression(R==sqrt(h^2+m^2)), cex=1)\ntext(re, im+0.05, expression(lambda==h+mi), cex=1)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Draw Argand diagram\n\n# Save real and imaginary part of complex eigenvalue\nre = evals[0].real\nim = evals[0].imag\n\n# Create a figure\nfig, ax = plt.subplots()\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_xlabel('h')\nax.set_ylabel('m')\nax.set_title('Argand diagram of complex eigenvalue')\n\n# Plot complex eigenvalue\nax.plot(re, im, 'o', markersize=8, color='k')\n\n# Plot unit circle\nX = np.linspace(0, 1, 100)\nY= np.sqrt(1-X**2)\nax.plot(X, Y, 'k--')\n\n# Plot a ray from the origin to the eigenvalue\nax.plot([0, re], [0, im], 'k-')\n\n# Add labels\nax.text(0.1, 0.025, r'$\\theta$', fontsize=12)\nax.text(0.001, 0.25, r'$R=\\sqrt{h^2+m^2}$', fontsize=12)\nax.text(re, im - 0.1, r'$\\lambda=h+mi$', fontsize=12)\n\nplt.show()\n\n\n\n\nThe angle \\(\\theta\\) of the line that connects the origin and the complex eigenvalue and the x-axis of the Argand diagram also contains information about the dynamics. To see this, note that the geometry of the complex number represented in the Argand diagram can also be expressed in trigonometric form: \\[\n\\sin\\theta=\\frac{m}{R}\n\\] \\[\n\\cos\\theta=\\frac{h}{R},\n\\]\nwhere \\(\\theta=\\arcsin (\\frac{m}{R}) =\\arccos (\\frac{h}{R})=\\arctan(\\frac{m}{h})\\)\nThus, we can write the complex eigenvalue also as:\n\\[\n\\lambda_{1,2}=R(\\cos\\theta \\pm \\sin\\theta \\times i).\n\\]\nBy De Moivre’s theorem, we have \\((\\cos\\theta \\pm \\sin\\theta \\times i)^t=(\\cos\\theta t \\pm \\sin\\theta t \\times i)\\). Thus, the solution to a dynamic system that exhibits complex eigenvalues will be of the form:\n\\[\ny_{1t}=v_{11}c_1 R_1^t(\\cos\\theta_1 t \\pm \\sin\\theta_1 t \\times i) +...+ y^*_1.\n\\]\nFrom this solution we can again deduce key information about the dynamics of the system based on the (complex) eigenvalues:\n\nstability will depend on the modulus: for \\(R&lt;\\) the system will be stable, for \\(R&gt;1\\) it will be unstable\nfrom the nature of the trigonometric functions \\(\\sin(\\theta t)\\) and \\(\\cos(\\theta t)\\), we know that system will exhibit periodic cyclical dynamics as \\(t\\) increases\nthe length of the cycles will be given by \\(L=\\frac{2\\pi}{\\theta}\\) and the frequency by \\(F=1/L=\\frac{\\theta}{2\\pi}\\)\n\nthe amplitude of the cycles will depend on the elements of the eigenvectors, the initial conditions, and \\(R\\).\n\nLet us simulate the Samuelson model with the parameterisation that yields complex eigenvalues to illustrate these results:\n\n# Calculate modulus\nmod=Mod(evals[1])\nmod\n\n[1] 0.8944272\n\n# Calculate cycle length\nL=(2*pi)/(acos(re/mod))\nL\n\n[1] 7.520433\n\n# Set number of periods for which you want to simulate\nQ=100\n\n# Set number of parameterisations that will be considered\nS=1\n\n# Construct matrices in which values for different periods will be stored; initialise at 1\nC=matrix(data=1, nrow=S, ncol=Q)\nI=matrix(data=1, nrow=S, ncol=Q)\n\n#Construct matrices for exogenous variable\nG0=matrix(data=5, nrow=S, ncol=Q)\n\n#Solve this system recursively based on the initialisation\nfor (t in 2:Q){\n    C[1,t] = c1*(C[1,t-1] + I[1,t-1] + G0[1,t])\n    I[1,t] = beta*(c1*(C[1,t-1] + I[1,t-1] + G0[1,t]) - C[1,t-1])\n  } # close t1me loop\n\n# Calculate output\nY=C+G0+I\n\n# Time series chart of output dynamics in Samuelson (1939) model\nplot(Y[1, 1:30],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Output fluctuations in Samuelson model with complex eigenvalues\", cex=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Calculate modulus\nmod = abs(evals[0])\nprint(mod)\n\n# Calculate cycle length\nimport math\nL = (2 * math.pi) / math.acos(re / mod)\nprint(L)\n\n# Set the number of periods and parameterizations\nQ = 100\nS = 1\n\n# Initialize matrices for consumption, investment, and exogenous government spending\nC = np.ones((S, Q))\nI = np.ones((S, Q))\nG0 = np.full((S, Q), 5)\n\n# Solve the system recursively based on the initialization\nfor t in range(1, Q):\n    C[0, t] = c1 * (C[0, t - 1] + I[0, t - 1] + G0[0, t])\n    I[0, t] = beta * (c1 * (C[0, t - 1] + I[0, t - 1] + G0[0, t]) - C[0, t - 1])\n\n# Calculate output\nY = C + G0 + I\n\n# Plot the time series chart of output dynamics\nplt.plot(Y[0, :30], color='k', linewidth=2, linestyle='-')\nplt.xlabel(\"Time\")\nplt.ylabel(\"Y\")\nplt.title(\"Output fluctuations in Samuelson model with complex eigenvalues\")\nplt.show()\n\n\n\n\nYou can see that the model generates cycles with a length (from peak/trough to peak/trough) of around 7.5 periods. Since the modulus is \\(R&lt;1\\), the system is stable and eventually converges to the equilibrium.\nA general condition for stability of 2D systems with complex eigenvalues can be derived by making use of the fact that \\(R=\\sqrt{h^2+m^2}= \\sqrt{ \\left( \\frac{b}{2} \\right) ^2 + \\left(\\frac{\\sqrt{4c-b^2}}{2}i \\right)^2} = \\sqrt{c}\\), where \\(b=tr(J)\\) and \\(c=det(J)\\).\nApplied to the modulus of the Samuelson model, this yields \\(R=\\sqrt{det(J)}=\\sqrt{\\beta c_1}\\). Thus, the stability condition is:\n\\[\\beta c_1&lt;1.\\]\nThe following code generates a plot that displays the condition for cycles and the stability condition in the \\((\\beta, c_1)\\)-space:\n\n# Create function for cycle condition: c1 &lt; (4*beta)/(1+beta)^2\ncyc= function (beta) {\n  (4*beta)/(1+beta)^2\n}\n\n# Create function for stability condition: c1 &lt; 1/beta\nstab= function (beta) {\n  1/beta\n}\n\n# Plot the two functions in (beta, c1)-space\ncurve(cyc, from = 0, to = 5, col = 1, xlab=expression(beta), ylab=expression(c[1]) , main=\"\",\n      lwd=1.5, n=10000, ylim=range(0, 1.5))\ncurve(stab, from = 0, to = 5, col = 2, lwd=1.5, n=10000, add = TRUE)\nlegend(\"topright\", legend = c(\"cycle condition\", \"stability condition\"), \n       col = c(1, 2), lwd = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create function for cycle condition using beta as argument\ndef cyc(beta):\n    return (4 * beta) / (1 + beta)**2\n\n# Create function for stability condition using beta as argument\ndef stab(beta):\n    return 1 / beta\n\n# Define the range of beta values\nbeta = np.linspace(0.001, 5, 10000)  # start from 0.001 to avoid division by zero\n\n# Plot the two functions in (beta, c1)-space\nplt.plot(beta, cyc(beta), label=\"cycle condition\", color='black', linewidth=1.5)\nplt.plot(beta, stab(beta), label=\"stability condition\", color='red', linewidth=1.5)\n\n# Set labels and title\nplt.xlabel(r'$\\beta$')\nplt.ylabel(r'$c_1$')\nplt.ylim(0, 2)\nplt.legend(loc=\"upper right\")\n\n# Display the plot\nplt.show()\n\n\n\n\nCombinations of \\(c_1\\) and \\(\\beta\\) below the cycle condition curve yield complex eigenvalues and thus cycles, while combinations below the stability condition curve yield an asymptotically stable equilibrium.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#nonlinear-systems",
    "href": "intro_stability_analysis.html#nonlinear-systems",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Nonlinear systems",
    "text": "Nonlinear systems\nSo far, we have analysed dynamic systems that are linear. However, in the more general case, a dynamic system may be nonlinear and of the form:\n\\[\ny_t=f(y_{t-1}).\n\\]\nAn \\(n\\)-dimensional nonlinear system may have multiple equilibria \\(y^*\\). To analyse the dynamic properties of such a system, we normally conduct a linear approximation in the neighbourhood of one of the equilibria. In that sense, the stability analysis of a nonlinear system has only local as opposed to global validity.\nMathematically, linearisation around an equilibrium point can be done by conducting a first-order Taylor expansion around that equilibrium:\n\\[\ny_t=f^i(y^*) + \\sum_{j=1}^{n}\\frac{\\partial f^i(y^*)}{\\partial y_{jt-1}}(y_{jt-1}-y_j^*),\n\\]\nwhere \\(i=1,2,...,n\\).\nThis yields a linear version of the system that can be written as:\n\\[\ny_{t}=Ay_{t-1}+B,\n\\]\nwhere \\(A_{11}=\\frac{\\partial f^1(y^*)}{y_{1t-1}}\\) and so forth.\nThe matrix \\(A\\) is the so-called Jacobian matrix of the system \\(f(y_{t-1})\\) evaluated at \\(y^*\\). The Jacobian matrix collects all partial derivatives of the state variables \\(y_t\\) with respect to each other, i.e. \\(\\frac{\\partial y_{1t}}{\\partial y_{1t-1}}\\), \\(\\frac{\\partial y_{1t}}{\\partial y_{2t-1}}\\), and so on.3 The linearised Jacobian matrix \\(A\\) can be obtained by plugging the equilibrium solutions for \\(y^*\\) into the Jacobian.\nIn practice, this means that to analyse the local stability of a nonlinear system, one needs to:\n\nfind the equilibrium solution \\(y^*\\) whose neighbourhood you want to analyse\ncompute the Jacobian matrix of \\(f(y_{t-1})\\)\n\nsubstitute \\(y^*\\) into the Jacobian and analyse the resulting matrix.\n\nAn example for the stability analysis of a simple two-dimensional nonlinear system can be found in Section 14.5.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#key-takeaways",
    "href": "intro_stability_analysis.html#key-takeaways",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "Key takeaways",
    "text": "Key takeaways\n\ndynamic models are systems of difference (or differential) equations\nthe stability of a system depends on (a combination of) its coefficients\nmore generally, the system’s dynamic properties (including stability) are encapsulated in the an matrix\nthe (dominant) eigenvalues of the Jacobian matrix indicate whether a system is\n\nstable (\\(\\lambda &lt; 1\\)) or unstable (\\(\\lambda &gt; 1\\))\nacyclical (\\(\\lambda \\in \\mathbb{R}\\)) or cyclical (\\(\\lambda \\in \\mathbb{C}\\))\n\n\nthe (dominant) eigenvectors mediate the impact of the eigenvalues in the dynamics\nnonlinear systems are analysed locally around one of its equilibria",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#a-simplified-recipe-for-analysing-dynamic-systems",
    "href": "intro_stability_analysis.html#a-simplified-recipe-for-analysing-dynamic-systems",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "A simplified recipe for analysing dynamic systems",
    "text": "A simplified recipe for analysing dynamic systems\n\nIdentify the state variables of your model, i.e. \\(y_t = f(y_{t-1})\\)\n\nSubstitute away any other endogenous variables that are not state variables (e.g. by using the equilibrium solutions of the endogenous variables that are determined simultaneously within every period)\nWrite your model as a system in the state variables only (with otherwise only exogenous parameters/variables)\nFind the steady state solutions to the state variables by setting \\(y_t = y_{t-1}=y^*\\)\n\nConstruct the Jacobian matrix of the system containing the partial derivatives of the state variables with respect to each other\nIf the model has nonlinearities, plug the steady state solutions into the Jacobian matrix\nCheck the stability of the system by relying on well-known stability conditions, e.g. those in Gandolfo (2009)\n\nCheck if other interesting properties can be derived (e.g. complex eigenvalues)\nConfirm your analytical results through numerical simulations, e.g. compute the eigenvalues, check the stability conditions, etc.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#references",
    "href": "intro_stability_analysis.html#references",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "References",
    "text": "References\n\n\n\n\nAnthony, Martin, and Michele Harvey. 2012. Linear Algebra: Concepts and Methods. Cambridge UK: Cambridge University Press.\n\n\nChiang, Alpha C, and Kevin Wainwright. 2005. Fundamental Methods of Mathematical Economics. 4th ed. New York: McGraw-Hill Education.\n\n\nGandolfo, Giancarlo. 2009. Economic Dynamics. Study Edition. 4th Edition. Springer.\n\n\nSamuelson, Paul A. 1939. “Interactions between the Multiplier Analysis and the Principle of Acceleration.” The Review of Economics and Statistics 21 (2): 75–78. https://doi.org/10.2307/1927758.\n\n\nSayama, Hiroki. 2015. Introduction to the Modeling and Analysis of Complex Systems. Open SUNY Textbooks, Milne Library.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "intro_stability_analysis.html#footnotes",
    "href": "intro_stability_analysis.html#footnotes",
    "title": "9  An Introduction to the Analysis of Dynamic Models",
    "section": "",
    "text": "We will focus here on difference instead of differential equations, i.e. on dynamics in discrete as opposed to continuous time. Most of the continuous-time counterpart is analogous to the material covered here. Sayama (2015) provides a very accessible and applied introduction to dynamic systems with Python code. An introductory treatment of the underlying mathematics is Chiang and Wainwright (2005), chaps. 15-19. Gandolfo (2009) provides a more advanced treatment of the mathematics as well as many economic examples. A great introduction to linear algebra is Anthony and Harvey (2012).↩︎\nThis is because in the product \\((PDP^{-1})(PDP^{-1})(PDP^{-1})...\\), each \\(P\\) cancels a \\(P^{-1}\\), except for the first \\(P\\) and last \\(P^{-1}\\).↩︎\nIn this way, the Jacobian matrix can be regarded as a more general version of the coefficient matrix in linear systems.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>An Introduction to the Analysis of Dynamic Models</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html",
    "href": "a_new_keynesian_3_equation_model.html",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "",
    "text": "Overview\nNew Keynesian dynamic general equilibrium models were developed in the 1990s and 2000s to guide monetary policy.1 They build on real business cycle models with rational expectations but introduce Keynesian frictions such as imperfect competition and nominal rigidities. While the structural forms of these models are typically complex as behavioural functions are derived from the intertemporal optimisation, the reduced-form of the benchmark models can be represented by three main equations: (i) an IS curve, (ii) a Phillips curve, (iii) and an interest rate rule.\nThe IS curve establishes a negative relationship between real income and the real interest rate. For a higher real interest rate, households will save more and thus consume less. The Phillips curve models inflation as a function of the output gap. A positive output gap (an economic expansion) leads to higher inflation. The monetary policy rule specifies how the central bank reacts to deviations of actual inflation from a politically determined inflation target.\nThe simplified version of the 3-equation model we consider here is directly taken from chapter 4 of Carlin and Soskice (2014). This is a short-run model in which prices are flexible but the capital stock is fixed. The focus is thus on goods market equilibrium rather than economic growth. In the Carlin-Soskice version, inflation expectations are assumed to be adaptive and the response of aggregate demand to a change in the interest rate is sluggish. This renders the model dynamic.2",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#the-model",
    "href": "a_new_keynesian_3_equation_model.html#the-model",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "The Model",
    "text": "The Model\n\\[\ny_t=A -a_1r_{t-1}\n\\tag{10.1}\\]\n\\[\n\\pi_t=\\pi_{t-1}+a_2(y_t -y_e)\n\\tag{10.2}\\]\n\\[\nr_s=\\frac{(A - y_e)}{a_1}\n\\tag{10.3}\\]\n\\[\nr_t = r_s + a_3(\\pi_t-\\pi^T)\n\\tag{10.4}\\]\nwhere \\(y\\), \\(A\\), \\(r\\), \\(\\pi\\), \\(y_e\\), \\(r_s\\), and \\(\\pi^T\\) are real output, autonomous demand (times the multiplier), the real interest rate, inflation, equilibrium output, the stabilising real interest rate, and the inflation target, respectively.\nEquation 10.1 is the IS curve or goods market equilibrium condition. Aggregate output adjusts to the level of aggregate demand, which is given by autonomous demand (times the multiplier) and a component that is negatively related to the (lagged) real interest rate via households’ saving (\\(a_1&gt;0\\)). Equation 10.2 is the Phillips curve. It is assumed that inflation is driven by adaptive expectations (\\(E[\\pi_{t+1}]=\\pi_{t-1}\\)) and positively related to the output gap \\((y_t-y_e)\\), i.e. \\(a_2&gt;0\\). By Equation 10.3, the stabilising real interest rate is that real interest rate that is consistent with equilibrium output (\\(y_e=A -a_1r_s\\)). Finally, the interest rate rule in Equation 10.4 specifies the real interest rate the central bank needs to set to minimise its loss function (see Section 10.5 below for a derivation). The parameter \\(a_3\\) is a composite one given by \\(a_3 = \\frac{1}{a_1(\\frac{1}{a_2 b} + a_2)} &gt;0\\). Although the central bank only sets the nominal interest rate \\(i = r + E[\\pi_{t+1}]\\) directly, the fact that expected inflation is predetermined in every period allows it to indirectly control the real interest rate.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#simulation",
    "href": "a_new_keynesian_3_equation_model.html#simulation",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. For all parameterisations, the system is initialised at the equilibrium \\((y^*,\\pi^*,r^*)=(y_e,\\pi^T, r_s)\\). Three scenarios will then be considered. In scenario 1, there is an increase in autonomous aggregate demand (\\(A\\)). In scenario 2, the central bank sets a higher inflation target (\\(\\pi^T\\)). Scenario 3 considers a rise in equilibrium output (\\(y_e\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(a_1\\)\n\\(a_2\\)\n\\(b\\)\n\\(A\\)\n\\(\\pi^T\\)\n\\(y_e\\)\n\n\n\n1: rise in aggregate demand (\\(A\\))\n0.3\n0.7\n1\n12\n2\n5\n\n\n2: higher inflation target (\\(\\pi^T\\))\n0.3\n0.7\n1\n10\n3\n5\n\n\n3: rise in equilibrium output (\\(y_e\\))\n0.3\n0.7\n1\n10\n2\n7\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=50\n\n# Set number of scenarios\nS=3\n\n# Set period in which shock/shift will occur\ns=5\n\n# Create (S x Q)-matrices that will contain the simulated data\ny=matrix(data=0,nrow=S,ncol=Q) # Income/output\np=matrix(data=0,nrow=S,ncol=Q) # Inflation rate\nr=matrix(data=0,nrow=S,ncol=Q) # Real interest rate\nrs=matrix(data=0,nrow=S,ncol=Q) # Stabilising interest rate\n\n# Set constant parameter values\na1=0.3  # Sensitivity of inflation with respect to output gap \na2=0.7  # Sensitivity of output with respect to interest rate\nb=1     # Sensitivity of central bank to inflation gap\na3=(a1*(1/(b*a2) + a2))^(-1)\n\n# Set parameter values for different scenarios\nA=matrix(data=10,nrow=S,ncol=Q) # autonomous spending\npt=matrix(data=2,nrow=S,ncol=Q) # Inflation target\nye=matrix(data=5,nrow=S,ncol=Q) # Potential output\n\nA[1,s:Q]=12  # scenario 1: AD boost  \npt[2,s:Q]=3  # scenario 2: higher inflation target\nye[3,s:Q]=7  # scenario 3: higher potential output\n\n# Initialise endogenous variables at equilibrium values\ny[,1]=ye[,1]\np[,1]=pt[,1]\nrs[,1]=(A[,1] - ye[,1])/a1 \nr[,1]=rs[,1]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    #(1) IS curve\n    y[i,t] = A[i,t] - a1*r[i,t-1]\n    \n    #(2) Phillips Curve\n    p[i,t] = p[i,t-1] +a2*(y[i,t]-ye[i,t])\n    \n    #(3) Stabilising interest rate\n    rs[i,t] = (A[i,t] - ye[i,t])/a1\n    \n    #(4) Monetary policy rule, solved for r\n    r[i,t] = rs[i,t] + a3*(p[i,t]-pt[i,t])\n  \n  } # close time loop\n}   # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 50\n\n# Set number of scenarios\nS = 3\n\n# Set period in which shock/shift will occur\ns = 5\n\n# Create (S x Q) arrays to store simulated data\ny = np.zeros((S, Q))  # Income/output\np = np.zeros((S, Q))  # Inflation rate\nr = np.zeros((S, Q))  # Real interest rate\nrs = np.zeros((S, Q))  # Stabilizing interest rate\n\n# Set constant parameter values\na1 = 0.3  # Sensitivity of inflation with respect to output gap\na2 = 0.7  # Sensitivity of output with respect to interest rate\nb = 1     # Sensitivity of the central bank to inflation gap\na3 = (a1 * (1 / (b * a2) + a2)) ** (-1)\n\n# Set parameter values for different scenarios\nA = np.full((S, Q), 10)  # Autonomous spending\npt = np.full((S, Q), 2)  # Inflation target\nye = np.full((S, Q), 5)  # Potential output\n\nA[0, s:Q] = 12  # Scenario 1: AD boost\npt[1, s:Q] = 3  # Scenario 2: Higher inflation target\nye[2, s:Q] = 7  # Scenario 3: Higher potential output\n\n# Initialize endogenous variables at equilibrium values\ny[:, 0] = ye[:, 0]\np[:, 0] = pt[:, 0]\nrs[:, 0] = (A[:, 0] - ye[:, 0]) / a1\nr[:, 0] = rs[:, 0]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        # (1) IS curve\n        y[i, t] = A[i, t] - a1 * r[i, t - 1]\n        # (2) Phillips Curve\n        p[i, t] = p[i, t - 1] + a2 * (y[i, t] - ye[i, t])\n        # (3) Stabilizing interest rate\n        rs[i, t] = (A[i, t] - ye[i, t]) / a1\n        # (4) Monetary policy rule, solved for r\n        r[i, t] = rs[i, t] + a3 * (p[i, t] - pt[i, t])\n\n\n\n\nPlots\nFigures 1-3 depict the response of the model’s key endogenous variables to various shifts. A permanent rise in aggregate demand (scenario 1) has an instantaneous expansionary effect on output, but also pushes inflation above the target. This induces the central bank to raise the interest rate, which brings down output below equilibrium in the next period. The central bank then gradually lowers the policy rate towards its new higher equilibrium value, where inflation is again stabilised at its target level.\n\n### Plot results\n\n### Plots\n# Set maximum period for plots\nTmax=15\n\n# Output under different scenarios\nplot(y[1, 1:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", xlim=range(2:(Tmax)), ylab=\"y\", ylim=range(y[1, 1:Tmax],y[3, 1:(Tmax)])) \ntitle(main=\"Figure 1: Output under different scenarios\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(y[2, 1:(Tmax+1)],lty=2, lwd=2)\nlines(y[3, 1:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: aggregate demand boost\", \"2: rise inflation target\", \"3: rise potential output\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Inflation under different scenarios\nplot(p[1, 1:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", xlim=range(2:(Tmax)), ylab=expression(pi), ylim=range(p[1, 2:Tmax],p[3, 2:(Tmax)])) \ntitle(main=\"Figure 2: Inflation under different scenarios\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(p[2, 1:(Tmax+1)],lty=2, lwd=2)\nlines(p[3, 1:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: aggregate demand boost\", \"2: rise inflation target\", \"3: rise potential output\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Policy rate under different scenarios\nplot(r[1, 2:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", xlim=range(1:(Tmax)), ylab=\"r\", ylim=range(r[1, 2:Tmax],r[3, 2:(Tmax)])) \ntitle(main=\"Figure 3: Policy rate under different scenarios\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(r[2, 2:(Tmax+1)],lty=2, lwd=2)\nlines(r[3, 2:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: aggregate demand boost\", \"2: rise inflation target\", \"3: rise potential output\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmax = 15\n\n# Plot output under different scenarios\nplt.figure(figsize=(8, 6))\nplt.plot(y[0, :Tmax + 1], label=\"Scenario 1: aggregate demand boost\",\n         color='k', linestyle='solid', linewidth=2)\nplt.plot(y[1, :Tmax + 1], label=\"Scenario 2: Rise inflation target\",\n         color='k', linestyle='dashed', linewidth=2)\nplt.plot(y[2, :Tmax + 1], label=\"Scenario 3: Rise potential output\",\n         color='k', linestyle='dotted', linewidth=2)\n\nplt.title(\"Output under Different Scenarios\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"y\")\nplt.xlim(1, Tmax)\nplt.ylim(np.min(y), np.max(y))\nplt.legend()\nplt.show()\n\n\n\n\nAn increase in the central bank’s inflation target (scenario 2) gradually raises the inflation rate to a new level. During the adjustment period, the interest rate falls, which temporarily allows for a higher level of output. However, there is no permanent expansionary effect.\nBy contrast, an increase in potential or equilibrium output (scenario 3) allows for a permanently higher level of output and a lower real interest rate.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#directed-graph",
    "href": "a_new_keynesian_3_equation_model.html#directed-graph",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n# Construct auxiliary Jacobian matrix for 7 variables: y, p, r, A, ye, rs, pt\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,0,1,1,0,0,0,\n               1,0,0,0,1,0,0,\n               0,1,0,0,0,1,1,\n               0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,\n               0,0,0,1,1,0,0,\n               0,0,0,0,0,0,0),7,7, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted=NULL)\n\n# Define node labels\nV(dg)$name=c(\"y\", expression(pi), \"r\", \"A\", expression(y[e]),expression(r[s]), expression(pi^T))\n\n# Plot directed graph\nplot(dg, main=\"Figure 4: Directed graph of 3-Equation model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Directed graph\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Define the Jacobian matrix\nM_mat = np.array([[0, 0, 1, 1, 0, 0, 0],\n                  [1, 0, 0, 0, 1, 0, 0],\n                  [0, 1, 0, 0, 0, 1, 1],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 1, 1, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0],\n                 ])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {\n    0: \"y\",\n    1: \"π\",\n    2: \"r\",\n    3: \"A\",\n    4: \"yₑ\",\n    5: \"rₛ\",\n    6: \"πᵀ\"\n}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 4, it can be seen that aggregate demand (\\(A\\)), equilibrium output (\\(y_e\\)), and the inflation target (\\(\\pi^T\\)) are the key exogenous variables of the model. All other variables are endogenous and form a closed loop (or cycle) within the system. The upper-right side of the graph represents the supply side, given by the equilibrium level of output and its effect on inflation. The upper-left side captures the demand side and its effect on actual output. The key endogenous variables, output, inflation, and the interest rate form the centre of the graph, where they stand in a triangular relationship to each other. Output drives inflation, which in turn impacts the real interest rate. The latter then feeds back into output. Structural changes in the relationship between demand and supply (e.g. excess demand) also impact the system through their effect on the stabilising interest rate (\\(r_s\\)).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#sec-analytical",
    "href": "a_new_keynesian_3_equation_model.html#sec-analytical",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nDerivation of core equations\nIS curve\nThe IS curve in Equation 10.1 is loosely based on the consumption Euler equation introduced in Chapter 3. Suppose there are two periods and the household maximises its utility function \\(U=\\ln(C_t) + \\beta \\ln(C_{t+1})\\) subject to the intertemporal budget constraint \\(C_t+\\frac{C_{t+1}}{1+r}=Y_t + \\frac{Y_{t+1}}{1+r}\\). Substituting the constraint into the objective function and differentiating with respect to \\(C_t\\) yields the first-order condition:\n\\[\nC_t = \\frac{C_{t+1}}{\\beta(1+r)}.\n\\]\nThis consumption Euler equation establishes the negative relationship between the real interest rate and expenditures in Equation 10.1.\nPC curve\nThe Phillips curve Equation 10.2 is derived from wage- and price-setting in imperfect labour markets.3 Consider the following wage- and price-setting functions: \\[\n\\frac{W}{P^E} = B + \\alpha(y_t - y_e) + z_w\n\\] \\[\nP=(1+\\mu)\\frac{W}{\\lambda},\n\\tag{10.5}\\]\ni.e. the nominal wage \\(W\\), adjusted for the expected price level, is increasing in the output gap, a factor \\(B\\) capturing unemployment benefits and the disutility of work as well as a vector \\(z_w\\) of wage-push factors. Prices are set based on a constant mark-up (\\(\\mu\\)) on unit labour cost (\\(\\frac{W}{\\lambda}\\)).\nIn equilibrium, the real wage is given by: \\(w_e = B + z_w\\). In a dynamic setting, wage setters will raise the expected real wage by \\(\\left(\\frac{W_t}{P_{t}^E}\\right) - \\left(\\frac{W_{t-1}}{P_{t-1}}\\right)=\\alpha(y_t - y_e)\\). Together with adaptive expectations for prices \\(\\hat{P_t^E} = \\hat{P}_{t-1}\\) and the approximation \\(\\hat{W_t} - \\hat{P_{t-1}} \\approx \\left(\\frac{W_t}{P_{t}^E}\\right) - \\left(\\frac{W_{t-1}}{P_{t-1}}\\right)\\), this yields the following equation for wage inflation: \\[\n\\hat{W_t} = \\hat{P}_{t-1} +\\alpha(y_t - y_e).\n\\tag{10.6}\\]\nTransforming equation Equation 10.5 into growth rates (\\(\\hat{P}=\\hat{W}\\)) and combining it with the wage-inflation equation Equation 10.6 yields the Phillips curve Equation 10.2.\nMonetary policy rule\nFinally, to derive the interest rate rule, start from the following central bank loss function:4\n\\[\nL=(y_t-y_e)^2 + b(\\pi_t - \\pi^T)^2.\n\\] Substituting the Phillips curve (Equation 10.2) into the loss function, differentiating with respect to \\(y_t\\), and simplifying yields the first-order condition:\n\\[\ny_t-y_e = -a_2b(\\pi-\\pi^T),\n\\]\nwhich can also be regarded as a monetary policy rule. Next, substitute the Phillips curve (Equation 10.2), the IS-curve (Equation 10.1), and the stabilising interest rate (Equation 10.3) into the monetary policy rule and define \\(a_3 = \\frac{1}{a_1(\\frac{1}{a_2b} + a_2)}\\), which yields the interest rate rule (Equation 10.4).\nEquilibrium solutions and stability analysis\nBy definition, in the steady state we have \\(y^*=y_e\\). This implies that \\(r^*=r_s\\). From this, it follows that \\(\\pi^* = \\pi^T\\).\nTo analyse the dynamic stability of the model, we rewrite it as a system of first-order difference equations. To this end, substitute Equation 10.1 into Equation 10.2, which yields: \\[\n\\pi_t = \\pi_{t-1} + a_2(A - a_1r_{t-1}-y_e)\n\\tag{10.7}\\]\nSubstitute this equation into Equation 10.4, which yields: \\[\nr_t= r_{s} + a_3[\\pi_{t-1} + a_2(A - a_1r_{t-1}-y_e) - \\pi^T].\n\\tag{10.8}\\]\nThe Jacobian matrix of the system in Equation 10.1, Equation 10.7, and Equation 10.8 is given by: \\[\nJ=\\begin{bmatrix} 0& 0 &-a_1 \\\\0 & 1 & -a_1 a_2 \\\\ 0 & a_3 & -a_1 a_2 a_3 \\end{bmatrix}.\n\\] The eigenvalues of the Jacobian can be obtained from the characteristic polynomial \\(\\lambda^3 - Tr(J)\\lambda^2 + [Det(J_1) + Det(J_2) + Det(J_3)]\\lambda - Det(J) = 0\\), where \\(Tr(J)\\) and \\(Det(J\\)) are the trace and determinant, respectively, and \\(Det(J_i)\\) refers to the \\(i_{th}\\) principal minor of the matrix. As there is a column in the Jacobian that only contains zeros, it follows that the matrix is singular and will have a zero determinant. In addition, all principal minors turn out to be zero. The characteristic polynomial thus reduces to \\(\\lambda^2[\\lambda - Tr(J)]=0\\). From this, it is immediate that \\(\\lambda_{1,2}=0\\) and \\(\\lambda_{3}=Tr(J)\\), where \\(Tr(J)=1-a_1a_2a_3=\\frac{1}{1+a_2^2b}\\). Stability requires the single real eigenvalue to be smaller than unity (in absolute terms). With \\(\\lambda_3=\\frac{1}{1+a_2^2b}\\), stability thus only requires \\(a_2 \\neq 0\\) and \\(b&gt;0\\), i.e. the output gap needs to impact inflation (otherwise the key channel through which interest rate policy brings inflation back on target is blocked) and the central bank needs to assign a (non-negative) loss to deviations of actual inflation from its target.5\nWe can verify these analytical solutions by comparing them with the results from the numerical solution:\n\n# Construct Jacobian matrix \nJ=matrix(c(0,0,-a1,\n           0,1,-a1*a2,\n           0,a3,-a1*a2*a3), 3, 3, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values &lt;- ev$values)\n\n[1] 0.6711409 0.0000000 0.0000000\n\n# Obtain determinant and trace\ndet(J)       # determinant\n\n[1] 0\n\nsum(diag(J)) # trace\n\n[1] 0.6711409\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Construct Jacobian matrix \nJ = np.array([[0, 0, -a1],\n          [0, 1, -a1 * a2],\n          [0, a3, -a1 * a2 * a3],])\n\n# Calculate eigenvalues\neigenvalues = np.linalg.eigvals(J)\n\n# Print the resulting eigenvalues\nprint(eigenvalues)\n\n# Calculate the determinant and trace of the Jacobian matrix\ndeterminant = np.linalg.det(J)\ntrace = np.trace(J)\nprint(determinant)\nprint(trace)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#references",
    "href": "a_new_keynesian_3_equation_model.html#references",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nCarlin, Wendy, and David Soskice. 2014. Macroeconomics. Instititions, Instability, and the Financial System. Oxford University Press.\n\n\nGalí, Jordi. 2018. “The State of New Keynesian Economics: A Partial Assessment.” Journal of Economic Perspectives 32 (3): 87–112. https://doi.org/10.1257/jep.32.3.87.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_new_keynesian_3_equation_model.html#footnotes",
    "href": "a_new_keynesian_3_equation_model.html#footnotes",
    "title": "\n10  A New Keynesian 3-Equation Model\n",
    "section": "",
    "text": "See Galí (2018) for an overview.↩︎\nNote that this is quite different from conventional New Keynesian dynamic general equilibrium models in which the dynamic element stems from agents with rational expectations that react to serially correlated shocks.↩︎\nSee chapter 2 of Carlin and Soskice (2014) for details.↩︎\nSee chapter 2 of Carlin and Soskice (2014) for details.↩︎\nAs mentioned in footnote 2, this property of the Carlin-Soskice model is very different from conventional New Keynesian models with rational expectations. In these models, variables such as output and inflation are driven by the ‘forward-looking’ behaviour of rational agents, i.e. they depend on expectational terms for their current values rather than lagged values. To ensure what is called ‘determinancy’, these forward-looking variables must adjust fast (or ‘jump’) to bring the economy back onto a path that is consistent with the optimising equilibrium. This requires the number of jump variables to be matched by an equal number of unstable roots (i.e. being outside the unit circle).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>A New Keynesian 3-Equation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html",
    "href": "a_conflict_inflation_model.html",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "",
    "text": "Overview\nThis model is a version of the conflicting-claims approach to inflation that has been developed in the Marxian and post-Keynesian tradition (Rowthorn (1977)).1 The conflict inflation approach argues that inflation is driven by distributional conflict between price-setting firms and wage-setting workers. Each social class aspires a share of real income that is inconsistent with the claims of the other class. Workers gradually adjust nominal wages to reach a real wage target. Firms, by contrast, gradually adjust prices to achieve an implicit real wage target. The (implicit) real wage target of firms may stem from an (explicit) profitability target. Profitability, in turn, depends on the unit cost of firms. With nominal wages being a key component of those unit cost, any attempt by workers to raise real wages through higher nominal wages will eat into firms’ profitability, which will respond by raising prices. Equally, any attempt by firms to raise profitability by setting higher prices will undermine real wages and evoke a response by workers. This interplay between mutually inconsistent claims drives the inflationary process and the equilibrium real wage. Distributional outcomes in this model depend on the distributional targets of workers and firms as well as their ability to adjust wages and prices, which in turn may be affected by their relative bargaining power and labour market institutions.\nWe present a simplified version of the three-sector conflict inflation model in Wildauer et al. (2023) that examines the inflationary and distributional effects of energy price shocks.2 A final output sector uses energy as an intermediate input. Exogenous shocks to the prices of energy inputs can trigger temporary ‘price-wage spirals’, where firms raise prices to defend their profit margins, which in turn induces workers to raise nominal wages, which prolongs the inflationary shocks. While real wages fall, the economy-wide profit share rises.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#the-model",
    "href": "a_conflict_inflation_model.html#the-model",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "The Model",
    "text": "The Model\nThe model is given by the following equations:\n\\[\n\\Omega_t = \\frac{w_t}{p_t}\n\\tag{11.1}\\] \\[\nw_{t}  = w_{t-1}\\left[ 1 + \\phi(\\Omega^W - \\Omega_{t-1}) \\right]\n\\tag{11.2}\\]\n\\[\np_t= p_{t-1} \\left[ 1 + \\psi (r^T - r_{t-1}) \\right]\n\\tag{11.3}\\]\n\\[\np^T_t=(1+\\theta^T)\\left(w_t + \\delta p_t^E\\right)  \n\\tag{11.4}\\]\n\\[\nr^T=\\frac{\\theta^T}{1+\\theta^T}\n\\tag{11.5}\\]\n\\[\nr_t=1-\\Omega_t - \\delta \\epsilon\n\\tag{11.6}\\] \\[\np^E_t = \\epsilon p_t\n\\tag{11.7}\\]\nwhere \\(\\Omega\\), \\(w\\), \\(p\\), \\(\\Omega^W\\), \\(r^T\\), \\(r\\), \\(p^T\\), and \\(p^E\\) are the real wage, the nominal wage, the price level, workers’ desired real wage, firms’ desired profit margin, the realised profit margin, firms’ desired price level, and the nominal energy price, respectively.\nEquation 11.1 defines the real wage \\(\\Omega\\). Equation 11.2 specifies the dynamics of wage setting. Workers set the growth rate of nominal wages proportionally to the gap between their target real wage \\(\\Omega^W\\) and the actual real wage \\(\\Omega\\).3 The target real wage of workers is taken to be exogenous in this version of the model.4 By Equation 11.3, firms set the price inflation rate in a symmetric manner, responding to the deviation of the desired profit margin \\(r^T\\) from the actual profit margin \\(r\\). Equation 11.4 specifies the desired price level of firms, which charge a desired markup \\(\\theta^T\\) on their unit variable cost. Unit costs in this model consist of two components: (i) unit labour cost given by \\(w_t\\) (where we normalise labour productivity to unity for simplicity such that \\(\\frac{Y}{L}=1\\)), and (ii) unit energy cost \\(\\delta p^E\\), where \\(\\delta =\\frac{E}{Y}\\) is the (exogenous) energy intensity and \\(p^E\\) is the nominal energy price. The profit margin is defined as profits over gross output: \\(r=\\frac{\\Pi}{pY}=\\frac{pY-wL-p^E E}{pY}\\). The target profit margin as implied by the desired price level is then \\(r^T = \\frac{p^T - (w_t + \\delta p^E) }{p^T}\\), yielding Equation 11.5. The desired markup \\(\\theta^T\\) is considered exogenous in this version of the model.5 The actual or realised profit margin is given by Equation 11.6, where \\(\\epsilon=\\frac{p^E}{p}\\) is the real energy price. Finally, by Equation 11.7, the real energy price \\(\\epsilon\\) is taken to be exogenous (and subject to shocks), implying that the nominal energy price must grow at the same rate as the price level.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#simulation",
    "href": "a_conflict_inflation_model.html#simulation",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. In scenario 2, the real energy price \\(\\epsilon\\) increases. In scenario 3, the target markup \\(\\theta^T\\) rises. In scenario 4, the target real wage \\(\\Omega^W\\) rises.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(\\phi\\)\n\\(\\psi\\)\n\\(\\delta\\)\n\\(\\epsilon\\)\n\\(\\theta^T\\)\n\\(\\Omega^W\\)\n\n\n\n1: baseline\n1\n1\n1\n0.55\n0.4\n0.2\n\n\n2: rise in real energy price \\((\\epsilon)\\)\n\n1\n1\n1\n0.8\n0.4\n0.2\n\n\n3: rise in target markup \\((\\theta^T)\\)\n\n1\n1\n1\n0.55\n0.6\n0.2\n\n\n4: rise in target real wage \\((\\Omega^W)\\)\n\n1\n1\n1\n0.55\n0.4\n0.3\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n#Set number of periods\nQ = 300\n\n# Set number of scenarios (including baselines)\nS=4\n\n# Set period in which exogenous shift will occur\nq=50\n\n#Create (S x Q) matrices in which equilibrium solutions from different parameterisations will be stored\nomega=matrix(data=0.5, nrow=S, ncol=Q)   # real wage\nw=matrix(data=0.1, nrow=S, ncol=Q)       # nominal wage\np=matrix(data=0.5, nrow=S, ncol=Q)       # price level\nw_hat=matrix(data=0.1, nrow=S, ncol=Q)   # growth rate of nominal wages\np_hat=matrix(data=0.1, nrow=S, ncol=Q)   # growth rate of prices = inflation rate\np_T=matrix(data=0.5, nrow=S, ncol=Q)     # firms' desired price level\nomega_f=matrix(data=0.5, nrow=S, ncol=Q) # firms' desired real wage \np_E=matrix(data=0.5, nrow=S, ncol=Q)   # nominal energy price\nr_T=matrix(data=0.5, nrow=S, ncol=Q)     # target profit margin\nr=matrix(data=0.5, nrow=S, ncol=Q)       # realised profit margin\n\n# Set constant parameter values\nphi=1     # adjustment speed of nominal wages\npsi=1   # adjustment speed of prices\ndelta=1   # energy intensity\n\n# Set and initialise exogenous variables/parameters that will be shifted\nepsilon=matrix(data=0.55, nrow=S, ncol=Q)  # real energy price\ntheta_T=matrix(data=0.4, nrow=S, ncol=Q)       # target markup\nomega_w=matrix(data=0.2, nrow=S, ncol=Q)   # target real wage of workers\n\n# Set parameter values for different scenarios\nepsilon[2,q:Q]=0.8 # scenario 2: rise in real energy price\ntheta_T[3,q:Q]=0.6     # scenario 3: rise in target markup\nomega_w[4,q:Q]=0.3 # scenario 4: rise in target real wage of workers\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n    \n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # iterate the model 1000-times in each period\n    \n    #(1) Real wage\n    omega[i,t] =w[i,t]/p[i,t]\n      \n    #(2) Nominal wage\n    w[i,t] = w[i,t-1]*(1 + phi*(omega_w[i,t-1] - omega[i,t-1]))\n    \n    #(3) Price level\n    p[i,t] = p[i, t-1]*(1 + psi*(r_T[i, t-1] - r[i, t-1]))\n    \n    #(4) Firms' desired real wage\n    omega_f[i,t] = w[i,t]/p_T[i,t]\n    \n    #(5) Firms' desired price level\n    p_T[i,t] = (1 + theta_T[i,t])*(w[i,t] + delta * p_E[i,t])\n    \n    #(6) Nominal energy price\n    p_E[i,t]=epsilon[i,t]*p[i,t]\n    \n    # Target profit margin\n    r_T[i, t-1] = theta_T[i, t]/(1 + theta_T[i, t])\n    \n    # Realised profit margin\n    r[i, t] = 1 - omega[i, t] - epsilon[i,t]*delta\n    \n    # Growth rate of nominal wages\n    w_hat[i,t]= (w[i,t]- w[i,t-1])/w[i,t-1]\n    \n    # Growth rate of prices = inflation rate\n    p_hat[i,t]= (p[i,t]- p[i,t-1])/p[i,t-1]\n\n  } # close iterations loop\n }  # close time loop\n}   # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 300\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which exogenous shift will occur\nq = 50\n\n# Create (S x Q) matrices in which equilibrium solutions from different parameterizations will be stored\nomega = np.full((S, Q), 0.5)  # real wage\nw = np.full((S, Q), 0.1)      # nominal wage\np = np.full((S, Q), 0.5)      # price level\nw_hat = np.full((S, Q), 0.1)  # growth rate of nominal wages\np_hat = np.full((S, Q), 0.1)  # growth rate of prices = inflation rate\np_T = np.full((S, Q), 0.5)    # firms' desired price level\nomega_f = np.full((S, Q), 0.5) # firms' desired real wage \np_E = np.full((S, Q), 0.5)  # nominal energy price\nr_T = np.full((S, Q), 0.5)    # target profit margin\nr = np.full((S, Q), 0.5)      # realised profit margin\n\n# Set constant parameter values\nphi = 1     # adjustment speed of nominal wages\npsi = 1   # adjustment speed of prices\ndelta = 1   # energy intensity\n\n# Set and initialize exogenous variables/parameters that will be shifted\nepsilon = np.full((S, Q), 0.55)  # real energy price\ntheta_T = np.full((S, Q), 0.4)       # target markup\nomega_w = np.full((S, Q), 0.2)   # target real wage of workers\n\n# Set parameter values for different scenarios\nepsilon[1, q:Q] = 0.8  # scenario 2: rise in real energy price\ntheta_T[2, q:Q] = 0.6      # scenario 3: rise in target markup\nomega_w[3, q:Q] = 0.3  # scenario 4: rise in target real wage of workers\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for _ in range(1000):  # iterate the model 1000-times in each period\n            \n            # (1) Real wage\n            omega[i, t] = w[i, t] / p[i, t]\n              \n            # (2) Nominal wage\n            w[i, t] = w[i, t-1] * (1 + phi * (omega_w[i, t-1] - omega[i, t-1]))\n            \n            # (3) Price level\n            p[i, t] = p[i, t-1] * (1 + psi * (r_T[i, t-1] - r[i, t-1]))\n            \n            # (4) Firms' desired real wage\n            omega_f[i, t] = w[i, t] / p_T[i, t]\n            \n            # (5) Firms' desired price level\n            p_T[i, t] = (1 + theta_T[i, t]) * (w[i, t] + delta * p_E[i, t])\n            \n            # (6) Nominal energy price\n            p_E[i, t] = epsilon[i, t] * p[i, t]\n            \n            # Target profit margin\n            r_T[i, t-1] = theta_T[i, t] / (1 + theta_T[i, t])\n            \n            # Realised profit margin\n            r[i, t] = 1 - omega[i, t] - epsilon[i, t] * delta\n            \n            # Growth rate of nominal wages\n            w_hat[i, t] = (w[i, t] - w[i, t-1]) / w[i, t-1]\n            \n            # Growth rate of prices = inflation rate\n            p_hat[i, t] = (p[i, t] - p[i, t-1]) / p[i, t-1]\n            \n\n\n\n\nPlots\nFigure 11.1 displays the dynamics of nominal wages and prices (in levels), both of which exhibit exponential growth. Figure 11.2 plots the corresponding growth rates: the price and wage inflation rates. It can be seen that after an initial adjustment period, both rates converge on the same value, implying a constant real wage (and a constant profit margin).\n\n# Set start and end periods for plots\nTmin =3\nTmax=300\n\n# Prices and wages (baseline)\nplot(p[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"p, w\") \ntitle(main=\"Prices and wages (baseline)\", cex=0.8)\nlines(w[1, Tmin:Tmax],lty=2)\nlegend(\"topleft\", legend=c(\"p\", \"w\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.1: Prices and wages (baseline)\n\n\n\n\n\n# Set start and end periods for plots\nTmin =3\nTmax=60\n\n# Price and wage inflation (in %) (baseline)\nplot(100*p_hat[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"%\", ylim=range(100*p_hat[1, Tmin:Tmax], 100*w_hat[1, Tmin:Tmax])) \ntitle(main=\"Price and wage inflation (baseline)\", cex=0.8)\nlines(100*w_hat[1, Tmin:Tmax],lty=2)\nlegend(\"topright\", legend=c(expression(hat(p)), expression(hat(w))),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.2: Price and wage inflation (baseline)\n\n\n\n\nFigure 11.3 displays the energy price shock (scenario 2), where the real energy price rises permanently.6 As a result, there is a bout in the inflation rate, followed by an increase in the wage inflation rate. This reaction may be characterised as a (temporary) ‘price-wage spiral’ (Wildauer et al. (2023)), where firms react to the cost shock by raising prices to protect their profit margins, which trigger a response by workers to defend their real wages, which prolongs the inflationary shock. However, the inflation rate then embarks on a gradual downward convergence towards a new equilibrium that is higher than the one before the shock. Since the price inflation rate exceeds the wage inflation rate during the adjustment process, the real wage falls in response to the increase in the real energy price.\n\n# Set start and end periods for plots\nTmin =10\nTmax=100\n\n# Inflation and real wage in energy price shock scenario\nplot(100*p_hat[2, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=expression(hat(p))) \ntitle(main=\"Wage and price inflation and real wage, energy price shock (scen. 2)\", cex=0.8)\nlines(100*w_hat[2, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(hat(w)), side = 2, line = 3, at=12)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(omega[2, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=3, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(omega[2, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(omega[2, Tmin:Tmax]))  \nmtext(expression(Omega), side = 4, line = 3)\nlegend(\"topright\", legend=c(expression(hat(p)),expression(hat(w)), expression(Omega)),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.3: Price and wage inflation and real wage (energy price shock)\n\n\n\n\nFigure 11.4 considers the scenario where the target markup of firms rises. The resulting dynamics are very similar to the energy price shock: the inflation rate spikes, triggering a response in nominal wages that is weaker than the increase in inflation. As a result, the real wage falls until a new equilibrium with a higher inflation rate has been reached. In contrast to the energy price shock, both the profit margin and the profit share must increase in this scenario.\n\n# Set start and end periods for plots\nTmin =30\nTmax=80\n\n# Inflation and real wage in scenario 3\nplot(100*p_hat[3, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=expression(hat(p))) \ntitle(main=\"Price and wage inflation and real wage, rise in target markup (scen. 3)\", cex=0.8)\nlines(100*w_hat[3, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(hat(w)), side = 2, line = 3, at=7)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(omega[3, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=3, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(omega[3, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(omega[3, Tmin:Tmax]))  \nmtext(expression(Omega), side = 4, line = 3)\nlegend(\"topright\", legend=c(expression(hat(p)),expression(hat(w)), expression(Omega)),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.4: Increase in target markup\n\n\n\n\nFigure 11.5 displays scenario 4, where the target real wage of workers rises. The wage inflation rate shoots up, which is followed by an increase in price inflation. As nominal wages temporarily grow faster than prices, the real wage increases. By implication, both profit share and margin will fall.\nTaken together, scenarios 3 and 4 illustrate that besides cost shocks, exogeneous changes in the price- and wage-setting behaviour of firm and workers, respectively, will change the equilibrium inflation rate as well as income distribution. Such changes could stem from increases in market power (scenario 3) or fiercer industrial action by workers (scenario 4). An increase of the claim of either party on total real output will result in elevated social conflict, reflected in an increase in the inflation rate. The resulting distributional effect will depend on which party initiates the conflict.\n\n# Inflation and real wage in scenario 4\nplot(100*p_hat[4, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=expression(hat(p)), ylim=range(100*p_hat[4, Tmin:Tmax], 100*w_hat[4, Tmin:Tmax])) \ntitle(main=\"Price and wage inflation real wage, rise in target real wage (scen. 4)\", cex=0.8)\nlines(100*w_hat[4, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(hat(w)), side = 2, line = 3, at=7.5)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(omega[4, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=3, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(omega[4, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(omega[4, Tmin:Tmax]))  \nmtext(expression(Omega), side = 4, line = 3)\nlegend(\"topright\", legend=c(expression(hat(p)),expression(hat(w)), expression(Omega)),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.5: Increase in target real wage of workers\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Plot (here only inflation in scenario 2)            \nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmin = 9   # Zero-based index (equivalent to Tmin=10 in R)\nTmax = 100\n\n# Set up the main plot\nfig, ax1 = plt.subplots()\n\n# Plot inflation rates (price and wage growth rates) on the primary y-axis\nax1.plot(100 * p_hat[1, Tmin:Tmax], label=r'$\\hat{p}$', color=\"black\", linewidth=2, linestyle=\"-\")  # price inflation\nax1.plot(100 * w_hat[1, Tmin:Tmax], label=r'$\\hat{w}$', color=\"black\", linewidth=2, linestyle=\"--\")  # wage inflation\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(r'$\\hat{p}$, $\\hat{w}$')\nax1.set_ylim(0, 30)  # Adjust this limit as needed based on your data\n\n# Add secondary y-axis for real wage\nax2 = ax1.twinx()\nax2.plot(omega[1, Tmin:Tmax], label=r'$\\Omega$', color=\"black\", linewidth=2, linestyle=\":\")  # real wage\nax2.set_ylabel(r'$\\Omega$')\nax2.set_ylim(0, 0.2)  # Set range based on omega values\n\n# Titles and legends\nplt.title(\"Wage and price inflation and real wage, energy price shock (scenario 2)\", fontsize=10)\nax1.legend(loc=\"upper left\", frameon=False, fontsize=8)\nax2.legend(loc=\"upper right\", frameon=False, fontsize=8)\n\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#a-closer-look-at-the-effect-of-energy-price-shocks-on-profits",
    "href": "a_conflict_inflation_model.html#a-closer-look-at-the-effect-of-energy-price-shocks-on-profits",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "A closer look at the effect of energy price shocks on profits",
    "text": "A closer look at the effect of energy price shocks on profits\nThe model can be used to study the effects of an energy price shock on different measures of profitability and income distribution. Table 2 provides an overview of these measures.\nTable 2: Measures of profits\n\n\n\n\n\n\n\n\n\nDefinition\nModel equation\nEffect of energy price shock7 \\((\\uparrow \\epsilon)\\)\n\n\n\n\nProfit margin = profit share of energy sector\n\\[ r^E = \\pi^E = \\frac{\\Pi^E}{p^E E} \\]\n\\[ r^E = \\frac{p^E E - w^E L^E}{p^E E} = 1 - \\frac{\\Omega^E}{\\epsilon} \\]\nPositive\n\n\nProfit margin of final output sector\n\\[ r = \\frac{\\Pi}{pY} \\]\n\\[ r = \\frac{pY - wL - p^E E}{pY} = 1 - \\Omega - \\delta \\epsilon \\]\nNegative\n\n\nProfit share of final output sector\n\\[ \\pi = \\frac{\\Pi}{pVA} \\]\n\\[ \\pi = \\frac{pY - wL - p^E E}{pY - p^E E} = 1 - \\frac{\\Omega}{1 - p^E \\epsilon} \\]\nAmbiguous\n\n\nTotal profit share\n\\[ \\pi^{Total} = \\frac{\\Pi + \\Pi^E}{pY} \\]\n\\[ \\pi^{Total} = \\frac{pY - w^E L^E - wL}{pY} = 1 - \\delta \\Omega^E - \\Omega \\]\nPositive\n\n\n\nNote: \\(\\Pi\\) represents nominal profits, \\(E\\) is the output of the energy sector, which is an input to the final output \\(Y\\). The real wage of the energy sector \\(\\Omega^E = w^E/p\\) is exogenous. Labour productivity in both sectors is normalised to unity: \\(L^E / E = L / Y = 1\\). \\(VA\\) is value added.\nThe profit margin \\(r\\) is defined as the share of profits in gross output. By contrast, the profit share \\(\\pi\\) is defined as the share of profits in value added, i.e. output net of intermediate inputs. For the energy sector, which in this model does not use any intermediate inputs, the profit margin and profit share coincide. With the real wage in the energy sector assumed exogenous, a real energy price increase will unambiguously raise the profits of the energy sector. For the final output sector that uses energy as an input, an energy price shock will lower the profit margin due to the increase in energy cost. However, the effect on the final output sector’s profit share are ambiguous and will depend on the relative ability of workers and firms to defend their income targets in response to the shock. Finally, the total profit share incorporates the profits of the energy input sector and the final output sector (this assumes that the energy sector is domestic). An increase in the real energy price has an unambiguously positive effect on the economy-wide profit share.\nIn Figure 11.6, it can be seen how the energy price shock affects the profit margin and profit share of the final output sector in the simulations. While the profit margin falls due to the increase in energy cost, the profit share rises. This is because for the chosen parameterisation, we have \\(\\psi r^T-\\phi\\Omega^W&gt;0\\), for which \\(\\frac{\\partial \\pi}{\\partial \\epsilon} &gt; 0\\).8 Thus, if the price-setting power of firms and their target profit margins \\(\\psi r^T\\) are sufficiently large relative to wage-setting power and real wage target of workers \\(\\phi\\Omega^W\\), profit shares of domestic non-energy sectors may rise in response to an energy cost shock.\n\n# Calculate final output profit share\npi=(p-w-p_E*delta)/(p-p_E*delta)\n\n# Check if psi*r_T &gt; phi*omega_w, implying that the effect of an energy price increase on the profit share of the final output sector is positive\nprint(psi*r_T[1,1] - phi*omega_w[1,1] &gt;0)\n\n[1] TRUE\n\n# Plot profit margin and profit share in energy price shock scenario\nplot(r[2, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"r,\", ylim=range(r[2, Tmin:Tmax], pi[2, Tmin:Tmax])) \ntitle(main=\"Profit margin vs profit share, energy price shock (scenario 2)\", cex=0.8)\nlines(pi[2, Tmin:Tmax],lty=2, lwd=2)\nmtext(expression(pi), side = 2, line = 3, at=0.4)\nlegend(\"right\", legend=c(\"r\", expression(pi)),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 11.6: Profit margin and profit share (energy price shock)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#directed-graph",
    "href": "a_conflict_inflation_model.html#directed-graph",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 9 variables: \n  # endogenous: (1) Omega, (2) w, (3) p, (4) r^T, (5) r, (6) p_E\n  # exogenous: (7) epsilon, (8) \\theta^T, (9) Omega^W\n\n              #O w p rF r g e mF OW\nM_mat=matrix(c(0,1,1, 0,0,0,0, 0, 0,  # Omega\n               1,0,0, 0,0,0,0, 0, 1,  # w\n               0,0,0, 1,1,0,0, 0, 0,  # p\n               0,0,0, 0,0,0,0, 1, 0,  # rf\n               1,0,0, 0,0,0,1, 0, 0,  # r\n               0,0,1, 0,0,0,1, 0, 0,  # p_E\n               0,0,0, 0,0,0,0, 0, 0,  # epsilon\n               0,0,0, 0,0,0,0, 0, 0,  # \\theta^T\n               0,0,0, 0,0,0,0, 0, 0),  # Omega^W\n               9, 9, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(expression(Omega), \"w\", \"p\", expression(r^T), \"r\",\n             expression(p^E), expression(epsilon), expression(theta^T), expression(Omega^W))\n\n\n# Plot directed graph matrix\nplot(dg, main=\"Directed graph of conflict inflation model\", vertex.size=25, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.4, edge.width=1.1, edge.size=2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Directed graph\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 9 variables\n# endogenous: (1) Omega, (2) w, (3) p, (4) r^T, (5) r, (6) p_E\n# exogenous: (7) epsilon, (8) \\theta^T, (9) Omega^W\nM_mat = np.array([\n    [0, 1, 1, 0, 0, 0, 0, 0, 0],  # Omega\n    [1, 0, 0, 0, 0, 0, 0, 0, 1],  # w\n    [0, 0, 0, 1, 1, 0, 0, 0, 0],  # p\n    [0, 0, 0, 0, 0, 0, 0, 1, 0],  # r^T\n    [1, 0, 0, 0, 0, 0, 1, 0, 0],  # r\n    [0, 0, 1, 0, 0, 0, 1, 0, 0],  # p_E\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],  # epsilon\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],  # \\theta^T\n    [0, 0, 0, 0, 0, 0, 0, 0, 0]   # Omega^W\n])\n\n# Create adjacency matrix by transposing the auxiliary Jacobian matrix\nA_mat = M_mat.T\n\n# Create a directed graph from the adjacency matrix using networkx\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: r'$\\Omega$', 1: \"w\", 2: \"p\", 3: r'$r^T$', 4: \"r\", 5: r'$p^E$',\n            6: r'$\\epsilon$', 7: r'$\\theta^T$', 8: r'$\\Omega^W$'}\n\n# Plot the graph\npos = nx.spring_layout(G, k=0.6)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\n\nplt.title(\"Directed graph of conflict inflation model\", fontsize=12)\nplt.show()\n\n\n\n\nThe key exogenous variables in this version of the conflict inflation model are the real energy price \\(\\epsilon\\), the target markup \\(\\theta^T\\), and the target real wage of workers \\(\\Omega^W\\). The first two exogenous variables feed into the endogenous conflict inflation process via their impact on the realised profit margin \\(r\\) and the desired profit margin \\(r^T\\), respectively. The gap between desired and realised profit margins, in turn, impact price setting, the real wage, and then wage setting. By contrast, the target real wage of workers enters the inflationary process via its direct impact on nominal wages, which then impacts real wages, the realised profit margin, and then price setting. The directed graph thus highlights the joint determination and endogenous interaction of prices, wages, and income distribution.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#analytical-discussion",
    "href": "a_conflict_inflation_model.html#analytical-discussion",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo study the properties of the model, we reduce it to a first-order dynamic system in \\(w_t\\) and \\(p_t\\). To this end, substitute Equation 11.1 into Equation 11.2 to obtain the equation for \\(w_t\\). Next, substitute Equation 11.6, Equation 11.5 and Equation 11.1 into Equation 11.3. This gives the system:\n\\[\nw_{t+1} = w_{t}\\left[1+ \\phi\\left(\\Omega^W - \\frac{w_t}{p_t}\\right)\\right] \\\\\n\\tag{11.8}\\] \\[\np_{t+1} = p_{t} \\left[1+\\psi\\left(\\frac{w_t}{p_t} - \\frac{1}{1+\\theta^T} + \\delta \\epsilon \\right) \\right].\n\\tag{11.9}\\]\nNext, let’s introduce the definitions \\(\\frac{w_{t+1} -w_{t}}{w_{t}} = \\hat{w_t}\\) and \\(\\frac{p_{t+1} -p_{t}}{p_{t}} = \\hat{p_t}\\) for the growth rates of wages and prices, respectively. The equilibrium in this model is given by a real wage and inflation rate \\((\\Omega^*, \\hat{p}^*)\\) for which \\(\\hat{w_t}=\\hat{p_t}\\), i.e. wages and prices grow at the same rate, such that the real wage is constant. Imposing this equilibrium condition using Equation 11.8 and Equation 11.9 yields:\n\\[\\Omega^* = \\frac{\\phi \\Omega^W+ \\psi \\left(\\frac{1}{1+\\theta^T}- \\delta \\epsilon \\right)}{\\phi + \\psi}\n\\tag{11.10}\\]\nand\n\\[\n\\hat{p}^* = \\phi \\psi \\left[\\frac{ \\Omega^W - \\left(\\frac{1}{1+\\theta^T}- \\delta \\epsilon \\right)}{\\phi + \\psi}\\right],\n\\tag{11.11}\\]\nwhere the term \\(\\left(\\frac{1}{1+\\theta^T}- \\delta \\epsilon\\right)\\) can also be interpreted as firms’ implicit real wage target \\(\\Omega^F\\), such that for a positive equilibrium inflation rate \\(\\hat{p}^* &gt;0\\) , we need \\(\\Omega^W &gt; \\Omega^F = \\frac{1}{1+\\theta^T}- \\delta \\epsilon\\). Thus, workers’ and firms’ real wage targets need to be mutually inconsistent for inflation to emerge in equilibrium.\nWith these equilibrium solutions, we can show that increases in \\(\\theta^T\\) and \\(\\epsilon\\) reduce the equilibrium real wage and raise the equilibrium inflation rate, whereas increases in \\(\\Omega^W\\) raise the equilibrium real wage and raise the inflation rate:\n\\[\n\\frac{\\partial \\Omega^*} {\\partial \\theta^T} = -\\frac{\\psi}{(\\psi + \\phi)(1+\\theta^T)^2} &lt; 0,\n\\] \\[\n\\frac{\\partial \\hat{p}^*}{\\partial \\theta^T} = \\frac{\\phi\\psi}{(\\psi + \\phi)(1+\\theta^T)^2} &gt; 0,\n\\]\n\\[\n\\frac{\\partial \\Omega^*}{\\partial \\epsilon} = -\\frac{\\psi \\delta}{\\psi + \\phi} &lt; 0,\n\\] \\[\n\\frac{\\partial \\hat{p}^*}{\\partial \\epsilon} = \\frac{\\psi \\phi \\delta}{\\psi + \\phi} &gt; 0,\n\\]\n\\[\n\\frac{\\partial \\Omega^*} {\\partial \\Omega^W} = \\frac{\\phi}{\\psi + \\phi} &gt; 0,\n\\] \\[\n\\frac{\\partial \\hat{p}^*}{\\partial \\Omega^W} = \\frac{\\phi\\psi}{\\psi + \\phi} &gt; 0.\n\\]\nUsing the result for \\(\\frac{\\partial \\Omega^*}{\\partial \\epsilon}\\), we can easily work out the effects on the different measure of profitability listed in Table 2:\n\\[\n\\frac{\\partial r^E}{\\partial \\epsilon} = \\frac{\\Omega^E}{\\epsilon^2} &gt; 0,\n\\]\n\\[\n\\frac{\\partial r}{\\partial \\epsilon} =  -\\frac{\\delta \\phi}{\\psi + \\phi} &lt; 0,\n\\]\n\\[\n\\frac{\\partial \\pi}{\\partial \\epsilon} =   \\frac{\\delta(\\psi r^T-\\phi\\Omega^W)}{(\\psi + \\phi)(1-\\epsilon\\delta)^2} \\lesseqgtr 0,\n\\]\n\\[\n\\frac{\\partial \\pi^{Total}}{\\partial \\epsilon} =  \\frac{\\delta \\psi }{\\psi + \\phi} &gt; 0.\n\\]\nNext, to analyse dynamics of the model, we write down the Jacobian matrix of the system in Equation 11.8 and Equation 11.9:\n\\[\nJ(w,p)=\\begin{bmatrix}\n            1 + \\hat{w} - \\phi \\Omega & \\phi {\\Omega}^2   \\\\\n            \\psi & 1 + \\hat{p} - \\psi \\Omega   \\\\\n        \\end{bmatrix},\n\\] where we used \\(\\hat{w}=\\phi\\left(\\Omega^W - \\frac{w_t}{p_t}\\right)\\) and \\(\\hat{p}=\\psi\\left(\\frac{w_t}{p_t} - \\frac{1}{1+\\theta^T} + \\delta \\epsilon \\right)\\) to simplify the expressions inside the Jacobian.\nThe stability conditions for two-dimensional systems in discrete time are:\n\\[\n1+tr(J)+det(J)&gt;0,\n\\] \\[\n1-tr(J)+det(J)&gt;0,\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nWe know that this system will be unstable, because prices and wages will grow exponentially in equilibrium. We thus want to derive the condition under which the system becomes unstable and generates conflict inflation.\nImposing \\(\\hat{w_t}=\\hat{p_t}\\), the trace and determinant of the Jacobian matrix in equilibrium are given by:\n\\[\ntr(J)=2(1+\\hat{w}) - \\Omega(\\phi+\\psi),\n\\]\n\\[\\begin{equation}\n\n\\det(J)=1-\\Omega(\\phi+\\psi)+\\hat{w}[2+\\hat{w} - \\Omega(\\phi+\\psi)].\n\n\\end{equation}\n\\]\nLet’s focus on the second stability condition, which is:\n\\[\n1-tr(J)+det(J)= \\hat{w}[\\hat{w} - \\Omega(\\phi+\\psi)]&gt;0.\n\\]\nSubstituting the equilibrium solutions for \\(\\hat{w}^*\\) and \\(\\omega^*\\) into the term insight the square brackets yields:\n\\[\n-\\hat{w}^*\\left(\\frac{\\omega^W\\phi^2+(2\\phi+\\psi)\\psi \\Omega^F}{\\phi+\\psi}\\right)&lt;0.\n\\]\nThe term inside the brackets will be positive for meaningful economic values. The term outside the brackets will be negative if \\(\\hat{w}^*=\\hat{p^*}&gt;0\\), i.e. there is positive inflation, which in turn requires \\(\\Omega^W &gt; \\Omega^F\\), i.e. workers’ real wage target needs to exceed firms’ real wage target.\nWe can confirm these analytical results numerically. First, let’s confirm the solutions for the equilibrium real and the equilibrium inflation rate as well as the ‘instability condition’ that the target real wage of workers needs to exceed the target real wage of firms.\n\n## Check solution for equilibrium real wage\n# Analytical\n(omega_eq= (phi*omega_w[1,1]+psi*(1/(1+theta_T[1,1]) -delta*epsilon[1,1]))/(phi+psi))\n\n[1] 0.1821429\n\n# Numerical\nomega[1,Q]\n\n[1] 0.1821429\n\n## Check solution for equilibrium inflation rate\n# Analytical\nphi*psi*(omega_w[1,1]-(1/(1+theta_T[1,1]) -delta*epsilon[1,1]))/(phi+psi)\n\n[1] 0.01785714\n\n# Numerical\np_hat[1,Q]\n\n[1] 0.01785714\n\n## Check condition for instability: Omega^W &gt; Omega^F\nprint(omega_w[1,1] &gt; 1/(1+theta_T[1,1]) -delta*epsilon[1,1])\n\n[1] TRUE\n\n\nNext, we compute the Jacobian matrix of the simulated model (for the baseline), obtain the eigenvalues, eigenvectors, trace, and determinant. We then check the stability conditions. We find that the second stability condition is indeed violated.\n\n## Check eigenvalues of Jacobian matrix\n# Define matrix\nJ=matrix(c(1+p_hat[1,Q]-phi*omega[1,Q], phi*omega[1,Q]^2,\n           psi, 1+p_hat[1,Q]-psi*omega[1,Q]), \n           2, 2, byrow=TRUE)\n\n# Obtain eigenvalues \nev=eigen(J)\n(evals = ev$values)\n\n[1] 1.0178571 0.6535714\n\nevecs = ev$vectors\n\n# Obtain determinant and trace\ndet=det(J)      # determinant\ntr=sum(diag(J)) # trace\n\n#Check stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] FALSE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n\nFinally, following the approach presented in Chapter 9, we can check whether the ratio of the two unstable state variables \\(w_t\\) and \\(p_t\\), which is the real wage \\(\\Omega\\), approaches a value that is given by the ratios of the elements in the dominant eigenvector. To do this, we first normalise the eigenvectors by dividing through by the second element (which corresponds to the second state variable in our system, \\(p_t\\)). The first element in the normalised eigenvector should then correspond to the equilibrium real wage. This is indeed the case.\n\n# Normalise eigenvectors by dividing through by the second element\nevecs_norm=evecs\nfor (i in 1:2){\n  evecs_norm[,i]=evecs[,i]/evecs[2,i]\n}\n\n# Compare first element of normalised eigenvector with real wage Omega=w/p\nevecs_norm[1,1]\n\n[1] 0.1821429\n\nomega[1,Q] \n\n[1] 0.1821429\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\n### Analytical solutions\n# Analytical solution for equilibrium real wage\nprint((phi * omega_w[0, 0] + psi * (1 / (1 + theta_T[0, 0]) - delta * epsilon[0, 0])) / (phi + psi))\n\n# Numerical solution for equilibrium real wage\nprint(omega[0, Q-1])\n\n# Analytical solution for equilibrium inflation rate\nprint(phi * psi * (omega_w[0, 0] - (1 / (1 + theta_T[0, 0]) - delta * epsilon[0, 0])) / (phi + psi))\n\n# Numerical solution for equilibrium inflation rate\nprint(p_hat[0, Q-1]) \n\n# Check condition for instability: Omega^W &gt; Omega*\nprint( omega_w[0, 0] &gt; (1 / (1 + theta_T[0, 0]) - delta * epsilon[0, 0]))\n\n# Define the Jacobian matrix J\nJ = np.array([\n    [1 + p_hat[0, Q-1] - phi * omega[0, Q-1], phi * omega[0, Q-1]**2],\n    [psi, 1 + p_hat[0, Q-1] - psi * omega[0, Q-1]]\n])\n\n# Obtain eigenvalues and eigenvectors\nev = np.linalg.eig(J)\nevals = ev[0]  # eigenvalues\nevecs = ev[1]  # eigenvectors\nprint(evals)\nprint(evecs)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\nprint(det)\nprint(tr)\n\n# Check stability conditions\nprint(1 + tr + det &gt; 0)\nprint(1 - tr + det &gt; 0)\nprint(1 - det &gt; 0)\n\n# Normalise eigenvectors by dividing through by the second element\nevecs_norm = evecs.copy()  # Make a copy to modify\nfor i in range(2):\n    evecs_norm[:, i] = evecs[:, i] / evecs[1, i]  # Normalize by the second element\n\n# Compare first element of normalized eigenvector with real wage Omega = w/p\nprint(evecs_norm[0, 0])\nprint(omega[0, Q-1])",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#references",
    "href": "a_conflict_inflation_model.html#references",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nBlecker, Robert A., and Mark Setterfield. 2019. Heterodox Macroeconomics. Models of Demand, Distribution and Growth. Edward Elgar.\n\n\nHein, Eckhard. 2023. Macroeconmics After Kalecki and Keynes. Post-Keynesian Foundations. Edward Elgar.\n\n\nLavoie, Marc. 2022. Post-Keynesian Economics. New Foundations. 2nd ed. Edward Elgar.\n\n\nRowthorn, R. E. 1977. “Conflict, inflation and money.” Cambridge Journal of Economics 1 (3). https://doi.org/10.1093/oxfordjournals.cje.a035360.\n\n\nWildauer, Rafael, Karsten Kohler, Adam Aboobaker, and Alexander Guschanski. 2023. “Energy price shocks, conflict inflation, and income distribution in a three-sector model.” Energy Economics 127B. https://doi.org/10.1016/j.eneco.2023.106982.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_conflict_inflation_model.html#footnotes",
    "href": "a_conflict_inflation_model.html#footnotes",
    "title": "\n11  A Conflict Inflation Model\n",
    "section": "",
    "text": "With textbook treatments in Blecker and Setterfield (2019), chap. 5, Hein (2023), chap. 5, and Lavoie (2022), chap. 8.↩︎\nWildauer et al. (2023) use this model to study the 2021-23 inflationary episode in the US. Besides an energy sector providing intermediate inputs, they consider a final goods and a final services sector. In addition to the energy price shock, there is a positive demand shift towards goods and a negative supply shock due to lockdowns, creating a rise in the rate of capacity utilisation of the final goods sector. These additional shocks allow the final goods sector to raise its markup. The present simplified version of the model only considers the energy sector and a final output sector, and treats the markup of the final output sector as constant.↩︎\nThe growth rates of nominal wages and prices are defined as \\(\\hat{w_t}=\\frac{w_t - w_{t-1}}{w_{t-1}}\\) and \\(\\hat{p_t}=\\frac{p_t - p_{t-1}}{p_{t-1}}\\), respectively.↩︎\nBlecker and Setterfield (2019), chap. 5 and Lavoie (2022), chap. 8 analyse extensions which endogenise the real wage target of workers.↩︎\nIn Wildauer et al. (2023), the target markup of the final goods sector is endogenous with respect to the rate of capacity utilisation.↩︎\nMore accurately this is an energy price ‘shift’.↩︎\nWe derive the exact effects in the analytical discussion below.↩︎\nSee analytical discussion below.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>A Conflict Inflation Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html",
    "href": "a_sraffian_supermultiplier_model.html",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "",
    "text": "Overview\nThe Sraffian supermultiplier model was proposed by Serrano (1995) to integrate a Sraffian long-run equilibrium into a post-Keynesian growth model.1 The model requires the long-run rate of capacity utilisation to settle on an exogenously given normal rate. This requires investment to fully adjust to any changes in economic activity so as to bring back actual utilisation to the desired normal rate. As a result, investment expenditures (in the long-run) are assumed to be free of any idiosyncratic components such as Keynesian ‘animal spirits’. Long-run growth is then driven by those components of autonomous demand that do not create productive capacity – autonomous consumption in the simplest version of the model. An increase in the growth rate of autonomous consumption will stimulate economic activity and induce firms to adjust their expectations about long-run growth towards the new rate given by autonomous demand growth.\nIncome distribution is exogenous in this model. An increase in the wage share has an expansionary effect on economic activity and growth in the short-run as it increases consumption (investment is assumed to be independent of income distribution). However, this expansionary effect is only temporary as economic activity will eventually settle back on the normal rate of capacity utilisation, and the growth rate towards the rate given by autonomous demand growth. The absence of long-run effects of income distribution on output and growth constitutes a key difference between the Sraffian supermultiplier model and the post-Kaleckian model, in which there is no normal rate of capacity utilisation and no autonomous (non-capacity creating) demand.\nThis is a model of long-run steady state growth. In the steady state, all endogenous variables grow at the same rate.2 The model contains two state variables that determine the model’s dynamics: the ratio of autonomous demand to the capital stock (which changes during adjustment periods where the growth rate has not yet settled on the rate given by autonomous demand growth) and the expected growth rate of the capital stock, which sluggishly adjusts to the rate given by autonomous demand growth. We consider a continuous-time version of the model presented in chapter 6.5.8 of Lavoie (2022) .3",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#the-model",
    "href": "a_sraffian_supermultiplier_model.html#the-model",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "The Model",
    "text": "The Model\nThe following equations describe the model: \\[\nr_t=\\pi u_t\n\\tag{12.1}\\] \\[\ns_t=-z_t + s_r r_t\n\\tag{12.2}\\] \\[\nc_t= u_t-s_t\n\\tag{12.3}\\] \\[\ng_t=g^0_t+g_1(u_t-u_n)\n\\tag{12.4}\\] \\[\nu_t=c_t+g_t\n\\tag{12.5}\\] \\[\n\\dot{g^0_t}=\\mu(g_t-g^0_t)\n\\tag{12.6}\\] \\[\n\\dot{z_t}=z_t(g_z-g_t),\n\\tag{12.7}\\]\nwhere \\(r\\), \\(s\\), \\(c\\), \\(g\\), \\(u\\), \\(g^0\\), and \\(z\\) are the profit rate, the saving rate, the consumption rate, the investment rate, the rate of capacity utilisation, the expected growth rate, and the rate of autonomous demand, respectively. A dot over a variable represents the derivative with respect to time (\\(\\dot{x}=\\frac{d x}{d t}\\)).\nEquation 12.1 decomposes the profit rate (total profits over capital stock) into the product of the profit share \\(\\pi\\) (total profits over total output) and the rate of capacity utilisation (actual output over capital stock).4 Note that the wage share is given by \\(1-\\pi\\). By Equation 12.2, the economy-wide saving rate is given by the negative of the rate of autonomous demand (\\(z\\)), which in this version of the model is autonomous consumption, i.e. dissaving, and saving out of profits (\\(s_r\\)). It is assumed that workers do not save. Equation 12.3 simply states that consumption is income not saved. According to Equation 12.4, investment is determined by an autonomous component \\(g_0\\) that will be specified below and by the deviation of capacity utilisation from its normal rate \\(u_n\\). In other words, firms expand capacity whenever the actual rate of utilisation exceeds the desired normal rate. Equation 12.5 is the goods market equilibrium condition assuming that the rate of capacity utilisation adjusts to clear the goods market in the short run. Equation 12.6 is a key equation in the Sraffian supermultiplier approach, which posits that firms (sluggishly) adjust the expected growth rate to the actual growth rate. Finally, Equation 12.7 is an identity that traces changes in the rate of autonomous demand that stem from (temporary) mismatches between the exogenously given growth rate of autonomous demand (\\(g_z\\)) and the actual growth rate.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#simulation",
    "href": "a_sraffian_supermultiplier_model.html#simulation",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. In scenario 2, the growth rate of autonomous demand \\(g_z\\) increases. In scenario 3, the profit share \\(\\pi\\) rises. In scenario 4, the normal rate of capacity utilisation \\(u_n\\) increases. The model is initialised at the equilibrium of the baseline parameterisation and the various shifts then occur in period 50.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(\\pi\\)\n\\(s_r\\)\n\\(g_1\\)\n\\(u_n\\)\n\\(\\mu\\)\n\\(g_z\\)\n\n\n\n1: baseline\n0.35\n0.8\n0.2\n0.75\n0.08\n0.02\n\n\n2: rise in autonomous demand growth (\\(g_z\\))\n0.35\n0.8\n0.2\n0.75\n0.08\n0.03\n\n\n3: rise in profit share (\\(\\pi\\))\n0.4\n0.8\n0.2\n0.75\n0.08\n0.02\n\n\n4: rise in normal rate of capacity utilisation (\\(u_n\\))\n0.35\n0.8\n0.2\n0.8\n0.08\n0.02\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n#Set number of periods\nQ = 1000\n\n# Set number of scenarios (including baselines)\nS=4\n\n# Set period in which exogenous shift will occur\nq=50\n\n#Create (S x Q) matrices in which equilibrium solutions from different parameterisations will be stored\nu=matrix(data=0,nrow=S,ncol=Q) # rate of capacity utilisation\ng=matrix(data=0,nrow=S,ncol=Q) # growth rate of capital stock\ns=matrix(data=0,nrow=S,ncol=Q) # saving rate\nc=matrix(data=0,nrow=S,ncol=Q) # consumption rate\nr=matrix(data=0,nrow=S,ncol=Q) # profit rate\ng0=matrix(data=0,nrow=S,ncol=Q)# expected growth rate of capital stock\nz=matrix(data=0,nrow=S,ncol=Q) # autonomous demand rate\n\n#Set constant parameter values\ng1=0.2  # Sensitivity of investment with respect to utilisation\nsr=0.8  # propensity to save out of profits\nmu=0.08 # adjustment speed of expected growth rate\nd=0.1   # time increment\n\n# Set and initialise exogenous variables/parameters that will be shifted\npi=matrix(data=0.35,nrow=S,ncol=Q) # profit share\ngz=matrix(data=0.02,nrow=S,ncol=Q) # growth rate of autonomous demand\nun=matrix(data=0.75,nrow=S,ncol=Q)  # normal rate of capacity utilisation\n\n# Set parameter values for different scenarios\ngz[2,q:Q]=0.03 # scenario 2: rise in autonomous demand growth\npi[3,q:Q]=0.4 # scenario 3: rise in profit share\nun[4,q:Q]=0.8 # scenario 4: rise in normal rate of utilisation\n\n# Initialise endogenous variables at equilibrium values\nu[,1]=un[,1]\ng[,1]=gz[,1]\ns[,1]=g[,1]\nc[,1]=un[,1]-s[,1]\ng0[,1]=gz[,1]\nz[,1]=sr*pi[,1]*un[,1]-gz[,1]\nr[,1]=pi[,1]*un[,1]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n    \n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # iterate the model 1000-times in each period\n    \n    #(1) Profit rate\n    r[i,t] =pi[i,t]*u[i,t]\n      \n    #(2) Saving\n    s[i,t] = -z[i,t] + sr*r[i,t]\n    \n    #(3) Consumption\n    c[i,t] = u[i,t] - s[i,t]\n    \n    #(4) Investment\n    g[i,t] = g0[i,t] +g1*(u[i,t] - un[i,t])\n    \n    #(5) Capacity utilisation\n    u[i,t] = c[i,t] + g[i,t]\n    \n    #(6) Dynamic adjustment of expected growth rate of capital stock\n    g0[i,t] = g0[i,t-1] + mu*(g[i,t-1]-g0[i,t-1])*d\n    \n    #(7) Dynamic adjustment of autonomous demand\n    z[i,t] = z[i,t-1] + z[i,t-1]*(gz[i,t-1] - g[i,t-1])*d\n\n  } # close iterations loop\n }  # close time loop\n}   # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 1000\n\n# Set number of scenarios (including baselines)\nS = 4\n\n# Set period in which exogenous shift will occur\nq = 50\n\n# Create (S x Q) matrices for equilibrium solutions\nu = np.zeros((S, Q))  # rate of capacity utilization\ng = np.zeros((S, Q))  # growth rate of capital stock\ns = np.zeros((S, Q))  # saving rate\nc = np.zeros((S, Q))  # consumption rate\nr = np.zeros((S, Q))  # profit rate\ng0 = np.zeros((S, Q))  # expected growth rate of capital stock\nz = np.zeros((S, Q))  # autonomous demand rate\n\n# Set constant parameter values\ng1 = 0.2  # Sensitivity of investment with respect to utilization\nsr = 0.8  # propensity to save out of profits\nmu = 0.08  # adjustment speed of expected growth rate\nd = 0.1   # time increment\n\n# Set and initialize exogenous variables/parameters that will be shifted\npi = np.full((S, Q), 0.35)  # profit share\ngz = np.full((S, Q), 0.02)  # growth rate of autonomous demand\nun = np.full((S, Q), 0.75)  # normal rate of capacity utilization\n\n# Set parameter values for different scenarios\ngz[1, q:] = 0.03  # scenario 2: rise in autonomous demand growth\npi[2, q:] = 0.4   # scenario 3: rise in profit share\nun[3, q:] = 0.8   # scenario 4: rise in normal rate of utilization\n\n# Initialize endogenous variables at equilibrium values\nu[:, 0] = un[:, 0]\ng[:, 0] = gz[:, 0]\ns[:, 0] = g[:, 0]\nc[:, 0] = un[:, 0] - s[:, 0]\ng0[:, 0] = gz[:, 0]\nz[:, 0] = sr * pi[:, 0] * un[:, 0] - gz[:, 0]\nr[:, 0] = pi[:, 0] * un[:, 0]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for iterations in range(1000):  # iterate the model 1000 times in each period\n\n            # (1) Profit rate\n            r[i, t] = pi[i, t] * u[i, t]\n\n            # (2) Saving\n            s[i, t] = -z[i, t] + sr * r[i, t]\n\n            # (3) Consumption\n            c[i, t] = u[i, t] - s[i, t]\n\n            # (4) Investment\n            g[i, t] = g0[i, t] + g1 * (u[i, t] - un[i, t])\n\n            # (5) Capacity utilization\n            u[i, t] = c[i, t] + g[i, t]\n\n            # (6) Dynamic adjustment of expected growth rate of capital stock\n            g0[i, t] = g0[i, t - 1] + mu * (g[i, t - 1] - g0[i, t - 1]) * d\n\n            # (7) Dynamic adjustment of autonomous demand\n            z[i, t] = z[i, t - 1] + z[i, t - 1] * (gz[i, t - 1] - g[i, t - 1]) * d\n\n\n\n\nPlots\nFigures 1-3 depict the response of the three main endogenous variables to changes in the exogenous variables. In the second scenario (solid line), the growth rate of autonomous demand increases from 2% to 3%. As a result, the rate of capacity temporarily increases but then returns to the level given by the normal rate, as the rate of autonomous demand falls due to the increase in the capital stock. By contrast, the growth rate permanently settles to the new rate given by the autonomous rate.\nIn the third scenario (dashed line), the profit share rises, which initially has a contractionary effect on the rate of utilisation and growth. Both variables then briefly overshoot due to the increase in the autonomous demand rate and then return to their previous values.\n\n# Set maximum period for plots\nTmax=700\n\n# Capacity utilisation\nplot(u[2, 2:(Tmax+1)], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'u',xlab = 'Time',ylim=range(max(u[, 2:Tmax]),min(u[, 2:Tmax])),cex.axis=1,cex.lab=0.75)\ntitle(main=\"Figure 1: Rate of capacity utilisation under different scenarios\",cex=0.8 ,line=2)\nlines(u[3, 2:(Tmax+1)],lty=2)\nlines(u[4, 2:(Tmax+1)],lty=3)\nlegend(\"bottomright\", legend=c(\"Rise autom demand\", \"Rise profit share\", \"Rise normal rate\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Growth\nplot(g[2, 2:(Tmax+1)], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'g',xlab = 'Time',ylim=range(max(g[, 2:Tmax]),min(g[, 2:Tmax])),cex.axis=1,cex.lab=0.75)\ntitle(main=\"Figure 2: Growth rate under different scenarios\",cex=0.8 ,line=2)\nlines(g[3, 2:(Tmax+1)],lty=2)\nlines(g[4, 2:(Tmax+1)],lty=3)\nlegend(\"bottomright\", legend=c(\"Rise autom demand\", \"Rise profit share\", \"Rise normal rate\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Autonomous demand rate\nplot(z[2, 2:(Tmax+1)], type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     ylab = 'z',xlab = 'Time',ylim=range(max(z[, 2:Tmax]),min(z[, 2:Tmax])),cex.axis=1,cex.lab=0.75)\ntitle(main=\"Figure 3: Rate of autonomous demand under different scenarios\",cex=0.8 ,line=2)\nlines(z[3, 2:(Tmax+1)],lty=2)\nlines(z[4, 2:(Tmax+1)],lty=3)\nlegend(\"right\", legend=c(\"Rise autom demand\", \"Rise profit share\", \"Rise normal rate\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Plots (here for capacity utilisation only)\n\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmax = 700\n\n# Plot capacity utilization\nplt.plot(u[1, 1:Tmax], label='Rise autom demand', linestyle='-', linewidth=2, color='k')\nplt.plot(u[2, 1:Tmax], label='Rise profit share', linestyle='--', linewidth=2, color='k')\nplt.plot(u[3, 1:Tmax], label='Rise normal rate', linestyle='-.', linewidth=2, color='k')\nplt.title('Rate of Capacity Utilization under Different Scenarios')\nplt.xlabel('Time')\nplt.ylabel('u')\nplt.legend(loc='lower right')\nplt.show()\n\n\n\n\nFinally, a rise in the normal rate (dotted line) initially has contractionary effects on utilisation and growth but eventually raises utilisation to a permanently higher level. The growth rate returns to its previous value.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#directed-graph",
    "href": "a_sraffian_supermultiplier_model.html#directed-graph",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n# Construct auxiliary Jacobian matrix for 9 variables: \n# r, c, g, u, g0, z, pi, gz, un\n\nM_mat=matrix(c(0,0,0,1,0,0,1,0,0,\n               1,0,0,1,0,1,0,0,0,\n               0,0,0,1,1,0,0,0,1,\n               0,1,1,0,0,0,0,0,0,\n               0,0,1,0,0,0,0,0,0,\n               0,0,1,0,0,0,0,1,0,\n               0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0), 9, 9, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted=NULL)\n\n# Define node labels\nV(dg)$name=c(\"r\", \"c\", \"g\", \"u\", expression(g^0), \"z\", expression(pi), expression(g[z]), expression(u[n]))\n\n# Plot directed graph\nplot(dg, main=\"Figure 4: Directed graph of Sraffian Supermultiplier Model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Directed graph\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define the Jacobian matrix\nM_mat = np.array([[0, 0, 0, 1, 0, 0, 1, 0, 0],\n                  [1, 0, 0, 1, 0, 1, 0, 0, 0],\n                  [0, 0, 0, 1, 1, 0, 0, 0, 1],\n                  [0, 1, 1, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0, 0, 1, 0],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"r\", \n            1: \"c\",\n            2: \"g\",\n            3: \"u\",\n            4: r\"$g^0$\",\n            5: \"z\",\n            6: r\"$\\pi$\",\n            7: r\"$g_z$\",\n            8: r\"$u_n$\"}\n\n# Plot the directed graph\npos = nx.spring_layout(G, seed=43)  \nnx.draw(G, pos, with_labels=True, labels=nodelabs, node_size=300, node_color='lightblue', \n        font_size=10)\nedge_labels = {(u, v): '' for u, v in G.edges}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='black')\nplt.axis('off')\nplt.show()\n\n\n\n\nIn Figure 4, it can be seen that the growth rate of autonomous demand (\\(g_z\\)), the profit share (\\(\\pi\\)), and the normal rate of capacity utilisation (\\(u_n\\)) are the key exogenous variable of the model. The profit rate (\\(r\\)), consumption (\\(c\\)), the autonomous demand rate (\\(z\\)), investment (\\(g\\)), the rate of utilisation (\\(u\\)), an the expected growth rate (\\(g_0\\)) form a closed loop (or cycle) within the system. For example, an increase in the growth rate of autonomous demand increases consumption, which raises the rate of capacity utilisation, growth, and the expected growth rate. In a second-round effect, the increase in the growth rate then feeds back negatively into the autonomous demand rate, which leads to a return of the rate of capacity utilisation to its previous value.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#analytical-discussion",
    "href": "a_sraffian_supermultiplier_model.html#analytical-discussion",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the short-run equilibrium solutions for \\(u\\) and \\(g\\), first substitute Equation 12.1-Equation 12.4 into Equation 12.5 and solve for \\(u\\): \\[\nu^* = \\frac{g_0+z-g_1u_n}{s_r \\pi-g_1}.\n\\] From this, we get: \\[\ng^* = g_0 + g_1(u^* - u_n).\n\\] The long-run equilibrium is given by \\(u^{**}=u_n\\), \\(g^{**}=g_z\\), and (from Equation 12.7) \\(z^{**}=u_n s_r \\pi - g_z\\).\nThe dynamics are governed by Equation 12.6-Equation 12.7. The Jacobian matrix is: \\[\nJ(g^0, z)=\\begin{bmatrix} \\frac{\\mu g_1}{s_r\\pi-g_1}& \\frac{\\mu g_1}{s_r\\pi-g_1} \\\\ -z(\\frac{g_1}{s_r\\pi-g_1} +1)& \\frac{-zg_1}{s_r\\pi-g_1} \\end{bmatrix}.\n\\]\nThe determinant of the Jacobian matrix evaluated at the long-run equilibrium is: \\[\ndet(J^*) = \\frac{(u_n s_r \\pi - g_z)\\mu g_1}{s_r\\pi-g_1} &gt; 0,\n\\]\nwhich is positive provided \\(s_r\\pi-g_1\\), i.e. if the Keynesian stability condition holds.\nThe trace is:\n\\[\ntr(J^*) = \\frac{g_1(\\mu-u_n s_r \\pi + g_z)}{s_r\\pi-g_1}.\n\\]\nStability requires a negative trace, yielding a second stability condition: \\(\\mu&lt;u_n s_r \\pi - g_z\\).\nWe can verify these analytical solutions by comparing them with the results from the numerical solution:\n\n# Construct Jacobian matrix at the equilibrium \n\nJ=matrix(c((mu*g1)/(sr*pi[1,Q]-g1), (mu*g1)/(sr*pi[1,Q]-g1),\n           -z[1,Q]*(sr*pi[1,Q]/(sr*pi[1,Q]-g1)), -z[1,Q]*(g1/(sr*pi[1,Q]-g1))), 2, 2, byrow=TRUE)\nJ\n\n       [,1]   [,2]\n[1,]  0.200  0.200\n[2,] -0.665 -0.475\n\n# Obtain eigenvalues\nev=eigen(J)\n(values &lt;- ev$values)\n\n[1] -0.1375+0.1381801i -0.1375-0.1381801i\n\n# Obtain determinant and trace\ndet(J) # determinant\n\n[1] 0.038\n\nsum(diag(J)) # trace\n\n[1] -0.275\n\n# Check stability conditions for all scenarios\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(sr*pi[i,1]&gt;g1) # Keynesian stability condition\nprint(mu&lt;sr*un[i,1]*pi[i,1]-gz[i,1])\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Construct Jacobian matrix\nJ = np.array([\n    [(mu * g1) / (sr * pi[0, Q-1] - g1), (mu * g1) / (sr * pi[0, Q-1] - g1)],\n    [-z[0, Q-1] * (sr * pi[0, Q-1] / (sr * pi[0, Q-1] - g1)), -z[0, Q-1] * (g1 / (sr * pi[0, Q-1] - g1))]\n])\nprint(J)\n\n# Obtain eigenvalues, determinant, and trace\n\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\ndeterminant_J = np.linalg.det(J)\nprint(determinant_J)\n\ntrace_J = np.trace(J)\nprint(trace_J)\n\n# Check stability conditions for all scenarios\nfor i in range(1, S + 1):\n    print(f\"Scenario {i}:\")\n    print(sr * pi[i - 1, 0] &gt; g1)  # Keynesian stability condition\n    print(mu &lt; sr * un[i - 1, 0] * pi[i - 1, 0] - gz[i - 1, 0])",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#references",
    "href": "a_sraffian_supermultiplier_model.html#references",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "References",
    "text": "References\n\n\n\n\nBlecker, Robert A., and Mark Setterfield. 2019. Heterodox Macroeconomics. Models of Demand, Distribution and Growth. Edward Elgar.\n\n\nDutt, Amitava Krishna. 2018. “Some Observations on Models of Growth and Distribution with Autonomous Demand Growth.” Metroeconomica 70 (2): 288–301. https://doi.org/10.1111/meca.12234.\n\n\nLavoie, Marc. 2022. Post-Keynesian Economics. New Foundations. 2nd ed. Edward Elgar.\n\n\nSerrano, Franklin. 1995. “Long Period Effective Demand and the Sraffian Supermultiplier.” Contributions to Political Economy 14 (1): 67–90. https://doi.org/10.1093/oxfordjournals.cpe.a035642.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_sraffian_supermultiplier_model.html#footnotes",
    "href": "a_sraffian_supermultiplier_model.html#footnotes",
    "title": "\n12  A Sraffian Supermultiplier Model\n",
    "section": "",
    "text": "See chapter 7 in Blecker and Setterfield (2019), Dutt (2018), and chapter 6 in Lavoie (2022) for useful introductions. Note that contrary to what the name may suggest, this is a one-sector model.↩︎\nAll variables are normalised by the capital stock and thus rendered stationary.↩︎\nSection 2.6 explains how continuous time models can be solved numerically.↩︎\nFor simplicity, it is assumed that the capital-potential output ratio is equal to unity. This implies that the ratio of actual output to potential output is equal to the ratio of actual output to the capital stock, so that the latter can be taken as a measure of the rate of capacity utilisation.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>A Sraffian Supermultiplier Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html",
    "href": "a_malthusian_model.html",
    "title": "13  A Malthusian Model",
    "section": "",
    "text": "Overview\nThis model captures some key feature of Thomas Malthus’ theory of population dynamics as developed in his 1798 book An Essay on the Principle of Population. The theory revolves around the interaction between living standards and population growth.1 It assumes that birth rates increase with rising living standards, while death rates decline. Economic growth thus spurs population growth. However, due to supply constraints in agricultural production, population growth drives up food prices and thereby undermines real income, bringing population growth to a halt. The model is adapted from Karl Whelan’s lecture notes.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#the-model",
    "href": "a_malthusian_model.html#the-model",
    "title": "13  A Malthusian Model",
    "section": "The Model",
    "text": "The Model\nThe following equations describe the model:\n\\[\nN_t = N_{t-1} + B_{t-1} - D_{t-1}\n\\tag{13.1}\\]\n\\[\n\\frac{B_{t}}{N_t} = b_0 + b_1Y_t\n\\tag{13.2}\\]\n\\[\n\\frac{D_{t}}{N_t} = d_0 - d_1Y_t\n\\tag{13.3}\\]\n\\[\nY_t = a_0-a_1N_t\n\\tag{13.4}\\]\nwhere \\(N_t\\), \\(B_t\\), \\(D_t\\), and \\(Y_t\\) represent population, number of births, number of deaths, and real income, respectively.\nEquation 13.1 describes population dynamics as driven by births and deaths. Equation 13.2 and Equation 13.3 the Malthusian hypothesis that birth rates are positively and death rates negatively related to income. Equation 13.4 makes real income a negative function of the population, which captures the idea of supply constraints in agriculture.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#simulation",
    "href": "a_malthusian_model.html#simulation",
    "title": "13  A Malthusian Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable reports the parameterisation and initial values used in the simulation. Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenario 2 models what Malthus called preventative checks: a fall in the exogenous component of the birth rate (\\(b_0\\)) due to an increased use of contraception, changes in marriage norms etc. Scenario 3 models`positive checks’: a rise in the sensitivity of real income with respect to the population (\\(a_1\\)), capturing factors such as increased food scarcity. Scenario 4 considers a rise in the exogenous component of real income (\\(a_0\\)), which could be interpreted as a productivity boost due to the invention of better fertilisers. All scenarios initialise the population below its steady state value at \\(N_0=1\\) and the other variables at their steady state values.\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(b_0\\)\n\\(b_1\\)\n\\(d_0\\)\n\\(d_1\\)\n\\(a_0\\)\n\\(a_1\\)\n\n\n\n1: baseline\n0.5\n0.5\n2.5\n0.5\n2.5\n0.05\n\n\n2: fall in exog birth rate (\\(b_0\\))\n0.4\n0.5\n2.5\n0.5\n2.5\n0.05\n\n\n3: rise in sensitivity of income (\\(a_1\\))\n0.5\n0.5\n2.5\n0.5\n2.5\n0.07\n\n\n4: productivity boost (\\(a_0\\))\n0.5\n0.5\n2.5\n0.5\n2.6\n0.05\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nT=100\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=5\n\n# Create (S x T)-matrices that will contain the simulated data\nN=matrix(data=0,nrow=S,ncol=T) # population\nY=matrix(data=0,nrow=S,ncol=T) # real income\nB=matrix(data=0,nrow=S,ncol=T) # births\nD=matrix(data=0,nrow=S,ncol=T) # deaths\nN_eq=vector(length=S)          # equilibrium population\nY_eq=vector(length=S)          # equilibrium real income\nB_eq=vector(length=S)          # equilibrium births\nD_eq=vector(length=S)          # equilibrium deaths\n\n# Set baseline parameter values\nb0=matrix(data=0.5,nrow=S,ncol=T) # Exogenous birth rate\nb1=0.5 # Sensitivity of births with respect to real income\nd0=2.5 # Exogenous death rate\nd1=0.5 # Sensitivity of deaths with respect to real income\na0=matrix(data=2.5,nrow=S,ncol=T) # Exogenous component of real income \na1=matrix(data=0.05,nrow=S,ncol=T) #Sensitivity of the real income with respect to population\n\n# Set parameter values for different scenarios\nb0[2,s:T]=0.4  # scenario 2: reduction in birth rate\na1[3,s:T]=0.07 # scenario 3: increase in sensitivity of real income with respect to population\na0[4,s:T]=2.6  # scenario 4: improvement in productivity\n\n# Initialise \nN[,1]=1\nY[,1]=1\nB[,1]=1\nD[,1]=1\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor (i in 1:S){  \n\n  for (t in 2:T){\n \n    for (iterations in 1:1000){ # run the model 1000-times in each period \n       \n      # (1) Population dynamics    \n      N[i,t] = N[i,t-1] + B[i,t-1] - D[i,t-1]\n      \n      # (2) Births\n      B[i,t] = (b0[i,t] + b1*Y[i,t])*N[i,t]\n      \n      # (3) Deaths\n      D[i,t] = (d0 - d1*Y[i,t])*N[i,t]  \n      \n      # (4) Real income\n      Y[i,t] = a0[i,t] - a1[i,t]*N[i,t]   \n      \n    }  # close iterations loop \n  }    # close time loop\n}      # close scenario loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Load relevant libraries\nimport numpy as np\n\n# Set number of periods\nT = 100\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 5\n\n# Create (S x T)-matrices that will contain the simulated data\nN = np.zeros((S, T))  # population\nY = np.zeros((S, T))  # real income\nB = np.zeros((S, T))  # births\nD = np.zeros((S, T))  # deaths\nN_eq = np.zeros((S))  # equilibrium population\nY_eq = np.zeros((S))  # equilibrium real income\nB_eq = np.zeros((S))  # equilibrium births\nD_eq = np.zeros((S))  # equilibrium deaths\n\n# Set baseline parameter values\nb0 = np.zeros((S, T)) + 0.5  # Exogenous birth rate\nb1 = 0.5  # Sensitivity of births with respect to real income\nd0 = 2.5  # Exogenous death rate\nd1 = 0.5  # Sensitivity of deaths with respect to real income\na0 = np.zeros((S, T)) + 2.5  # Exogenous component of real income\na1 = np.zeros((S, T)) + 0.05  # Sensitivity of the real income with respect to population\n\n# Set parameter values for different scenarios\nb0[1, s:T] = 0.4  # scenario 2: reduction in birth rate\na1[2, s:T] = 0.07  # scenario 3: increase in sensitivity of real income with respect to population\na0[3, s:T] = 2.6  # scenario 4: improvement in productivity\n\n# Initialise \nN[:,0] = 1\nY[:,0] = Y_eq[0]\nB[:,0] = B_eq[0]\nD[:,0] = D_eq[0]\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor i in range(S):  \n  for t in range(1, T):\n    for iterations in range(1000): # run the model 1000-times in each period (to make sure the order of equations doesn't matter)\n      # (1) Population dynamics    \n      N[i,t] = N[i,t-1] + B[i,t-1] - D[i,t-1]\n      # (2) Births\n      B[i,t] = (b0[i,t] + b1*Y[i,t])*N[i,t]\n      # (3) Deaths\n      D[i,t] = (d0 - d1*Y[i,t])*N[i,t]  \n      # (4) Real income\n      Y[i,t] = a0[i,t] - a1[i,t]*N[i,t]   \n\n\n\n\nPlots\nFigure 1 displays population and real income dynamics for the baseline scenario. Starting from a below-equilibrium level of population, the population initially grows rapidly (seemingly exponentially) but then approaches a steady state. During the adjustment phase, real income is driven down to its steady state level (which can be interpreted as the subsistence level). Figure 2 displays the corresponding dynamics of births and deaths.\n\n# Set maximum period for plots\nTmax=20\n\n## Baseline\n#Population and real income\nplot(N[1, 2:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Population and real income, baseline\",ylab = 'N', xlab = 'Time',cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(Y[1, 2:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(Y[1, 2:20]),cex=0.8)\naxis(side = 4, at = pretty(range(Y[1, 2:Tmax])))  \nmtext(\"Y\", side = 4, line = 2)\nlegend(15, 2.3, legend=c(\"N\", \"Y\"),\n        lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.5)\n\n\n\n\n\n\n\n# Births and deaths\nplot(B[1, 2:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\") \ntitle(main=\"Figure 2: Births and deaths, baseline\", xlab = 'Time',cex=0.8,line=2)\nlines(D[1, 2:Tmax],lty=2)\nlegend(\"bottomright\", legend=c(\"B\", \"D\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.5)\n\n\n\n\n\n\n\nFigure 3 displays population dynamics under the different scenarios described in Table 1. As expected, both preventative and positive checks are effective: a fall in the exogenous component of the birth rate and an increase in the sensitivity of real income slow down population dynamics and lower its steady state value. By contrast, a productivity boost allows for a higher equilibrium level of population.\n\n## Population dynamics under different scenarios\nplot(N[1, 2:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(N[4, 2:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 3: Population dynamics under different scenarios\",ylab = 'N', xlab = 'Time',cex=0.8, line=2)\nlines(N[2, 2:(Tmax+1)],lty=2, lwd=2)\nlines(N[3, 2:(Tmax+1)],lty=3, lwd=2)\nlines(N[4, 2:(Tmax+1)],lty=4, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: baseline\",\"2: fall in exog birth rate\", \"3: rise in sensitivity of income\",\n      \"4: productivity boost\"), lty=1:4, cex=0.8, bty = \"n\", y.intersp=0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Plots (here for population and real income only)\n\nimport matplotlib.pyplot as plt\n\n# Set maximum period for plots\nTmax = 20\n\n## Baseline\n# Population and real income\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(Y[0, 2:Tmax], linestyle='dashed', label='Y', linewidth=0.8, color=\"black\")\nax2.set_ylabel('Y', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#directed-graph",
    "href": "a_malthusian_model.html#directed-graph",
    "title": "13  A Malthusian Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 6 variables: N, B, D, Y, b0, a0,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\nM_mat=matrix(c(0,1,1,0,0,0,\n              1,0,0,1,1,0,\n              1,0,0,1,0,0,\n              1,0,0,0,0,1,\n              0,0,0,0,0,0,\n              0,0,0,0,0,0), 6, 6, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"N\", \"B\", \"D\", \"Y\", expression(b[0]), expression(a[0]))\n\n# Plot directed graph matrix\nplot(dg, main=\"Figure 4: Directed graph of Malthusian model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\nimport networkx as nx\n\n#Construct auxiliary Jacobian matrix for 6 variables: N, B, D, Y, b0, a0\nM_mat = np.array([[0,1,1,0,0,0],\n                  [1,0,0,1,1,0],\n                  [1,0,0,1,0,0],\n                  [1,0,0,0,0,1],\n                  [0,0,0,0,0,0],\n                  [0,0,0,0,0,0]])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"N\", 1: \"B\", 2: \"D\", 3: \"Y\", 4: \"$b_0$\", 5: \"$a_0$\"}\n\n# Plot the graph\npos = nx.spring_layout(G)\nnx.draw_networkx(G, pos, node_size=500, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=12, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure 4: Directed graph of Malthusian model\")\nplt.show()\n\n\n\n\nIn Figure 4, it can be seen that the exogenous birth rate (\\(b0\\)) and productivity (\\(a0\\)) are exogenous variables that impact births and income, respectively. Births, deaths, employment and income are endogenous and form a closed loop (or cycle) within the system. Births and deaths affect the population size (with simultaneous feedback from population to births and deaths), and the population affects income. Income, in turn, feeds back into population size.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#analytical-discussion",
    "href": "a_malthusian_model.html#analytical-discussion",
    "title": "13  A Malthusian Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo find the steady state solution for \\(N\\), substitute Equation 13.2 - Equation 13.4 into Equation 13.1 and collect terms::\n\\[\nN_t = N_{t-1}[1+b_0-d_0+a_0(b_1+d_1)] - N_{t-1}^2 [a_1(b_1+d_1)].\n\\tag{13.5}\\]\nSubtract \\(N_{t-1}\\) and divide through by \\(N_{t-1}\\): \\[\n\\frac{N_t - N_{t-1}}{N_{t-1}} = [b_0-d_0+a_0(b_1+d_1)] - N_{t-1} [a_1(b_1+d_1)].\n\\]\nSet \\(\\frac{N_t - N_{t-1}}{N_t{t-1}}=0\\) and solve for \\(N_{t}\\) to find the non-trivial steady state:2 \\[\nN^* = \\frac{b_0-d_0+a_0(b_1+d_1)}{a_1(b_1+d_1)}.\n\\]\nSubstitution of \\(N^*\\) into Equation 13.4 and simplifying yields: \\[\nY^* = \\frac{d_0-b_0}{b_1+d_1}.\n\\]\nFinally, to assess the dynamic stability of the model, differentiate Equation 13.5 with respect to \\(N_{t-1}\\): \\[\n\\frac{\\partial N_t}{\\partial N_{t-1}} = 1+b_0-d_0+a_0(b_1+d_1)-2N_{t-1}[a_1(b_1+d_1)].\n\\]\nDue to then non-linearity of the model, stability can only be assessed locally around the steady state. To do this, substitute the steady state solution and simplify: \\[\n\\frac{\\partial N_t}{\\partial N_{t-1}} = 1-b_0+d_0-a_0(b_1+d_1).\n\\] From this, we can conclude that the steady state is stable iff: \\[\n|1-b_0+d_0-a_0(b_1+d_1)| &lt; 1.\n\\]\nWe can verify these analytical solutions by comparing them with the results from the numerical solution:\n\n# Calculate analytical equilibrium solutions \nfor (i in 1:S){\nN_eq[i]=(b0[i,T]-d0+a0[i,T]*(b1+d1))/(a1[i,T]*(b1+d1))\nY_eq[i]=(d0-b0[i,T])/(b1+d1)\nB_eq[i]=(b0[i,T] + b1*Y_eq[i])*N_eq[i]\nD_eq[i]=(d0 - d1*Y_eq[i])*N_eq[i]\n}\n\n# Compare with numerical solutions (here for the example of Y, scenario1)\nY_eq[1]\n\n[1] 2\n\nY[1,T]\n\n[1] 2\n\n# Check stability condition for all scenarios\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(abs(1-b0[i,T]+d0-a0[i,T]*(b1+d1)) &lt; 1)\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\n# Calculate analytical equilibrium solutions \nfor i in range(S):\n  N_eq[i] = (b0[i, T-1] - d0 + a0[i, T-1] * (b1 + d1)) / (a1[i, T-1] * (b1 + d1))\n  Y_eq[i] = (d0 - b0[i, T-1]) / (b1 + d1)\n  B_eq[i] = (b0[i, T-1] + b1 * Y_eq[i]) * N_eq[i]\n  D_eq[i] = (d0 - d1 * Y_eq[i]) * N_eq[i]\n  \n# Compare with numerical solutions (here for the example of Y, scenario1)\nprint(Y_eq[0])\nprint(Y[0,T-1])\n\n# Check stability condition for all scenarios\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(abs(1 - b0[i, T-1] + d0 - a0[i, T-1] * (b1 + d1)) &lt; 1)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#references",
    "href": "a_malthusian_model.html#references",
    "title": "13  A Malthusian Model",
    "section": "References",
    "text": "References\n\n\n\n\nFoley, Duncan K. 2006. Adam’s Fallacy. A Guide to Economic Theology. Cambridge, MA / London: Harvard University Press.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_malthusian_model.html#footnotes",
    "href": "a_malthusian_model.html#footnotes",
    "title": "13  A Malthusian Model",
    "section": "",
    "text": "See chapter 2 of Foley (2006) for an excellent introduction.↩︎\nA trivial steady state is at \\(N^*=0\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A Malthusian Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html",
    "href": "a_ricardian_one_sector_model.html",
    "title": "14  A Ricardian One-Sector Model",
    "section": "",
    "text": "Overview\nThis model captures some key feature of David Ricardo’s theory of growth and distribution as developed in his 1817 book On the Principles of Political Economy and Taxation. The model revolves around the determination of real wages, rents, and profits, and how profitability in turn drives capital accumulation.1 It assumes a corn economy with a single good (corn) that serves both as an investment and consumption good.2 Corn production is subject to diminishing marginal returns. Real wages are driven down to a subsistence level and rent is a differential surplus landowners gain based on the fertility of their land relative to the marginal plot of land (the plot of land where fertility is lowest and no rent is earned). Profits are a residual. As employment increases and more land is utilised, marginal productivity falls and differential rents increase. As a result, profits are driven down and capital accumulation comes to a halt. A stationary state is reached. Landowners are the main beneficiaries of this process. The model is adapted from Pasinetti (1960).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#the-model",
    "href": "a_ricardian_one_sector_model.html#the-model",
    "title": "14  A Ricardian One-Sector Model",
    "section": "The Model",
    "text": "The Model\nThe following equations describe the model:\n\\[\nY_t=AN_t^a\n\\tag{14.1}\\]\n\\[\nW_t=K_t\n\\tag{14.2}\\]\n\\[\nw_t =W_t/N_t\n\\tag{14.3}\\]\n\\[\nMPL_t =\\frac{\\partial Y_t}{\\partial N_t} =aAN_t^{a-1}\n\\tag{14.4}\\]\n\\[\nR_t = Y_t - N_tMPL_t\n\\tag{14.5}\\]\n\\[\nP_t = Y_t - R_t - N_tw_t\n\\tag{14.6}\\]\n\\[\nK_t = K_{t-1} + \\beta P_{t-1}\n\\tag{14.7}\\]\n\\[\nN_t = N_{t-1} + \\gamma (w_{t-1} - w^S)\n\\tag{14.8}\\]\nwhere \\(Y_t\\), \\(A\\), \\(N_t\\), \\(W_t\\), \\(K_t\\),\\(w_t\\), \\(Y_t\\), \\(MPL_t\\), \\(R_t\\), \\(P_t\\), and \\(w^S\\) are real output (measured in units of corn), productivity, employment, the real wage bill (or wage fund), the capital stock, the real wage rate, the marginal product of labour, rents, profits, and the subsistence wage, respectively.\nEquation 14.1 is the production function with \\(\\alpha \\in (0,1)\\), i.e. exhibiting diminishing marginal returns to labour.3 By Equation 14.2, the wage fund is defined as the capital stock of this model (reflecting the fact that the production of corn only involves labour). Equation 14.3 defines the real wage rate. Equation 14.3 specifies the marginal product of labour. Equation 14.5 captures the determination of (differential) rents as a negative function of the marginal product of labour.4 Thus, the lower the productivity on the marginal land, the higher the rents. In Equation 14.6, profits are determined residually. Capital accumulation in Equation 14.7 is driven by the reinvestment of profits (with \\(\\beta\\) determining the proportion of profits that are reinvested). Finally, Equation 14.8 specifies population dynamics, whereby the population increases whenever the actual real wage is above the subsistence wage, echoing the Malthusian population mechanism.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#simulation",
    "href": "a_ricardian_one_sector_model.html#simulation",
    "title": "14  A Ricardian One-Sector Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation and initial values used in the simulation. In line with the Classical tradition, it will be assumed that all profits are reinvested, i.e. \\(\\beta=1\\). Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenarios 2 and 3 model two different forms of technological change: an increase in the productivity parameter \\(A\\) and an increase in the elasticity of output with respect to labour (\\(a\\)). Scenario 4 considers a higher subsistence wage (\\(w^S\\)). In all scenarios the population/employment is initialised below its equilibrium value.\nTable 1: Parameterisation\n\n\nScenario\n\\(A\\)\n\\(a\\)\n\\(w^S\\)\n\n\n\n1: baseline\n2\n0.7\n0.5\n\n\n2: productivity boost I (\\(A\\))\n3\n0.7\n0.5\n\n\n3: productivity boost II (\\(a\\))\n2\n0.75\n0.5\n\n\n4: higher subsistence wage (\\(w^S\\))\n2\n0.7\n0.7\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=500\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=20\n\n# Create (S x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=S,ncol=Q) # Income/output\nR=matrix(data=1,nrow=S,ncol=Q) # Rent\nP=matrix(data=1,nrow=S,ncol=Q) # Profits\nN=matrix(data=1,nrow=S,ncol=Q) # employment\nw=matrix(data=1,nrow=S,ncol=Q) # real wage\nK=matrix(data=1,nrow=S,ncol=Q) # capital stock\nMPL=matrix(data=1,nrow=S,ncol=Q) # marginal product of labour\nW=matrix(data=1,nrow=S,ncol=Q) # wage bill\nN_eq=vector(length=S)          # equilibrium population\nK_eq=vector(length=S)          # equilibrium capital\n\n# Set baseline parameter values\nA=matrix(data=2,nrow=S,ncol=Q) # productivity\na=matrix(data=0.7,nrow=S,ncol=Q) # labour elasticity of output\nbeta=1 # Sensitivity of investment with respect to profits\ngamma=5 # adjustment speed of population\nwS=matrix(data=0.5,nrow=S,ncol=Q) # subsistence wage rate\n\n# Set parameter values for different scenarios\nA[2,s:Q]=3 # scenario 2: productivity boost I\na[3,s:Q]=0.75 # scenario 3: productivity boost II\nwS[4,s:Q]=0.6 # scenario 4: increase in subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN[,1]=1\nK[,1]=1   \nY[,1]=A[,1]*N[,1]^(a[,1])\nMPL[,1]=a[,1]*A[,1]*(N[,1]^(a[,1]-1))\nw[,1]=wS[,1]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # run the model 1000-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = A[i,t]*N[i,t]^(a[i,t])\n    \n    #(2) Wage bill\n    W[i,t] = K[i,t] \n    \n    #(3) Real wage rate\n    w[i,t] = W[i,t]/N[i,t] \n     \n    #(4) Marginal product of labour\n    MPL[i,t] = a[i,t]*A[i,t]*(N[i,t]^(a[i,t]-1))\n\n    #(5) Rents\n    R[i,t] = Y[i,t] - N[i,t]*MPL[i,t]\n    \n    #(6) Profits\n    P[i,t] = Y[i,t]- R[i,t] - N[i,t]*w[i,t]\n    \n    # (7) Capital accumulation\n    K[i,t] = K[i,t-1] + beta*P[i,t-1]\n    \n    #(8) Employment/population dynamics  \n    N[i,t] = N[i,t-1] + gamma*(w[i,t-1] - wS[i,t-1])\n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 500\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 20\n\n# Create (S x Q)-matrices that will contain the simulated data\nY = np.ones((S, Q))  # Income/output\nR = np.ones((S, Q))  # Rent\nP = np.ones((S, Q))  # Profits\nN = np.ones((S, Q))  # employment\nw = np.ones((S, Q))  # real wage\nK = np.ones((S, Q))  # capital stock\nMPL = np.ones((S, Q))  # marginal product of labour\nW = np.ones((S, Q))  # wage bill\n\n# Set baseline parameter values\nA = np.ones((S, Q)) * 2  # productivity\na = np.ones((S, Q)) * 0.7  # labour elasticity of output\nbeta = 1  # Sensitivity of investment with respect to profits\ngamma = 5  # adjustment speed of population\nwS = np.ones((S, Q)) * 0.5  # subsistence wage rate\n\n# Set parameter values for different scenarios\nA[1, s:Q] = 3  # scenario 2: productivity boost I\na[2, s:Q] = 0.75  # scenario 3: productivity boost II\nwS[3, s:Q] = 0.6  # scenario 4: increase in subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN[:, 0] = 1\nK[:, 0] = 1\nY[:, 0] = A[:, 0] * N[:, 0]**(a[:, 0])\nMPL[:, 0] = a[:, 0] * A[:, 0] * (N[:, 0]**(a[:, 0] - 1))\nw[:, 0] = wS[:, 0]\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for iterations in range(1000):  # run the model 1000 times in each period\n            # Model equations\n            # (1) Output\n            Y[i, t] = A[i, t] * N[i, t]**(a[i, t])\n            # (2) Wage bill\n            W[i, t] = K[i, t]\n            # (3) Real wage rate\n            w[i, t] = W[i, t] / N[i, t]\n            # (4) Marginal product of labour\n            MPL[i, t] = a[i, t] * A[i, t] * (N[i, t]**(a[i, t] - 1))\n            # (5) Rents\n            R[i, t] = Y[i, t] - N[i, t] * MPL[i, t]\n            # (6) Profits\n            P[i, t] = Y[i, t] - R[i, t] - N[i, t] * w[i, t]\n            # (7) Capital accumulation\n            K[i, t] = K[i, t - 1] + beta * P[i, t - 1]\n            # (8) Employment/population dynamics\n            N[i, t] = N[i, t - 1] + gamma * (w[i, t - 1] - wS[i, t - 1])\n\n\n\n\nPlots\nFigure 1 displays employment, capital accumulation, and income for the baseline scenario. Starting from a below-equilibrium level of population, the economy grows in terms of output, capital, and employment but then approaches what Ricardo famously called a ‘stationary state’. Figure 2 shows that during the adjustment phase, the MPL declines reflecting diminishing marginal returns in the production of corn. This captures the idea that a growing economy will have to utilise less fertile lands. The real wage is initially below the MPL, allowing for profits. Over time, the MPL and actual real wage converge to the exogenously given subsistence wage. Figure 3 shows that profits initially increase but are then squeezed to zero as differential rents increase.\n\n# Set start and end periods for plots\nTmax=280\nTmin =10\n\n## Baseline\n#Employment, capital accumulation, and income\nplot(N[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Employment, capital accumulation, and income\",ylab = 'N', xlab = 'Time', cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(Y[1, 2:(Tmax+1)]),cex.axis=1,cex.lab=0.75)\nlines(Y[1, Tmin:(Tmax+1)],lty=3, lwd=2)\naxis(side = 4, at = pretty(range(Y[1, 2:(Tmax+1)])))  \nmtext(\"K, Y\", side = 4, line = 2)\nlegend(\"bottomright\", legend=c(\"N\", \"K\", \"Y\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Real wage, subsistence wage, and MPL\nplot(w[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(wS[1, Tmin:Tmax],w[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 2: Real wage, marginal product of labour, and subsistence wage\", xlab = 'Time',cex=0.8,line=2)\nlines(MPL[1, Tmin:Tmax],lty=2)\nlines(wS[1, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"w\", \"MPL\", \"wS\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Profits and Rents\nplot(P[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(P[1, Tmin:Tmax])) \ntitle(main=\"Figure 3: Profits and rents\", xlab = 'Time',cex=0.8,line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(R[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=2, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"P\", \n     ylim=range(R[1, 3:Tmax]), axes=FALSE) \naxis(side = 4, at = pretty(range(R[1, Tmin:(Tmax+1)])))  \nmtext(\"R\", side = 4, line = 2)\nlegend(\"right\", legend=c(\"P\", \"R\"), lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nFigure 4 displays capital accumulation under the different scenarios described in Table 1. As expected, both forms of technical change boost both the speed of capital accumulation and the equilibrium level of capital. An increase in the subsistence wage reduces the pace of capital accumulation and leads to a lower equilibrium level of capital.\n\n## Different scenarios\n# Capital accumulation\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(K[1, 2:Tmax], K[2, Tmin:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 4: Capital accumulation under different scenarios\",ylab = 'K', xlab = 'Time',cex=0.8, line=2)\nlines(K[2, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(K[3, Tmin:(Tmax+1)],lty=3, lwd=2)\nlines(K[4, Tmin:(Tmax+1)],lty=4, lwd=2)\nlegend(\"topleft\", legend=c(\"1: baseline\",\"2: product. boost I\", \"3: product. boost II\", \"4: higher subs. wage\"), lty=1:4, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Plots (here for employment, capital accumulation, and income only)\n\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 280\nTmin = 10\n\n# Baseline\n# Employment, capital accumulation, and income\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\n\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(K[0, 2:Tmax], linestyle='dashed', label='K', linewidth=0.8, color=\"black\")\nax2.plot(Y[0, 2:Tmax], linestyle='dotted', label='Y', linewidth=0.8, color=\"black\")\nax2.set_ylabel('Y, K', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.title(\"Figure 1: Employment, capital accumulation, and income\")\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#directed-graph",
    "href": "a_ricardian_one_sector_model.html#directed-graph",
    "title": "14  A Ricardian One-Sector Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 10 variables: Y W w MPL R P K N A wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\nM_mat=matrix(c(0,0,0,0,0,0,0,1,1,0,\n               0,0,0,0,0,0,1,0,0,0,\n               0,1,0,0,1,0,0,1,0,0,\n               0,0,0,0,0,0,0,1,1,0,\n               1,0,0,1,0,0,0,1,0,0,\n               1,0,1,0,1,0,0,1,0,0,\n               0,0,0,0,0,1,0,0,0,0,\n               0,0,1,0,0,0,0,0,0,1,\n               0,0,0,0,0,0,0,0,0,0,\n               0,0,0,0,0,0,0,0,0,0), 10,10, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create and plot directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"W\", \"w\", \"MPL\", \"R\", \"P\", \"K\", \"N\", \"A\", expression(w^S))\n\n# Plot directed graph\nplot(dg, main=\"Figure 5: Directed graph of Ricardian One-Sector Model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create directed graph\n\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 10 variables: Y W w MPL R P K N A wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\nM_mat = np.array([\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 1, 0, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n    [1, 0, 1, 0, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n])\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: 'Y', 1: 'W', 2: 'w', 3: 'MPL', 4: 'R', 5: 'P', 6: 'K', 7: 'N', 8: 'A', 9: 'wS'}\n\n# Plot the graph\npos = nx.spring_layout(G)\nnx.draw_networkx(G, pos, node_size=500, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=12, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure 5: Directed graph of Ricardian One-Sector Model\")\nplt.show()\n\n\n\n\nIn Figure 5, it can be seen that productivity (\\(A\\)) and the subsistence wage (\\(w^S\\)) are the key exogenous variables that impact income and the marginal product of labour, and population dynamics, respectively. Most other variables are endogenous and form a closed loop (or cycle) within the system. Profits are a residual. The directed graph illustrates the supply-driven nature of the model, where productivity determines employment and distribution, which in turn feed back into income and capital accumulation. At the same time, income distribution has an exogenous element in the form of the subsistence wage, which feeds into the system.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#sec-ricardo_1_analytical",
    "href": "a_ricardian_one_sector_model.html#sec-ricardo_1_analytical",
    "title": "14  A Ricardian One-Sector Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo analyse the dynamics, combine Equation 14.1 to Equation 14.6 and substitute into Equation 14.7. Further use Equation 14.2 and Equation 14.3 in Equation 14.8. This yields the two-dimensional dynamic system in \\(K_t\\) and \\(N_t\\):\n\\[\nK_t = (1-\\beta)K_{t-1}+\\beta(aA N_{t-1}^a )\n\\] \\[\nN_t = N_{t-1} +\\gamma\\left(\\frac{K_{t-1}}{N_{t-1}} -w^S\\right)\n\\] The Jacobian matrix is given by: \\[\nJ(K, N)=\\begin{bmatrix} 1-\\beta& \\beta a^2AN^{\\alpha-1} \\\\\\frac{\\gamma}{N} & 1-\\frac{\\gamma K}{N^2} \\end{bmatrix}.\n\\]\nFrom equations Equation 14.7 and Equation 14.8, it can readily be seen that an equilibrium is reached when \\[\nP^*=0\n\\] and \\[\nw^*=w^S.\n\\] Using \\(P^*=0\\) with Equation 14.5 and Equation 14.6, yields \\(w^*=w^S=MPL\\). Thus, in equilibrium, profits are zero, and the real wage is equal to the MPL and the subsistence wage. Setting \\(K_t=K_{t-1}\\) and \\(N_t=N_{t-1}\\), we can further derive:\n\\[\nK^*=aA\\left(\\frac{w^S}{aA}\\right)^{-\\frac{a}{1-a}}\n\\] and\n\\[\nN^*=\\left(\\frac{w^S}{aA}\\right)^{-\\frac{1}{1-a}}\n\\] With this, we can evaluate the Jacobian at the steady state: \\[\nJ(K^*, N^*)=\\begin{bmatrix} 1-\\beta & \\beta a w^S \\\\ \\gamma \\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}} & 1-\\gamma aA \\left(\\frac{w^S}{aA}\\right)^{\\frac{2-a}{1-a}}\n\\end{bmatrix}.\n\\] For the system to be stable, both eigenvalues of the Jacobian need to be inside the unit circle. This requires the following three conditions to hold:\n\\[\n1+tr(J)+det(J)&gt;0\n\\] \\[\n1-tr(J)+det(J)&gt;0\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nLet us consider the Classical case where \\(\\beta=1\\), i.e. all profits are reinvested. Then we have\n\\[\ndet(J)=-aw^S \\gamma \\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}}&lt;0,\n\\] so that the third condition is always satisfied and it is the first one that is binding. The first condition then becomes\n\\[\n2-\\gamma a \\left[ A \\left(\\frac{w^S}{aA}\\right)^{\\frac{2-a}{1-a}} + w^S\\left(\\frac{w^S}{aA}\\right)^{\\frac{1}{1-a}} \\right]&gt;0\n\\]\nWe can check the analytical solutions and stability conditions numerically:\n\n# Calculate equilibrium solutions\nfor (i in 1:S){\n  N_eq[i]=(wS[i,Q]/(a[i,Q]*A[i,Q]))^(-1/(1-a[i,Q]))\n  K_eq[i]=a[i,Q]*A[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^(-a[i,Q]/(1-a[i,Q]))\n}\n\n# Compare with numerical solutions (here only for baseline)\nN_eq[1]\n\n[1] 30.94046\n\nN[1,Q]\n\n[1] 30.94031\n\nK_eq[1]\n\n[1] 15.47023\n\nK[1,Q]\n\n[1] 15.47018\n\n### Examine model properties (here for the baseline scenario only)\n# Construct Jacobian matrix at the equilibrium \nJ=matrix(c(1-beta, beta*a[1,Q]*wS[1,Q],\n           beta*(wS[1,Q]/(a[1,Q]*A[1,Q]))^(1/(1-a[1,Q])),\n           1-gamma*a[1,Q]*A[1,Q]*(wS[1,Q]/(a[1,Q]*A[1,Q]))^((2-a[1,Q])/(1-a[1,Q]))), 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values = ev$values)\n\n[1]  0.93134557 -0.01214592\n\n# Obtain determinant and trace\ndet=det(J)      # determinant\ntr=sum(diag(J)) # trace\n\n#Check general stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n# Check specific stability condition for the case beta=1\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(2-gamma*a[i,Q]*(A[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^((2-a[i,Q])/(1-a[i,Q])) \n                      + wS[i,Q]*(wS[i,Q]/(a[i,Q]*A[i,Q]))^(1/(1-a[i,Q])))&gt;0)\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Initialize arrays for equilibrium solutions\nN_eq = np.zeros(S)\nK_eq = np.zeros(S)\n\n# Calculate equilibrium solutions\nfor i in range(S):\n    N_eq[i] = (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (-1 / (1 - a[i, Q-1]))\n    K_eq[i] = a[i, Q-1] * A[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (-a[i, Q-1] / (1 - a[i, Q-1]))\n\n# Compare with numerical solutions (here only for baseline)\nN_eq[0]\nN[0,Q-1]\n\n# Construct Jacobian matrix at the equilibrium \nJ = np.array([\n    [1 - beta, beta * a[0, Q-1] * wS[0, Q-1]],\n    [beta * (wS[0, Q-1] / (a[0, Q-1] * A[0, Q-1])) ** (1 / (1 - a[0, Q-1])),\n     1 - gamma * a[0, Q-1] * A[0, Q-1] * (wS[0, Q-1] / (a[0, Q-1] * A[0, Q-1])) ** ((2 - a[0, Q-1]) / (1 - a[0, Q-1]))]\n])\n\n# Obtain eigenvalues\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\n\n# Check general stability conditions\nprint(1+tr+det&gt;0)\nprint(1-tr+det&gt;0)\nprint(1-det&gt;0)\n\n# Check specific stability condition for the case beta=1\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(2 - gamma * a[i, Q-1] * (\n        A[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** ((2 - a[i, Q-1]) / (1 - a[i, Q-1])) +\n        wS[i, Q-1] * (wS[i, Q-1] / (a[i, Q-1] * A[i, Q-1])) ** (1 / (1 - a[i, Q-1]))\n    ) &gt; 0)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#references",
    "href": "a_ricardian_one_sector_model.html#references",
    "title": "14  A Ricardian One-Sector Model",
    "section": "References",
    "text": "References\n\n\n\n\nFoley, Duncan K. 2006. Adam’s Fallacy. A Guide to Economic Theology. Cambridge, MA / London: Harvard University Press.\n\n\nPasinetti, Luigi L. 1960. “A Mathematical Formulation of the Ricardian System.” The Review of Economic Studies 27 (2): 78–98. https://doi.org/10.2307/2296129.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_one_sector_model.html#footnotes",
    "href": "a_ricardian_one_sector_model.html#footnotes",
    "title": "14  A Ricardian One-Sector Model",
    "section": "",
    "text": "See chapter 2 of Foley (2006) for an excellent introduction.↩︎\nSee Chapter 15 for a two-sector extension of the model.↩︎\nPasinetti (1960) specifies a generic function \\(f(N_t)\\) with \\(f(0) \\geq\\) 0, \\(f'(0) &gt; w^*\\), and \\(f''(N_t) &lt; 0\\). Equation 14.1 satisfies these conditions.↩︎\nEquation 14.5 is based on the definition of total rent as the sum of the net gains of the non-marginal landowners. See Pasinetti (1960) for a formal derivation.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Ricardian One-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html",
    "href": "a_ricardian_two_sector_model.html",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "",
    "text": "Overview\nThis model captures some key feature of David Ricardo’s theory of growth and distribution as developed in his 1817 book On the Principles of Political Economy and Taxation. The model revolves around the determination of real wages, rents, and profits, and how profitability in turn drives capital accumulation.1 It assumes an economy with two sectors: an agricultural sector producing corn subject to diminishing marginal returns and a luxury good sector with constant marginal returns.2 Prices are determined by the quantity of labour required for production. Rent on the land used for agricultural production is a differential surplus landowners gain based on the fertility of their land relative to the marginal plot of land (the plot of land where fertility is lowest and no rent is earned). Real wages are determined by the subsistence level in the long run. Profits in agriculture are a residual and set the economy-wide profit rate. As employment increases and more land is utilised, marginal productivity in agriculture falls and differential rents increase. As a result, profits are driven down to zero and capital accumulation comes to a halt. A ‘stationary state’ is reached. Landowners are the main beneficiaries of this process. The model is adapted from Pasinetti (1960).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#the-model",
    "href": "a_ricardian_two_sector_model.html#the-model",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "The Model",
    "text": "The Model\nThe following equations describe the model: \\[\nY_t=AN_{1t}^{a_1}\n\\tag{15.1}\\]\n\\[\nMPL_t =\\frac{\\partial Y_{1t}}{\\partial N_{1t}} =a_1AN_{1t}^{a_1-1}\n\\tag{15.2}\\]\n\\[\nN_{1t}=N_t - N_{2t}\n\\tag{15.3}\\]\n\\[\nW_t=K_t\n\\tag{15.4}\\]\n\\[\nw_t =\\frac{W_t}{N_t}\n\\tag{15.5}\\]\n\\[\nR_t =  Y_{1t} - N_{1t}MPL_{t}\n\\tag{15.6}\\]\n\\[\nP_{1t} = Y_{1t} - R_t - N_{1t}w_t\n\\tag{15.7}\\]\n\\[\np_{1t}=\\frac{1}{MPL_t}\n\\tag{15.8}\\]\n\\[\nY_{2t}=\\left(\\frac{p_{1t}}{p_{2}}\\right)R_t\n\\tag{15.9}\\]\n\\[\nN_{2t} = \\frac{Y_{2t}}{a_2}\n\\tag{15.10}\\]\n\\[\np_{2}=\\frac{1}{a_2}\n\\tag{15.11}\\]\n\\[\nP_{2t}=Y_{2t}-\\left(\\frac{p_{1t}}{p_{2}}\\right)N_{2t}w_t\n\\tag{15.12}\\]\n\\[\nP_{t}=p_{1t}Y_{1t}+p_{2}Y_{2t}-p_{1t}R_t -p_{1t}W_t\n\\tag{15.13}\\]\n\\[\nK_t = K_{t-1} + g\\left(\\frac{P_{t-1}}{p_{1t-1}}\\right)\n\\tag{15.14}\\]\n\\[\nN_t = N_{t-1} + \\gamma (w_{t-1} - w^S)\n\\tag{15.15}\\]\nwhere \\(Y_t\\), \\(A\\), \\(N_t\\), \\(W_t\\), \\(K_t\\),\\(w_t\\), \\(Y_t\\), \\(MPL_t\\), \\(R_t\\), \\(P_t\\), \\(p\\), and \\(w^S\\) are real output, productivity, employment, the real wage bill (or wage fund), the capital stock (in terms of corn), the real wage rate (in terms of corn), the marginal product of labour (in the corn sector), rents, profits, prices, and the subsistence wage, respectively. The subscripts 1 and 2 denote the corn, i.e. agricultural, sector and the luxury goods sectors, respectively.\nEquation 15.1 is the production function with \\(\\alpha \\in (0,1)\\), i.e. exhibiting diminishing marginal returns to labour.3 By Equation 15.4, the wage fund is defined as the capital stock of this model (reflecting the fact that the production of corn only involves labour). Equation 15.5 defines the real wage rate. Equation 15.5 specifies the marginal product of labour. By Equation 15.3, employment in agriculture is residually determined after employment in the luxury goods sector has been determined (more on this below) Equation 15.6 captures the determination of (differential) rents as a negative function of the marginal product of labour.4 Thus, the lower the productivity on the marginal land, the higher the rents. By Equation 15.7, profits in agriculture are determined residually. Equation Equation 15.8 specifies price determination and captures Ricardo’s labour theory of value according to which the value of a good (net of rent) is determined by the quantity of labour required to produce it. 5\nEquation 15.9 specifies that the production of the luxury good is demand determined. Only landlords consume luxuries and they spend all their income (rent) on luxuries.6 With production in sector 2 demand determined, employment in sector 2 as given by Equation 15.10 must accommodate based on the production function \\(Y_{2t}=a_2N_{2t}\\). With employment in sector 2 pinned down in this way and total employment given by the wage fund (Equation 15.4), employment in sector 1 must be the residual (as specified in equation Equation 15.3). From the labour theory of value, \\(p_2Y_2=N_2\\) must hold. Together with the production function \\(Y_{2t}=a_2N_{2t}\\) this yields Equation 15.11 for the price of the luxury good. Note that due to the constant marginal returns in this sector, its price is constant too.7 By Equation 15.12, profits in the luxuries sector are determined residually (note that no rent is paid by this sector).\nEquation 15.13 specifies total profits (in nominal terms).8 Capital accumulation in equation Equation 15.14 is driven by the reinvestment of profits (with \\(\\beta\\) determining the proportion of profits that are reinvested). Finally, Equation 15.15 specifies population dynamics, whereby the population increases whenever the actual real wage is above the subsistence wage, echoing the Malthusian population mechanism.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#simulation",
    "href": "a_ricardian_two_sector_model.html#simulation",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation and initial values used in the simulation. In line with the Classical tradition, it will be assumed that all profits are reinvested, i.e. \\(\\beta=1\\). Besides a baseline (labelled as scenario 1), three further scenarios will be considered. Scenarios 2-4 model three different forms of technological change: an increase in the productivity parameter \\(A\\) (scenario 2), an increase in the elasticity \\(a_1\\) of agricultural output with respect to labour (scenario 3), and an increase in labour productivity \\(a_2\\) in the luxury good sector (scenario 4). Scenario 5 considers a higher subsistence wage (\\(w^S\\)). In all scenarios the population/employment is initialised below its equilibrium value.\nTable 1: Parameterisation\n\n\nScenario\n\\(A\\)\n\\(a_1\\)\n\\(a_2\\)\n\\(w^S\\)\n\n\n\n1: baseline\n2\n0.7\n0.5\n0.5\n\n\n2: productivity boost I (\\(A\\))\n3\n0.7\n0.5\n0.5\n\n\n3: productivity boost II (\\(a_1\\))\n2\n0.75\n0.5\n0.5\n\n\n4: productivity boost III (\\(a_2\\))\n2\n0.7\n0.55\n0.5\n\n\n5: higher subsistence wage (\\(w^S\\))\n2\n0.7\n0.5\n0.6\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=600\n\n# Set number of scenarios (including baseline)\nS=5\n\n# Set period in which shock/shift will occur\ns=15\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1=matrix(data=1,nrow=S,ncol=Q) # Output in sector 1\nY2=matrix(data=1,nrow=S,ncol=Q) # Output in sector 2\nR=matrix(data=1,nrow=S,ncol=Q) # Rent\nP=matrix(data=1,nrow=S,ncol=Q) # Qotal profits\nP1=matrix(data=1,nrow=S,ncol=Q) # Profits in sector 1\nP2=matrix(data=1,nrow=S,ncol=Q) # Profits in sector 2\nN=matrix(data=1,nrow=S,ncol=Q) # total employment\nN1=matrix(data=1,nrow=S,ncol=Q) # employment in sector 1\nN2=matrix(data=1,nrow=S,ncol=Q) # employment in sector 2\nw=matrix(data=1,nrow=S,ncol=Q) # real wage\nwn=matrix(data=1,nrow=S,ncol=Q) # nominal wage\nK=matrix(data=1,nrow=S,ncol=Q) # capital stock\nMPL=matrix(data=1,nrow=S,ncol=Q) # marginal product of labour (in sector 1)\nr=matrix(data=1,nrow=S,ncol=Q) # profit rate\np1=matrix(data=1,nrow=S,ncol=Q) # price of good from sector 1\np2=matrix(data=1,nrow=S,ncol=Q) # price of good from sector 2\nN_eq=vector(length=S)          # equilibrium population\nK_eq=vector(length=S)          # equilibrium capital\n\ntest=matrix(data=1,nrow=S,ncol=Q) # price of good from sector 2\n\n\n# Set baseline parameter values\nA=matrix(data=2,nrow=S,ncol=Q) # productivity\na1=matrix(data=0.7,nrow=S,ncol=Q) # labour elasticity of output, sector 1\na2=matrix(data=0.5,nrow=S,ncol=Q) # labour coefficient, sector 2\ngamma=5 # adjustment speed of population \nbeta=1 # Sensitivity of investment with respect to profits\nwS=matrix(data=0.5,nrow=S,ncol=Q) # natural wage rate\n\n# Set parameter values for different scenarios\nA[2,s:Q]=3     # scenario 2: productivity boost I\na1[3,s:Q]=0.75 # scenario 3: productivity boost II\na2[4,s:Q]=0.55 # scenario 4: productivity boost III\nwS[5,s:Q]=0.6  # scenario 5: higher subsistence wage\n\n# Initialise variables such that employment and the capital stock are below the equilibrium\nN1[,1]=1\nN2[,1]=1\nN[,1]=N1[,1]+N2[,1]\nK[,1]=1\nw[,1]=wS[,1]\nY1[,1]=A[,1]*N1[,1]^(a1[,1])\nMPL[,1]=a1[,1]*A[,1]*(N1[,1]^(a1[,1]-1))\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n\n  for (t in 2:Q){\n    \n    for (iterations in 1:1000){ # run the model 1000-times in each period\n      \n    #Model equations\n      \n      #(2) Wage bill (omitted for simplicity)\n      #W[i,t]=K[i,t] \n\n      #(3) Output sector 1\n      Y1[i,t] = A[i,t]*(N1[i,t]^a1[i,t])\n      \n      #(4) Employment sector 1\n      N1[i,t] = N[i,t] - N2[i,t]\n\n      #(5) Marginal product of labour (sector 1)\n      MPL[i,t]=a1[i,t]*A[i,t]*(N1[i,t]^(a1[i,t]-1))\n\n      #(6) Rent (simplified equation)\n      R[i,t]= Y1[i,t]*(1-a1[i,t]) \n      \n      #(7) Profits sector 1\n      P1[i,t] = Y1[i,t] - R[i,t] - N1[i,t]*w[i,t]\n\n      #(8) Prices sector 1\n      p1[i,t] = 1/(MPL[i,t])        \n\n      #(9) Output sector 2\n      Y2[i,t]=(p1[i,t]/p2[i,t])*R[i,t]\n      \n      #(3 Real wage rate\n      w[i,t] = K[i,t]/N[i,t] \n      \n      #(10) Employment sector 2\n      N2[i,t]= Y2[i,t]/a2[i,t]\n\n      #(11) Prices\n      p2[i,t] = 1/a2[i,t]\n\n      #(12) Profits sector 2\n      P2[i,t] = Y2[i,t] - (p1[i,t]/p2[i,t])*N2[i,t]*w[i,t]\n\n      #(13) Total profits\n      P[i,t]=p1[i,t]*Y1[i,t] + p2[i,t]*Y2[i,t] - p1[i,t]*R[i,t] - p1[i,t]*K[i,t]\n\n      #(14) Capital accumulation\n      K[i,t]= K[i,t-1] + beta*(P[i,t-1]/p1[i,t-1])\n      \n      #(8) Employment/population dynamics  \n      N[i,t] = N[i,t-1] + gamma*(w[i,t-1] - wS[i,t-1])\n      \n    } # close iterations loop\n  } # close time loop\n} # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 600\n\n# Set number of scenarios (including baseline)\nS = 5\n\n# Set period in which shock/shift will occur\ns = 15\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1 = np.ones((S, Q))\nY2 = np.ones((S, Q))\nR = np.ones((S, Q))\nP = np.ones((S, Q))\nP1 = np.ones((S, Q))\nP2 = np.ones((S, Q))\nN = np.ones((S, Q))\nN1 = np.ones((S, Q))\nN2 = np.ones((S, Q))\nw = np.ones((S, Q))\nwn = np.ones((S, Q))\nK = np.ones((S, Q))\nMPL = np.ones((S, Q))\nr = np.ones((S, Q))\np1 = np.ones((S, Q))\np2 = np.ones((S, Q))\nN_eq = np.zeros(S)\nK_eq = np.zeros(S)\ntest = np.ones((S, Q))\n\n# Set baseline parameter values\ngamma = 5\nbeta = 1\nA = np.full((S, Q), 2.0)\na1 = np.full((S, Q), 0.7)\na2 = np.full((S, Q), 0.5)\nwS = np.full((S, Q), 0.5)\n\n# Set parameter values for different scenarios\nA[1, s:] = 3     # scenario 2: productivity boost I\na1[2, s:] = 0.75 # scenario 3: productivity boost II\na2[3, s:] = 0.55 # scenario 4: productivity boost III\nwS[4, s:] = 0.6  # scenario 5: higher subsistence wage\n\n# Initialize variables\nN1[:, 0] = 1\nN2[:, 0] = 1\nN[:, 0] = N1[:, 0] + N2[:, 0]\nK[:, 0] = 1\nw[:, 0] = wS[:, 0]\nY1[:, 0] = A[:, 0] * N1[:, 0] ** (a1[:, 0])\nMPL[:, 0] = a1[:, 0] * A[:, 0] * (N1[:, 0] ** (a1[:, 0] - 1))\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    for t in range(1, Q):\n        for iterations in range(1000):\n            # Model equations\n            Y1[i, t] = A[i, t] * (N1[i, t] ** a1[i, t])\n            N1[i, t] = N[i, t] - N2[i, t]\n            MPL[i, t] = a1[i, t] * A[i, t] * (N1[i, t] ** (a1[i, t] - 1))\n            R[i, t] = Y1[i, t] * (1 - a1[i, t])\n            P1[i, t] = Y1[i, t] - R[i, t] - N1[i, t] * w[i, t]\n            p1[i, t] = 1 / MPL[i, t]\n            Y2[i, t] = (p1[i, t] / p2[i, t]) * R[i, t]\n            w[i, t] = K[i, t] / N[i, t]\n            N2[i, t] = Y2[i, t] / a2[i, t]\n            p2[i, t] = 1 / a2[i, t]\n            P2[i, t] = Y2[i, t] - (p1[i, t] / p2[i, t]) * N2[i, t] * w[i, t]\n            P[i, t] = p1[i, t] * Y1[i, t] + p2[i, t] * Y2[i, t] - p1[i, t] * R[i, t] - p1[i, t] * K[i, t]\n            K[i, t] = K[i, t - 1] + beta * (P[i, t - 1] / p1[i, t - 1])\n            N[i, t] = N[i, t - 1] + gamma * (w[i, t - 1] - wS[i, t - 1])\n\n\n\n\nPlots\nFigures 1-4 illustrate the model’s dynamics under the baseline parameterisation. Starting from below-equilibrium levels, the economy grows in terms of output, capital, and employment but then approaches what Ricardo famously called a ‘stationary state’. Figure 3 shows that during the adjustment phase, the MPL declines, reflecting diminishing marginal returns in agriculture. This captures the idea that a growing economy will have to utilise less fertile lands. The real wage is driven up until it is equal to the MPL. Figure 4 shows that total profits initially increase but are then squeezed to zero as differential rents increase.\n\n# Set start and end periods for plots\nTmax=100\nTmin=6\n\n## Baseline\n#Employment and capital accumulation\nplot(N[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylab = '', xlab = '')\ntitle(main=\"Figure 1: Employment and capital accumulation\",ylab = 'N', xlab = 'Time', cex=0.8, line=2)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(K[1, Tmin:(Tmax+1)]), cex=0.8)\naxis(side = 4, at = pretty(range(K[1, 2:(Tmax+1)])))  \nmtext(\"K\", side = 4, line = 2)\nlegend(\"bottomright\", legend=c(\"N\", \"K\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n#Output in the two sectors\nplot(Y1[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(Y1[1, Tmin:Tmax],Y2[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 2: Output in agriculture and luxuries\", xlab = 'Time',cex=0.8 ,line=2)\nlines(Y2[1, Tmin:(Tmax+1)],lty=2)\nlegend(\"bottomright\", legend=c(\"Y1\", \"Y2\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Real wage, MPL, and subsistence wage\nplot(w[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(wS[1, Tmin:Tmax],w[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 3: Real wage, marginal product of labour, and subsistence wage\", xlab = 'Time',cex=0.8,line=2)\nlines(MPL[1, Tmin:Tmax],lty=2)\nlines(wS[1, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"w\", \"MPL\", \"wS\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Total Profits and Rents\nplot(P[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, xlim=range(0:(Tmax)), xlab=\"\", ylab=\"\", ylim=range(P[1, Tmin:Tmax],R[1, Tmin:(Tmax)])) \ntitle(main=\"Figure 4: Total profits and rents\", xlab = 'Time',cex=0.8,line=2)\nlines(R[1, Tmin:(Tmax+1)],lty=2)\nlegend(\"right\", legend=c(\"P\", \"R\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nFigures 5 and 6 display capital accumulation under the five different scenarios described in Table 1. Technical change that increases productivity in agriculture (scenarios 2 and 3) raises the speed of capital accumulation and the equilibrium level of capital. By contrast, an increase in productivity in the luxury good sector (scenario 4) has no effect on capital accumulation. This is because productivity in sector 2 has no effects on functional income distribution.9 An increase in the initial stock of capital (scenario 5) raises the steady state value. Thus, economies with larger initial endowments will reach a higher level of income in the stationary state.\n\n## Scenarios\n# Capital accumulation under scenarios 1-3\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(K[1, Tmin:Tmax], K[2, Tmin:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 5: Capital accumulation under different scenarios (pt 1)\",ylab = 'K', xlab = 'Time',cex=0.8, line=2)\nlines(K[2, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(K[3, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"topleft\", legend=c(\"1: baseline\",\"2: productivity boost I\", \"3: productivity boost II\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Capital accumulation under scenarios 1, 4+5\nplot(K[1, Tmin:(Tmax+1)],type=\"l\", lwd=2, lty=1, xlim=range(0:(Tmax)), ylim=range(K[1, Tmin:Tmax], K[5, Tmin:Tmax]), ylab = '', xlab = '')\ntitle(main=\"Figure 6: Capital accumulation under different scenarios (pt 2)\",ylab = 'K', xlab = 'Time',cex=0.8, line=2)\nlines(K[4, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(K[5, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"topleft\", legend=c(\"1: baseline\",\"4: productivity boost III\", \"5: higher subsist. wage\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\nFigures 7 and 8 show the dynamics of relative prices (corn price relative to luxury good price) for the different scenarios. Over time, corn becomes more expensive in relative turns due to diminishing marginal returns. Improvements in labour productivity reduce the relative price of the respective sector in line with the labour theory of value.\n\n# Relative prices under scenarios 1 - 3\nrelpr=p1/p2\nplot(relpr[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     main=\"Figure 7: Relative prices under different scenarios (pt 1)\",ylab = 'p1/p2',xlab = 'Time',ylim = range(relpr[1, Tmin:(Tmax+1)], relpr[2, Tmin:(Tmax+1)]),cex=0.8)\nlines(relpr[2, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(relpr[3, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: baseline\", \"2: productivity boost I\", \"3: productivity boost II\"),lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n# Relative prices under scenarios 1, 4-5\nplot(relpr[1, Tmin:(Tmax+1)],type=\"l\", col=1, lwd=2, lty=1, font.main=1,cex.main=1, \n     main=\"Figure 8: Relative prices under different scenarios (pt 2)\",ylab = 'p1/p2',xlab = 'Time',ylim = range(relpr[1, Tmin:(Tmax+1)], relpr[4, Tmin:(Tmax+1)]),cex=0.8)\nlines(relpr[4, Tmin:(Tmax+1)],lty=2, lwd=2)\nlines(relpr[5, Tmin:(Tmax+1)],lty=3, lwd=2)\nlegend(\"bottomright\", legend=c(\"1: baseline\", \"4: productivity boost III\", \"5: higher subsist. wage\"), lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Plots (here for employment and capital accumulation only)\n\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 100\nTmin = 6\n\n# Baseline\n# Employment and capital accumulation\nfig, ax1 = plt.subplots()\nax1.plot(N[0, 2:(Tmax+1)], linestyle='solid', label='N', linewidth=0.8, color=\"black\")\n\nax1.set_xlabel('Time')\nax1.set_ylabel('N', rotation=0)\nax2 = ax1.twinx()\nax2.plot(K[0, 2:Tmax], linestyle='dashed', label='K', linewidth=0.8, color=\"black\")\nax2.set_ylabel('K', rotation=0)\nlines, labels = ax1.get_legend_handles_labels() #collect legend in one box\nlines2, labels2 = ax2.get_legend_handles_labels()\nax2.legend(lines + lines2, labels + labels2, loc=5)\nplt.title(\"Figure 1: Employment and capital accumulation\")\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#directed-graph",
    "href": "a_ricardian_two_sector_model.html#directed-graph",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).10\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 18 variables: \n#(1)Y1 (2)N1 (3)MPL (4)R (5)P1 (6)p1 (7)Y2 (8)w (9)N2 (10)p2 (11)P2\n#(12)P (13)K (14)N (15)A (16)a1 (17)a2 (18)wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\n#              1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\nM_mat=matrix(c(0,1,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 1, 1, 0, 0, #1\n               0,0,0,0,0,0,0,0,1,0, 0, 0, 0, 1, 0, 0, 0, 0, #2\n               0,1,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 1, 1, 0, 0, #3\n               1,1,1,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #4\n               1,1,0,1,0,0,0,1,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #5\n               0,0,1,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #6\n               0,0,0,1,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #7\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 1, 1, 0, 0, 0, 0, #8\n               0,0,0,0,0,0,1,0,0,0, 0, 0, 0, 0, 0, 0, 1, 0, #9\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 1, 0, #10\n               0,0,0,0,0,0,1,1,1,0, 0, 0, 0, 0, 0, 0, 0, 0, #11 \n               0,0,0,0,1,0,0,0,0,0, 1, 0, 0, 0, 0, 0, 0, 0, #12\n               0,0,0,0,0,0,0,0,0,0, 0, 1, 0, 0, 0, 0, 0, 0, #13\n               0,0,0,0,0,0,0,1,0,0, 0, 0, 0, 0, 0, 0, 0, 1, #14\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #15\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #16\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, #17\n               0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0  #18\n               ), 18,18, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create and plot directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(expression(Y[1]), expression(N[1]), \"MPL\", \"R\", expression(P[1]), \n             expression(p[1]), expression(Y[2]), \"w\", expression(N[2]), \n             expression(p[2]), expression(P[2]), \"P\", \"K\", \"N\", \"A\", \n             expression(a[1]), expression(a[2]), expression(w^S))\n\n# Plot directed graph (using a tree-like layout)\nplot(dg, layout = layout_as_tree(dg), main=\"Figure 9: Directed graph\", vertex.size=22, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=0.8, \n     vertex.frame.color=\"NA\", margin=0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create directed graph\n\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 18 variables: \n#(1)Y1 (2)N1 (3)MPL (4)R (5)P1 (6)p1 (7)Y2 (8)w (9)N2 (10)p2 (11)P2\n#(12)P (13)K (14)N (15)A (16)a1 (17)a2 (18)wS,\n# where non-zero elements in regular Jacobian are set to 1 and zero elements are unchanged\n\n#                    1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18\nM_mat = np.array([  [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], #1\n                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], #2\n                    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], #3\n                    [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #4\n                    [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #5\n                    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #6\n                    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #7\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], #8\n                    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], #9\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], #10\n                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], #11\n                    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], #12\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], #13\n                    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], #14\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #15\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #16\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #17\n                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])#18\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat = M_mat.transpose()\n\n# Create the graph from the adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {\n    0: r'$Y_1$', 1: r'$N_1$', 2: 'MPL', 3: 'R', 4: r'$P_1$', \n    5: r'$p_1$', 6: r'$Y_2$', 7: 'w', 8: r'$N_2$', 9: r'$p_2$', \n    10: r'$P_2$', 11: 'P', 12: 'K', 13: 'N', 14: 'A', \n    15: r'$a_1$', 16: r'$a_2$', 17: r'$w^S$'\n}\n\n# Plot the graph\npos = nx.spring_layout(G, k=0.9)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Figure: Directed graph of Ricardian Two-Sector Model\")\nplt.show()\n\n\n\n\nIn Figure 9, it can be seen that productivity in agriculture (\\(A\\) and \\(a_1\\)) are key exogenous variables that impact income in sector 1 and the marginal product of labour. The subsistence wage (\\(w^S\\)) is another exogenous variable that impacts the system through its effect on population dynamics. Productivity in the luxuries sector (\\(a_2\\)) feeds into the system via employment.ost other variables are endogenous and form a closed loop (or cycle) within the system. Profits are a residual. The directed graph illustrates the supply-driven nature of the agricultural sector, where (marginal) productivity determine employment and distribution. By contrast, the luxury goods sector is demand-determined with employment being the residual. Profits determine capital accumulation, which in turn provides funds that can be used to hire more agricultural workers. A higher subsistence wage reduces capital accumulation as it leaves fewer profits to be reinvested.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#analytical-discussion",
    "href": "a_ricardian_two_sector_model.html#analytical-discussion",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo analyse the dynamics, combine Equation 15.1 to Equation 15.13 and substitute into Equation 15.14. Further use Equation 15.4 and Equation 15.5 in Equation 15.15. This yields the two-dimensional dynamic system in \\(K_t\\) and \\(N_t\\):\n\\[\nK_t = (1-\\beta)K_{t-1}+\\beta(a_1^{a_1}A N_{t-1}^{a_1} )\n\\] \\[\nN_t = N\\_{t-1} +\\gamma\\left(\\frac{K_{t-1}}{N_{t-1}} -w^S\\right)\n\\] The Jacobian matrix is given by:\n\\[\nJ(K, N)=\\begin{bmatrix} 1-\\beta& \\beta a_1^{1+a_1}AN^{a_1-1} \\\\\\frac{\\gamma}{N} & 1-\\frac{\\gamma K}{N^2} \\end{bmatrix}.\n\\]\nFrom equations Equation 15.14 and Equation 15.15, it can readily be seen that an equilibrium is reached when \\[\nP^*=0\n\\] and \\[\nw^*=w^S.\n\\] Using \\(P^*=0\\) with Equation 15.6 and Equation 15.13, yields \\(w^*=w^S=MPL\\). Thus, in equilibrium, profits are zero, and the real wage is equal to the MPL and the subsistence wage. Setting \\(K_t=K_{t-1}\\) and \\(N_t=N_{t-1}\\), we can further derive:\n\\[\nK^*=a_1^{a_1}A\\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{-\\frac{a_1}{1-a_1}}\n\\] and\n\\[\nN^*=\\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{-\\frac{1}{1-a_1}}\n\\] With this, we can evaluate the Jacobian at the steady state: \\[\nJ(K^*, N^*)=\\begin{bmatrix} 1-\\beta & \\beta a_1 w^S \\\\ \\gamma \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{1}{1-a_1}} & 1-\\gamma a_1^{a_1}A \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{2-a_1}{1-a_1}}\n\\end{bmatrix}.\n\\] For the system to be stable, both eigenvalues of the Jacobian need to be inside the unit circle. This requires the following three conditions to hold:\n\\[\n1+tr(J)+det(J)&gt;0\n\\] \\[\n1-tr(J)+det(J)&gt;0\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nLet us consider the Classical case where \\(\\beta=1\\), i.e. all profits are reinvested. Then we have\n\\[\ndet(J)=-a_1w^S \\gamma \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{1}{1-a_1}}&lt;0,\n\\]\nso that the third condition is always satisfied and it is the first one that is binding. The first condition then becomes\n\\[\n2-\\gamma  \\left[a_1^{a_1} A \\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{2-a_1}{1-a_1}} + a_1 w^S\\left(\\frac{w^S}{a_1^{a_1}A}\\right)^{\\frac{1}{1-a_1}} \\right]&gt;0\n\\]\nWe can check the analytical solutions and stability conditions numerically:\n\n# Calculate equilibrium solutions\nfor (i in 1:S){\n  N_eq[i]=(wS[i,Q]/((a1[i,Q]^a1[i,Q])*A[i,Q]))^(-1/(1-a1[i,Q]))\n  K_eq[i]=(a1[i,Q]^a1[i,Q])*A[i,Q]*(wS[i,Q]/((a1[i,Q]^a1[i,Q])*A[i,Q]))^(-a1[i,Q]/(1-a1[i,Q]))\n}\n\n# Compare with numerical solutions (here for the example of Y, baseline)\nN_eq[1]\n\n[1] 44.20066\n\nN[1,Q]\n\n[1] 44.19942\n\nK_eq[1]\n\n[1] 22.10033\n\nK[1,Q]\n\n[1] 22.09989\n\n### Examine model properties (here for the baseline scenario only)\n# Construct Jacobian matrix at the equilibrium \nJ=matrix(c(1-beta, \n           beta*a1[1,Q]*wS[1,Q],\n           gamma*(wS[1,Q]/((a1[i,Q]^a1[i,Q])*A[1,Q]))^(1/(1-a1[1,Q])),\n           1-gamma*(a1[i,Q]^a1[i,Q])*A[1,Q]*(wS[1,Q]/((a1[i,Q]^a1[i,Q])*A[1,Q]))^((2-a1[1,Q])/(1-a1[1,Q]))), 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values = ev$values)\n\n[1]  0.98368845 -0.04024869\n\n# Obtain determinant and trace\ndet=det(J)      # determinant\ntr=sum(diag(J)) # trace\n\n#Check stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n# Check specific stability condition for the case beta=1\nfor (i in 1:S){\nprint(paste0(\"Scenario \", i, \":\"))\nprint(2-gamma*((a1[i,Q]^a1[i,Q])*A[i,Q]*(wS[i,Q]/(((a1[i,Q]^a1[i,Q])*A[i,Q])))^((2-a1[i,Q])/(1-a1[i,Q]))) + a1[i,Q]*wS[i,Q]*(wS[i,Q]/(((a1[i,Q]^a1[i,Q])*A[i,Q]))^(1/(1-a1[i,Q])))&gt;0)\n}\n\n[1] \"Scenario 1:\"\n[1] TRUE\n[1] \"Scenario 2:\"\n[1] TRUE\n[1] \"Scenario 3:\"\n[1] TRUE\n[1] \"Scenario 4:\"\n[1] TRUE\n[1] \"Scenario 5:\"\n[1] TRUE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Initialize arrays for equilibrium solutions\nN_eq = np.zeros(S)\nK_eq = np.zeros(S)\n\n# Calculate equilibrium solutions\nfor i in range(S):\n    N_eq[i] = (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** (-1 / (1 - a1[i, Q-1]))\n    K_eq[i] = (a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1] * (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** (-a1[i, Q-1] / (1 - a1[i, Q-1]))\n\n# Compare with numerical solutions (example for N, baseline)\nN_eq[0]\nN[0,Q-1]\n\n# Construct Jacobian matrix at the equilibrium \nJ = np.array([\n    [1 - beta, beta * a1[0, Q-1] * wS[0, Q-1]],\n    [gamma * (wS[0, Q-1] / ((a1[0, Q-1] ** a1[0, Q-1]) * A[0, Q-1])) ** (1 / (1 - a1[0, Q-1])),\n     1 - gamma * (a1[0, Q-1] ** a1[0, Q-1]) * A[0, Q-1] * (wS[0, Q-1] / ((a1[0, Q-1] ** a1[0, Q-1]) * A[0, Q-1])) ** ((2 - a1[0, Q-1]) / (1 - a1[0, Q-1]))]\n])\n\n# Obtain eigenvalues\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\n\n# Check general stability conditions\nprint(1+tr+det&gt;0)\nprint(1-tr+det&gt;0)\nprint(1-det&gt;0)\n\n# Check specific stability condition for the case beta=1\nfor i in range(S):\n    print(f\"Scenario {i + 1}:\")\n    print(2 - gamma * (\n        (a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1] * \n        (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** ((2 - a1[i, Q-1]) / (1 - a1[i, Q-1])) +\n        a1[i, Q-1] * wS[i, Q-1] * (wS[i, Q-1] / ((a1[i, Q-1] ** a1[i, Q-1]) * A[i, Q-1])) ** (1 / (1 - a1[i, Q-1]))\n    ) &gt; 0)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#references",
    "href": "a_ricardian_two_sector_model.html#references",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "References",
    "text": "References\n\n\n\n\nFoley, Duncan K. 2006. Adam’s Fallacy. A Guide to Economic Theology. Cambridge, MA / London: Harvard University Press.\n\n\nPasinetti, Luigi L. 1960. “A Mathematical Formulation of the Ricardian System.” The Review of Economic Studies 27 (2): 78–98. https://doi.org/10.2307/2296129.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_ricardian_two_sector_model.html#footnotes",
    "href": "a_ricardian_two_sector_model.html#footnotes",
    "title": "15  A Ricardian Two-Sector Model",
    "section": "",
    "text": "See chapter 2 of Foley (2006) for an excellent introduction.↩︎\nSee Chapter 14 for a simpler one-sector version of the model,↩︎\nPasinetti (1960) specifies a generic function \\(f(N_t)\\) with \\(f(0) \\geq\\) 0, \\(f'(0) &gt; w^*\\), and \\(f''(N_t) &lt; 0\\). Equation 15.1 satisfies these conditions.↩︎\nEquation 15.6 is based on the definition of total rent as the sum of the net gains of the non-marginal landowners. See Pasinetti (1960) for a formal derivation. Note that by using Equation 15.2, Equation 15.6 can also be written as \\(R_t = Y_{1t}(1-a_1)\\).↩︎\nTo see this, notice that equation Equation 15.8 can be derived from \\(p_{t1}Y_{t1}-p_{t1}R_{t}=N_{t1}\\) if combined with equation Equation 15.6.↩︎\nOutput in equation Equation 15.9 is expressed in real terms and can be derived from \\(p_{2}Y_{2t}=p_{1t}R_t\\).↩︎\nThe luxury good may therefore serve as Ricardo’s ‘invariable standard of value’ in terms of which the value of all commodities could be expressed.↩︎\nNote that by combining Equation 15.13 with Equation 15.9, total profits can also be written as \\(P_t=p_{1t}(Y_{1t} - W_t)\\). In other words, total profits are independent of output in sector 2.↩︎\nThe increase in \\(a_2\\) does raise real output and profits in sector 2 but it leaves total profits unchanged.↩︎\nValuation effects from changes in relative prices were omitted for simplicity.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>A Ricardian Two-Sector Model</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html",
    "href": "a_Lewis_model.html",
    "title": "16  A Lewis Model of Economic Development",
    "section": "",
    "text": "Overview\nThis model captures some key features of W. Arthur Lewis (1954)’ two-sector model of the growth process of a developing country. The model describes the development process as one where a modern urban sector draws labour inputs from a traditional subsistence sector that is characterised by surplus labour, i.e. labour that does not produce any additional output (reflected in a zero marginal product). Workers in the traditional sector are paid a fixed subsistence wage. The presence of surplus labour allows the modern sector to attract workers from the traditional sector for a small wage premium above the subsistence wage. This enables the modern sector to make excess profits that are reinvested and thus drive rapid capital accumulation in the modern sector. As a result, the economy undergoes industrialisation. This process of rapid structural change comes to an end when the surplus labour in the traditional sector is depleted. Labour supply then becomes sensitive to the real wage, leading to a slowdown in the growth of profits and capital accumulation.\nWe present a formal version of the model that is adapted from the graphical representation in Todaro and Smith (2015), pp. 124-127.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#the-model",
    "href": "a_Lewis_model.html#the-model",
    "title": "16  A Lewis Model of Economic Development",
    "section": "The Model",
    "text": "The Model\n\\[\n    Y_{1t}=\n\\begin{cases}\n    \\lambda^\\alpha, &    \\text{if } L_{1t-1} &gt; \\lambda \\\\\n    L^\\alpha_{1t},& \\text{if } L_{1t-1}\\leq \\lambda\n\\end{cases}\n\\tag{16.1}\\]\n\\[\nw_{1t} = w^S  \n\\tag{16.2}\\]\n\\[\nL_{1t} = L - L_{2t}  \n\\tag{16.3}\\]\n\\[\nY_{2t} = L_{2t}^\\beta K_{2t}^{1-\\beta}  \n\\tag{16.4}\\]\n\\[\n    w_{2t}=\n\\begin{cases}\n    w^S(1 + \\rho), &    \\text{if } L_{1t-1} &gt; \\lambda \\\\\n    \\gamma L_{2t},& \\text{if } L_{1t-1}\\leq \\lambda\n\\end{cases}\n\\tag{16.5}\\]\n\\[\nMPL_{2t}= \\frac{\\partial Y_{2t}}{\\partial L_{2t}} = \\frac{\\beta Y_{2t}}{L_{2t}}\n\\tag{16.6}\\]\n\\[\nL_{2t}= L_{2t-1} + \\delta(MPL_{2t-1} - w_{2t-1})\n\\tag{16.7}\\]\n\\[\nP_{2t}=Y_{2t} - w_{2t}L_{2t}\n\\tag{16.8}\\]\n\\[\nK_{2t}=K_{2t-1} + P_{2t-1}\n\\tag{16.9}\\]\nwhere the subscripts 1 and 2 refer to the traditional and modern sector, respectively, and \\(Y_t\\), \\(w_t\\), \\(L_t\\), \\(MPL_t\\), \\(K_t\\), and \\(P_t\\) represent output, the real wage rate, employment, the marginal product of labour, the capital stock, and profits, respectively.\nEquation 16.1 describes output determination in the traditional sector. The variable \\(\\lambda\\) is the employment level beyond which the marginal product of labour (MPL) in sector 1 becomes zero. As long as employment is above this threshold, there is surplus labour and output is fixed at the level implied by the level of employment for which the MPL becomes zero (\\(\\lambda\\)). If actual employment falls below this level, the sector faces a production function that is increasing in employment but with diminishing marginal returns \\((\\alpha \\in (0,1))\\). By Equation 16.2, the real wage in the traditional sector is an exogenously given subsistence wage \\(w^S\\). Equation 16.3 says that the level of employment in the traditional sector is residually determined by the total labour supply net of employment in the modern sector. Total labour is taken to be exogenous. Unlike the traditional sector, the modern sector employs capital. Equation 16.4 is the production function of the modern sector, which exhibits constant returns to scale and diminishing marginal returns \\((\\beta\\in (0,1))\\). Equation 16.5 specifies wage determination in the modern sector. If there is surplus labour in the traditional sector, the modern sector pays a wage premium \\(\\rho\\) on the subsistence wage. As soon as surplus labour is depleted, the modern sector faces an upward-sloping labour supply curve, which we model for simplicity as a linear function with slope coefficient \\(\\gamma\\). Equation 16.6 specifies the marginal product of labour of the modern sector: \\(MPL_{2t}=\\beta L_{2t}^{\\beta-1} K_{2t}^{1-\\beta} = \\beta \\frac{Y_{2t}}{L_{2t}}\\). Equation 16.7 is the labour demand curve of the modern sector. To maximise profits, the firm would have to equalise the real wage and the MPL: \\(w_{2t}=MPL_{2t}\\). Equation 16.7 specifies this as a gradual process, where the rate at which the modern firm attracts workers from the traditional sector is increasing in the gap between their marginal product and the fixed wage the firm pays these workers. Finally, Equation 16.8 defines profits in the modern sector, and Equation 16.9 describes capital accumulation in that sector, where it is assumed that all profits are invested \\((P_{2t}=I_{2t})\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#simulation",
    "href": "a_Lewis_model.html#simulation",
    "title": "16  A Lewis Model of Economic Development",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable reports the parameterisation used in the simulation. All scenarios are initialised such that there is surplus labour (\\(L_{10} &gt; \\lambda\\)).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(L\\)\n\\(\\lambda\\)\n\\(\\alpha\\)\n\\(\\beta\\)\n\\(\\delta\\)\n\\(w^S\\)\n\\(\\gamma\\)\n\n\n\n1: baseline\n20\n10\n0.9\n0.7\n0.5\n0.4\n0.12\n\n\n2: rise subsistence wage (\\(w^S\\))\n20\n10\n0.9\n0.7\n0.5\n0.3\n0.12\n\n\n3: rise in labour supply elasticity (\\(\\gamma\\))\n20\n10\n0.9\n0.7\n0.5\n0.4\n0.17\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=250\n\n# Set number of scenarios (including baseline)\nS=3\n\n# Set period in which shock/shift will occur\ns=1\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1=matrix(data=1,nrow=S,ncol=Q) # Output in sector 1 (traditional)\nY2=matrix(data=1,nrow=S,ncol=Q) # Output in sector 2 (modern)\nL1=matrix(data=1,nrow=S,ncol=Q) # employment in sector 1\nL2=matrix(data=1,nrow=S,ncol=Q) # employment in sector 2\nw2=matrix(data=1,nrow=S,ncol=Q) # real wage sector 2\nMPL2 = matrix(data=1, nrow=S, ncol=Q) # marginal product of labour in sector 2\nK=matrix(data=1,nrow=S,ncol=Q) # capital stock (only in sector 2)\nP2=matrix(data=1,nrow=S,ncol=Q) #  profits in sector 2\n\n# Set fixed parameter values\nalpha=0.9 # labour elasticity of output, sector 1\nrho=1     # wage premium\nL=20      # total labour supply (exogenous)\nlambda=10 # employment at which MPL in sector 1 becomes zero\nbeta=0.7  # labour elasticity of output, sector 2\ndelta = 0.5  # sensitivity of employment in sector 2 to deviation of MPL2 from w2\n\n# Set baseline parameter values\nw1=matrix(data=0.4,nrow=S,ncol=Q) # subsistence real wage sector 1\ngamma=matrix(data=0.12, nrow=S, ncol=Q) # labour supply coefficient, sector 2\n\n# Set parameter values for different scenarios\nw1[2,s:Q]=0.3         # scenario 2: fall in subsistence wage\ngamma[3,s:Q]=0.17     # scenario 3: rise in labour supply elasticity\n\n# Create vectors that will record when the turning point occurs and when the simulation ends\ntp = rep(NA, S)\nend = rep(NA, S)\n\n# Initialise such that there is surplus labour (L1 &gt; lambda)\nL1[,1]= 0.9*L\nL2[,1]= L - L1[,1]\n\n# Simulate the model by looping over T time periods for S different scenarios\nfor (i in 1:S){\n  \n  # Create flag that will be set to TRUE when the turning point has been reached\n  cond = FALSE\n  \n  # Inititalise time index\n  t = 2\n  \n  # Run the model as long as the number of periods Q hasn't been reached yet and employment in sector 1 is positive \n  while (t &lt;= Q && L1[i, t-1] &gt; 0) {\n    \n   for (iterations in 1:1000){ \n      \n      ## Model equations\n      # Output sector1 and wages sector 2\n      if (!cond && L1[i, t-1] &gt; lambda) {\n      Y1[i,t] = lambda^alpha\n      w2[i,t]= w1[i,t]*(1 + rho)\n      }\n      else{\n      Y1[i,t] = (L1[i,t]^alpha)\n      w2[i,t]= gamma[i,t]*L2[i,t]\n      cond = TRUE # set the flag to TRUE once the condition is violated \n                  #(this prevents the iterations loop from getting trapped between the two conditions)\n      }\n\n      # Employment sector 1\n      L1[i,t] = L - L2[i,t]\n     \n      # Output sector 2\n      Y2[i,t]=(L2[i,t]^beta)*(K[i,t]^(1-beta))\n\n      # MPL sector 2\n      MPL2[i,t] = beta* (Y2[i, t]/L2[i, t]) \n            \n      # Employment sector 2 \n      L2[i,t] =L2[i, t-1] + delta*(MPL2[i,t-1] - w2[i,t-1])\n      \n      # Profits sector 2\n      P2[i,t]=Y2[i,t] - w2[i,t]*L2[i,t]\n      \n      # Capital accumulation sector 2\n      K[i,t]= K[i,t-1] + P2[i,t-1]\n\n    } # close iterations loop\n    \n      if (L1[i, t] &gt; lambda) {\n        tp[i] = t # record when turning point occurs\n      }\n    \n      if (L1[i, t] &lt;= 0) {\n        end[i] = t # record when L1 becomes non-positive, which terminates the simulation\n      }\n    \n    # Update time index  \n     t = t + 1\n\n  } # close time loop\n} # close scenarios loop\n\n# Calculate profits in S1\nP1=Y1 - w1*L1\n\n#Calculate aggregate profit share \nPS=(P1 + P2)/(Y1 + Y2)\n\n# Calculate sectoral profit shares\nPS1=(P1)/(Y1)\nPS2=(P2)/(Y2)\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 250\n\n# Set number of scenarios (including baseline)\nS = 3\n\n# Set period in which shock/shift will occur\ns = 1\n\n# Create (S x Q)-matrices that will contain the simulated data\nY1 = np.ones((S, Q))  # Output in sector 1 (traditional)\nY2 = np.ones((S, Q))  # Output in sector 2 (modern)\nL1 = np.ones((S, Q))  # Employment in sector 1\nL2 = np.ones((S, Q))  # Employment in sector 2\nw2 = np.ones((S, Q))  # Real wage sector 2\nMPL2 = np.ones((S, Q))  # Marginal product of labour in sector 2\nK = np.ones((S, Q))  # Capital stock (only in sector 2)\nP2 = np.ones((S, Q))  # Profits in sector 2\n\n# Set fixed parameter values\nalpha = 0.9  # Labour elasticity of output, sector 1\nrho = 1  # Wage premium\nL = 20  # Total labour supply (exogenous)\nlambda_ = 10  # Employment at which MPL in sector 1 becomes zero\nbeta = 0.7  # Labour elasticity of output, sector 2\ndelta = 0.5  # Sensitivity of employment in sector 2 to deviation of MPL2 from w2\n\n# Set baseline parameter values\nw1 = np.full((S, Q), 0.4)  # Subsistence real wage sector 1\ngamma = np.full((S, Q), 0.12)  # Labour supply coefficient, sector 2\n\n# Set parameter values for different scenarios\nw1[1, s:Q] = 0.3  # Scenario 2: fall in subsistence wage\ngamma[2, s:Q] = 0.17  # Scenario 3: rise in labour supply elasticity\n\n# Create vectors that will record when the turning point occurs and when the simulation ends\ntp = np.full(S, np.nan)\nend = np.full(S, np.nan)\n\n# Initialise such that there is surplus labour (L1 &gt; lambda)\nL1[:, 0] = 0.9 * L\nL2[:, 0] = L - L1[:, 0]\n\n# Simulate the model by looping over time periods for different scenarios\nfor i in range(S):\n    cond = False  # Flag for turning point condition\n    t = 1  # Initialize time index (Python uses 0-based indexing)\n\n    # Run the model as long as Q periods haven't been reached and employment in sector 1 is positive\n    while t &lt; Q and L1[i, t-1] &gt; 0:\n        for _ in range(1000):  # Iterations loop\n            # Model equations for output sector 1 and wages sector 2\n            if not cond and L1[i, t-1] &gt; lambda_:\n                Y1[i, t] = lambda_**alpha\n                w2[i, t] = w1[i, t] * (1 + rho)\n            else:\n                Y1[i, t] = L1[i, t]**alpha\n                w2[i, t] = gamma[i, t] * L2[i, t]\n                cond = True  # Set flag once condition is violated\n\n            # Employment sector 1\n            L1[i, t] = L - L2[i, t]\n\n            # Output sector 2\n            Y2[i, t] = (L2[i, t]**beta) * (K[i, t]**(1 - beta))\n\n            # MPL sector 2\n            MPL2[i, t] = beta * (Y2[i, t] / L2[i, t])\n\n            # Employment sector 2\n            L2[i, t] = L2[i, t-1] + delta * (MPL2[i, t-1] - w2[i, t-1])\n\n            # Profits sector 2\n            P2[i, t] = Y2[i, t] - w2[i, t] * L2[i, t]\n\n            # Capital accumulation sector 2\n            K[i, t] = K[i, t-1] + P2[i, t-1]\n\n        # Record turning point\n        if L1[i, t] &gt; lambda_:\n            tp[i] = t\n\n        # Record when L1 becomes non-positive\n        if L1[i, t] &lt;= 0:\n            end[i] = t\n\n        # Update time index\n        t += 1\n\n# Calculate profits in sector 1\nP1 = Y1 - w1 * L1\n\n# Calculate aggregate profit share\nPS = (P1 + P2) / (Y1 + Y2)\n\n# Calculate sectoral profit shares\nPS1 = P1 / Y1\nPS2 = P2 / Y2\n\n\n\n\nPlots\nFigure 18.2 - Figure 16.3 display the model’s dynamics under the baseline scenario. The red vertical line marks the ‘Lewis turning point’, which is the period in which the surplus labour in the traditional sector is depleted \\((L_{1t}&lt;\\lambda)\\). It can be seen that before the Lewis turning point is reached, output in the modern sector grows exponentially thanks to the availability of cheap surplus labour whose employment comes with rising profits. After the turning point, output continues to increase but at a lower rate. This is because as the surplus labour in the traditional sector is depleted, the modern sector faces an upward-sloping labour supply curve. As a result, real wages increase and profits are reduced. This slows down capital accumulation and growth. In the traditional sector, output falls after the turning point as the sector now faces diminishing marginal return to labour.\n\n# Set start and end periods for plots\nTmax=50\nTmin=2\n\n#Output in the two sectors, baseline\nplot(Y1[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y\", ylim=range(Y1[1, Tmin:Tmax],Y2[1, Tmin:Tmax])) \ntitle(main=\"Output in traditional (Y1) and modern (Y2) sector\", xlab = 'Time',cex=0.8 ,line=2)\nlines(Y2[1, Tmin:Tmax],lty=2)\nabline(v = tp[1], col = \"darkred\")\nlegend(\"topleft\", legend=c(expression(Y[1]), expression(Y[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.1: Output in traditional (Y1) and modern (Y2) sector\n\n\n\n\n\n#Employment in the two sectors, baseline\nplot(L1[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"L\", ylim=range(L1[1, Tmin:Tmax],L2[1, Tmin:Tmax])) \ntitle(main=\"Employment in traditional (L1) and modern (L2) sector\", xlab = 'Time',cex=0.8 ,line=2)\nlines(L2[1, Tmin:Tmax],lty=2)\nabline(v = tp[1], col = \"darkred\")\nlegend(\"right\", legend=c(expression(L[1]), expression(L[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.2: Employment in traditional (L1) and modern (L2) sector\n\n\n\n\n\n#Profits and capital accumulation in manufacturing, baseline\nplot(P2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"\", ylim=range(P2[1, Tmin:Tmax])) \ntitle(main=\"Capital accumulation and profits in modern sector\", ylab = expression(P[2]), xlab = 'Time', cex=0.8, line=2)\nabline(v = tp[1], col = \"darkred\")\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE,\n     xlab = '',ylim = range(K[1, Tmin:Tmax]),cex.axis=1,cex.lab=0.75)\naxis(side = 4, at = pretty(range(K[1, Tmin:Tmax])))  \nmtext(expression(K[2]), side = 4, line = 2)\nlegend(\"bottomright\", legend=c(expression(P[2]), expression(K[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.3: Capital accumulation and profits in modern sector\n\n\n\n\nFigure 16.4 and Figure 16.5 illustrate the distributional implications of the model. Before the Lewis turning point, the profit share of the modern sector increases, as firms benefit from a real wage that is fixed below the marginal product of labour. After the turning point, real wages jump upwards and begin to increase further, gradually closing the gap with the marginal product. As a result, the profit share falls and embarks on a downward convergence to the level implied by the marginal product of labour.1 The aggregate profit share broadly displays an inverted U-shaped pattern.\n\n# Real wage and profit share in manufacturing\nplot(PS2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"\", xlim=range(Tmin:Tmax), ylim=range(PS2[1, Tmin:Tmax])) \ntitle(main=\"Profit share and real wage in modern sector\",ylab = expression(pi[2]), xlab = 'Time', cex=0.8, line=2)\nabline(v = tp[1], col = \"darkred\")\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(w2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=2, font.main=1,cex.main=1,ylab = '', axes=FALSE, xlim=range(0:Tmax),\n     xlab = '', ylim = range(w2[1, Tmin:Tmax]), cex.axis=1,cex.lab=0.75)\naxis(side = 4, at = pretty(range(w2[1, Tmin:Tmax])))  \nmtext(expression(w[2]), side = 4, line = 2)\nlegend(\"topleft\", legend=c(expression(pi[2]), expression(w[2])),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.4: Real wage and profit share in modern sector\n\n\n\n\n\n# Aggregate profit share\nplot(PS[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=expression(pi), xlim=range(Tmin:Tmax), ylim=range(PS[1, Tmin:Tmax])) \ntitle(main=\"Aggregate profit share\",ylab = '', xlab = 'Time', cex=0.8, line=2)\nabline(v = tp[1], col = \"darkred\")\n\n\n\n\n\n\nFigure 16.5: Aggregate profit share\n\n\n\n\nFigure 17.2 compares output dynamics in the modern sector for the baseline scenario with scenario 2 in which the subsistence wage \\(w^s\\) is fixed at a lower level and with scenario 3 in which the labour supply elasticity \\(\\gamma\\) the modern sector faces after the turning point is higher. It can be seen that for a lower subsistence wage, the modern sector grows faster and the Lewis turning point is reached earlier. For a higher labour supply elasticity, the labour supply curve after the turning point is steeper, which leads to a faster increase in the real wage, a stronger squeeze of profits, and thus slower output growth. These results illustrate the Classical nature of the model, whereby capital accumulation is driven by profits. Thus, any reduction in profits slows down the growth process.\n\nTmax=60\nplot(Y2[1, Tmin:Tmax],type=\"l\", col=1, lwd=2, lty=1, xlim=range(Tmin:Tmax), xlab=\"\", ylab=expression(Y[2]), ylim=range(Y2[1, Tmin:Tmax],Y2[2, Tmin:Tmax])) \ntitle(main=\"Output in  modern sector\", xlab = 'Time',cex=0.8 ,line=2)\nlines(Y2[2, Tmin:Tmax],lty=2)\nlines(Y2[3, Tmin:Tmax],lty=3)\nabline(v = tp[1], col = \"darkred\")\nabline(v = tp[2], col = \"red\")\nlegend(\"bottomright\", legend=c(\"1: baseline\", \"2: lower subsistence wage\", \"3: higher labour supply elasticity\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 16.6: Output in modern sector under different scenarios\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Plots (here only for output)\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots (set as integers)\nTmax = int(end[0] -2)\nTmin = int(2)\n\n# Output in the two sectors, baseline\nplt.plot(range(Tmin, Tmax + 1), Y1[0, Tmin:Tmax + 1], 'k-', linewidth=2, label='Y1')\nplt.plot(range(Tmin, Tmax + 1), Y2[0, Tmin:Tmax + 1], 'k--', linewidth=2, label='Y2')\n\n# Highlight Lewis turning point\nplt.axvline(x=tp[0], color='darkred', linestyle='-')\n\n# Set plot labels and title\nplt.title('Output in traditional (Y1) and modern (Y2) sector')\nplt.xlabel('Time')\nplt.ylabel('Y')\nplt.ylim(min(Y1[0, Tmin:Tmax]), max(Y2[0, Tmin:Tmax]))\n\n# Add legend\nplt.legend(loc='upper left')\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#directed-graph",
    "href": "a_Lewis_model.html#directed-graph",
    "title": "16  A Lewis Model of Economic Development",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 9 variables: \n\n#              Y1,Y2,L1,L2,w1,w2,P2,K, MPL2\nM_mat=matrix(c(0, 0, 1, 0, 0, 0, 0, 0, 0,\n               0, 0, 0, 1, 0, 0, 0, 1, 0,\n               0, 0, 0, 1, 0, 0, 0, 0, 0, \n               0, 0, 0, 0, 0, 1, 0, 0, 1, \n               0, 0, 0, 0, 0, 0, 0, 0, 0,\n               0, 0, 0, 0, 1, 0, 0, 0, 0,\n               0, 1, 0, 1, 0, 1, 0, 0, 0,\n               0, 0, 0, 0, 0, 0, 1, 0, 0,\n               0, 1, 0, 1, 0, 0, 0, 0, 0), 9, 9, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian \nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg= graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(expression(Y[1]), expression(Y[2]), expression(L[1]), expression(L[2]), \n             expression(w[1]), expression(w[2]), expression(P[2]), \"K\", \"MPL\")\n\n# Plot directed graph\nplot(dg, main=\"Directed Graph of Lewis Model\", vertex.size=20, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create directed graph\nimport networkx as nx\n\n# Create the adjacency matrix (M_mat in R)\nM_mat = np.array([[0, 0, 1, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 1, 0, 0, 0, 1, 0],\n                  [0, 0, 0, 1, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 1, 0, 0, 1],\n                  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 1, 0, 0, 0, 0],\n                  [0, 1, 0, 1, 0, 1, 0, 0, 0],\n                  [0, 0, 0, 0, 0, 0, 1, 0, 0],\n                  [0, 1, 0, 1, 0, 0, 0, 0, 0]])\n\n# Transpose the matrix to get A_mat\nA_mat = M_mat.transpose()\n\n# Create a directed graph from the adjacency matrix using networkx\nG = nx.DiGraph(A_mat)\n\n# Define the node labels as expressions for plotting\nnodelabs  = {0: r'$Y_1$', 1: r'$Y_2$', 2: r'$L_1$', 3: r'$L_2$', \n          4: r'$w_1$', 5: r'$w_2$', 6: r'$P_2$', 7: 'K', 8: 'MPL'}\n\n# Plot the graph\npos = nx.spring_layout(G, k=0.4)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Directed Graph of Lewis Model\")\nplt.show()\n\n\n\n\nThe directed graph illustrates that the subsistence wage in the traditional sector \\(w_1=w^s\\) is the key exogenous variables that impact the dynamics of growth and distribution via its effect on real wages in the modern sector. Employment, output, profits, and capital accumulation in the modern sector form a closed loop (or cycle) within the system. The traditional sector plays a residual role.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#analytical-discussion",
    "href": "a_Lewis_model.html#analytical-discussion",
    "title": "16  A Lewis Model of Economic Development",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nLet us analyse the dynamic stability of the model before the Lewis turning point, i.e. for the case where \\((L_{1t}&gt;\\lambda)\\) such that \\(w_2\\) is exogenous. Combining Equation 16.7 and Equation 16.6 yields a first-order difference equation for \\(L_2\\), and combining Equation 16.9, Equation 16.8, and Equation 16.7, yields a first-order difference equation for \\(K_2\\):\n\\[\nL_{2t}= L_{2t-1} + \\delta(\\beta L_{2t-1}^{\\beta -1}K_{2t-1}^{1-\\beta} - w_{2})\n\\] \\[\nK_{2t}=K_{2t-1} + L_{2t-1}^\\beta K_{2t-1}^{1-\\beta} - wL_{2t-1}\n\\] The Jacobian matrix is given by:\n\\[\nJ(L_2, K_2)=\\begin{bmatrix} 1+ \\delta\\beta (\\beta-1) L_{2t-1}^{\\beta-2} K_{2t-1}^{1-\\beta}   &\\delta\\beta (1-\\beta) L_{2t-1}^{\\beta-1} K_{2t-1}^{-\\beta} \\\\ \\beta L_{2t-1}^{\\beta-1} K_{2t-1}^{1-\\beta} -w & 1+ (1-\\beta) L_{2t-1}^{\\beta} K_{2t-1}^{-\\beta} \\end{bmatrix}.\n\\]\nFor the system to be stable, both eigenvalues of the Jacobian need to be inside the unit circle. This requires the following three conditions to hold:\n\\[\n1+tr(J)+det(J)&gt;0\n\\] \\[\n1-tr(J)+det(J)&gt;0\n\\] \\[\n1-det(J)&gt;0,\n\\] where \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nWith \\(tr(J)\\) clearly positive, let us focus on \\(1-tr(J)+det(J)&gt;0\\). Plugging in \\(tr(J)\\) and \\(det(J)\\) and simplifying yields:\n\\[\nw_2 - \\frac{Y_{2t-1}}{L_{2t-1}}&gt;0.\n\\] As long as the real wage is below the average product of labour, \\(\\frac{Y_{2}}{L_{2}}\\), the condition will be violated, as there are positive profits and thus capital accumulation. With the real wage being lower or equal to the marginal product of labour, this is indeed the case. The system is then dynamically unstable and will generate exponential growth.\nWe can check this stability analysis numerically:\n\n### Examine stability before the turning point (here for the baseline scenario only)\n\n# Construct Jacobian matrix before the turning point \nJ=matrix(c(1 + delta*beta*(beta-1)*(L2[1,tp[1]-1]^(beta-2))*(K[1,tp[1]-1]^(1-beta)), \n           delta*beta*(1-beta)*(L2[1,tp[1]-1]^(beta-1))*(K[1,tp[1]-1]^(-beta)),\n           beta*(L2[1,tp[1]-1]^(beta-1))*(K[1,tp[1]-1]^(1-beta)) - w2[1,tp[1]-1],\n           1 + (1-beta)*(L2[1,tp[1]-1]^(beta))*(K[1,tp[1]-1]^(-beta))), \n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev=eigen(J)\n(values = ev$values)\n\n[1] 1.0552484 0.9580697\n\n# Obtain determinant and trace\n(det=det(J))      # determinant\n\n[1] 1.011002\n\n(tr=sum(diag(J))) # trace\n\n[1] 2.013318\n\n#Check stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] FALSE\n\nprint(1-det&gt;0)\n\n[1] FALSE\n\n# Check simplified stability condition\nprint(w2[1,(tp[1]-1)] - Y2[1,(tp[1]-1)]/L2[1,(tp[1]-1)] &gt;0)\n\n[1] FALSE\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Examine stability before the turning point (here for the baseline scenario only)\n\n# Set turning point as integer\ntp = tp.astype(int)  \n\n# Construct Jacobian matrix before the turning point \nJ = np.array([\n    [1 + delta * beta * (beta - 1) * (L2[0, tp[0]-1] ** (beta - 2)) * (K[0, tp[0]-1] ** (1 - beta)),\n     delta * beta * (1 - beta) * (L2[0, tp[0]-1] ** (beta - 1)) * (K[0, tp[0]-1] ** (-beta))],\n    [beta * (L2[0, tp[0]-1] ** (beta - 1)) * (K[0, tp[0]-1] ** (1 - beta)) - w2[0, tp[0]-1],\n     1 + (1 - beta) * (L2[0, tp[0]-1] ** beta) * (K[0, tp[0]-1] ** (-beta))]\n])\n\n# Obtain eigenvalues\neigenvalues, eigenvectors = np.linalg.eig(J)\nprint(eigenvalues)\n\n# Obtain determinant and trace\ndet = np.linalg.det(J)\ntr = np.trace(J)\n\n# Check general stability conditions\nprint(1+tr+det&gt;0)\nprint(1-tr+det&gt;0)\nprint(1-det&gt;0)\n\n# Check simplified stability condition\nprint(w2[0, tp[0]-1] - Y2[0, tp[0]-1] / L2[0, tp[0]-1] &gt; 0)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#references",
    "href": "a_Lewis_model.html#references",
    "title": "16  A Lewis Model of Economic Development",
    "section": "References",
    "text": "References\n\n\n\n\nLewis, W. A. 1954. “Economic Development with Unlimited Supplies of Labour.” The Manchester School 22 (2): 139–91. https://doi.org/10.1111/j.1467-9957.1954.tb00021.x.\n\n\nTodaro, Michael P., and Stephen C. Smith. 2015. Economic Development, 12th Edition. Pearson.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Lewis_model.html#footnotes",
    "href": "a_Lewis_model.html#footnotes",
    "title": "16  A Lewis Model of Economic Development",
    "section": "",
    "text": "In equilibrium, where \\(L_{2t} - L_{2t-1} =0\\), the real wage \\(w_2\\) will be equal to the MPL in sector 2. The profit share is then constant and given by \\(\\frac{P{_2}}{Y{_2}} = 1-\\beta\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Lewis Model of Economic Development</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html",
    "href": "a_Hicks_model.html",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "",
    "text": "Overview\nThis model captures some key features of John R. Hicks (1950)’ nonlinear model of business cycle fluctuations. The model builds on Samuelson (1939)’s linear multiplier-accelerator model analysed in Chapter 2 and Chapter 9, but gives it a different twist. While Samuelson (1939)’s business cycle model usually requires repeated external shocks to produce sustained cycles, Hicks (1950)’s model produces permanent, shock-independent fluctuations that are bounded by a floor and a ceiling.1 The goods market equilibrium is assumed to be locally unstable due to a strong accelerator effect, i.e. investment reacts strongly to increases in aggregate output, which creates more output and boosts investment even further. However, aggregate output is constrained by a ceiling that may stem from full employment (and a fixed labour supply). On the downward trajectory, output is constrained by a floor that is given by a minimum amount of investment needed to replace the depreciated capital stock.\nWe present a version of the model that is adapted from Gabisch and Lorenz (1989), chapter 2.1.2",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#the-model",
    "href": "a_Hicks_model.html#the-model",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "The Model",
    "text": "The Model\n\\[\n  Y_{t}=\\min[C_t + I_t, Y^C]\n\\tag{17.1}\\]\n\\[\nC_{t} = c_0 + c_1 Y_{t-1},  \\quad c_1 \\in (0,1)\n\\tag{17.2}\\]\n\\[\nI_{t} = I_0 + \\max[\\beta(Y_{t-1} - Y_{t-2}), -D],  \\quad \\beta &gt; 1, D &gt;0\n\\tag{17.3}\\]\nwhere \\(Y_t\\), \\(C_t\\), \\(I_t\\), \\(Y^C\\), and \\(D\\), represent output, consumption, investment, the (full employment) output ceiling, and depreciation, respectively.\nEquation 17.1 specifies aggregate income. For values below the ceiling \\(Y^C\\), aggregate income is determined by aggregate demand (consisting only of consumption and net investment). As soon as aggregate demand hits the ceiling, aggregate income is given by the ceiling. Equation 17.2 is a simple linear Keynesian consumption function. Equation 17.3 is the investment function. For investment levels above depreciation \\(D\\), net investment is given by an autonomous component \\(I_0\\) and an accelerator component that is responsive to the change in aggregate income.3 The reaction coefficient \\(\\beta\\) is assumed to be sufficiently large to generate explosive dynamics. Once the change in aggregate income has fallen below the negative of the level of depreciation \\(D\\), net investment is given by the floor \\(I_0 - D\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#simulation",
    "href": "a_Hicks_model.html#simulation",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. Besides a baseline (scenario 1), we consider a fall in the output ceiling \\(Y^C\\) in scenario 2, an increase in the investment floor \\(I_0 - D\\) in scenario 3, and finally a decrease in the accelerator coefficient \\(\\beta\\) (scenario 4).\nTable 1: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(c_0\\)\n\\(c_1\\)\n\\(I_0\\)\n\\(\\beta\\)\n\\(Y^C\\)\n\\(D\\)\n\n\n\n1: baseline\n0\n0.75\n10\n1.25\n80\n10\n\n\n2: fall in output ceiling (\\(Y^C\\))\n0\n0.75\n10\n1.25\n100\n10\n\n\n3: increase in investment floor (\\(I_0 - D\\))\n0\n0.75\n10\n1.25\n80\n1\n\n\n4: decrease in accelerator coefficient (\\(\\beta\\))\n0\n0.75\n10\n0.8\n80\n10\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=200\n\n# Set number of scenarios (including baseline)\nS=4\n\n# Set period in which shock/shift will occur\ns=50\n\n# Create (S x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=S,ncol=Q) # Income/output\nC=matrix(data=1,nrow=S,ncol=Q) # Consumption\nI=matrix(data=1,nrow=S,ncol=Q) # Investment\n\n# Set fixed parameter values\nc0=0\nc1=0.75\nI0=10\n\n# Set baseline parameter values\nYc=matrix(data=80,nrow=S,ncol=Q)      # output ceiling\nD=matrix(data=10,nrow=S,ncol=Q)       # investment floor (depreciation)\nbeta=matrix(data=1.25,nrow=S,ncol=Q)  # accelerator coefficient\n\n# Set parameter values for different scenarios\nYc[2,s:Q]=100 # scenario 2: increase in output ceiling\nD[3,s:Q]=1    # scenario 3: increase in investment floor\nbeta[4,s:Q]=0.8 # scenario 4: reduction in accelerator coefficient\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:500){ # run the model 500-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = min(C[i,t]+I[i,t], Yc[i,t])\n    \n    #(2) Consumption\n    C[i,t] = c0 + c1*Y[i,t-1]\n    \n    #(3) Investment\n    I[i,t] = I0 + max(beta[i,t]*(Y[i,t-1] - Y[i,t-2]), -D[i,t]) \n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 200\n\n# Set number of scenarios (including baseline)\nS = 4\n\n# Set period in which shock/shift will occur\ns = 50\n\n# Create (S x Q)-arrays that will contain the simulated data\nY = np.ones((S, Q))  # Income/output\nC = np.ones((S, Q))  # Consumption\nI = np.ones((S, Q))  # Investment\n\n# Set fixed parameter values\nc0 = 0\nc1 = 0.75\nI0 = 10\n\n# Set baseline parameter values\nYc = np.full((S, Q), 80)      # output ceiling\nD = np.full((S, Q), 10)       # investment floor (depreciation)\nbeta = np.full((S, Q), 1.25)  # accelerator coefficient\n\n# Set parameter values for different scenarios\nYc[1, s:Q] = 100     # scenario 2: increase in output ceiling\nD[2, s:Q] = 1        # scenario 3: increase in investment floor\nbeta[3, s:Q] = 0.8   # scenario 4: reduction in accelerator coefficient\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor i in range(S):\n    \n    for t in range(1, Q):\n        \n        for iterations in range(500):  # run the model 500-times in each period\n            \n            # Model equations\n            \n            # (1) Output\n            Y[i, t] = min(C[i, t] + I[i, t], Yc[i, t])\n            \n            # (2) Consumption\n            C[i, t] = c0 + c1 * Y[i, t - 1]\n            \n            # (3) Investment\n            I[i, t] = I0 + max(beta[i, t] * (Y[i, t - 1] - Y[i, t - 2]), -D[i, t])\n            \n        # Close iterations loop\n    # Close time loop\n# Close scenario loop\n\n\n\n\nPlots\nFigure 17.1 displays the model’s dynamics under the baseline scenario. The model generates cycles in aggregate output, consumption and investment that are constrained by the output ceiling \\(Y^C=80\\) and the investment floor \\(I_0-D=0\\). These cycles are permanent, i.e. they don’t require any external shocks, and they are (roughly) periodic, with a cycle length from peak (trough) to peak (trough) of around 13.5 periods. What generates the turning points? Suppose income is on an increasing trajectory. The accelerator effect on investment will amplify this process as firms will increase their investment, which raises aggregate demand and increases income further. When the output ceiling is reached, the change in income becomes zero, and investment demand decreases relative to the boom phase. This decrease in investment lowers aggregate output, and the accelerator effect again amplifies this tendency that now plays out on a downward trajectory until net investment hits the lower bound. Once investment has stopped its downward trajectory, aggregate income stops falling as well, which allows the accelerator effect to turn positive again and thereby induce a new cycle.\n\n# Set start and end periods for plots\nTmax=100\nTmin =10\n\n#Income, consumption, and investment\nplot(Y[1, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[1, Tmin:Tmax],Y[1, Tmin:(Tmax)]))\ntitle(main=\"Income, consumption, and investment (baseline)\", xlab = 'Time',cex=0.8,line=2)\nlines(C[1, Tmin:Tmax],lty=2)\nlines(I[1, Tmin:Tmax],lty=3)\nlegend(\"topleft\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.1: Income, consumption, and investment (baseline)\n\n\n\n\nIn Figure 17.2, the output ceiling rises to \\(Y^C = 100\\) in \\(t=50\\). This raises the amplitude of the cycles. Interestingly, the ceiling is no longer binding, but the cycles still do not explode. This illustrates a feature of the model that has been noted before: it actually does not need a ceiling to generate bounded cycles (see, e.g., Puu, Gardini, and Sushko (2005)). The acceleration of income during a boom will become smaller and smaller, and eventually turn negative, thereby lowering investment and inducing a switch from boom to bust. Hence, cycles (and thus turning points) will occur even without floor and ceilings, but to prevent these cycles to become larger and larger, a floor is sufficient.\n\n# Scenario 2: increase in ceiling\nplot(Y[2, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[2, Tmin:Tmax],Y[2, Tmin:(Tmax)]))\ntitle(main=\"Scenario 2: Increase in output ceiling\", xlab = 'Time',cex=0.8,line=2)\nlines(C[2, Tmin:Tmax],lty=2)\nlines(I[2, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.2: Increase in output ceiling\n\n\n\n\nAn increase in the investment floor to \\(I_0 - D = 9\\) in period \\(t=50\\), displayed in Figure 17.3, has the effect of reducing the amplitude of the fluctuations. Intuitively, the milder the bust, the milder the recovery.\n\n# Scenario 3: increase in investment floor\nplot(Y[3, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[3, Tmin:Tmax],Y[3, Tmin:(Tmax)]))\ntitle(main=\"Scenario 3: Increase in investment floor\", xlab = 'Time',cex=0.8,line=2)\nlines(C[3, Tmin:Tmax],lty=2)\nlines(I[3, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.3: Increase in investment floor\n\n\n\n\nFinally, Figure 17.4 displays the scenario where the accelerator coefficient \\(\\beta\\) falls, rendering investment much less sensitive to changes in aggregate income. As a result, the model’s regular cycles turn into damped oscillations that eventually converge to a stable equilibrium.\n\n# Scenario 4: Reduction in accelerator coefficient\nplot(Y[4, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"Y, C, I\", ylim=range(I[4, Tmin:Tmax],Y[4, Tmin:(Tmax)]))\ntitle(main=\"Scenario 4: Reduction in accelerator coefficient\", xlab = 'Time',cex=0.8,line=2)\nlines(C[4, Tmin:Tmax],lty=2)\nlines(I[4, Tmin:Tmax],lty=3)\nlegend(\"topright\", legend=c(\"Y\", \"C\", \"I\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 17.4: Reduction in accelerator coefficient\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Plots (here only for baseline)\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmax = 100\nTmin = 10\n\n# Plot income (Y), consumption (C), and investment (I)\nplt.plot(range(Tmin, Tmax), Y[0, Tmin:Tmax], label='Y', color='black', linewidth=2, linestyle='-')\nplt.title(\"Income, consumption, and investment (baseline)\", fontsize=10)\nplt.xlabel('Time')\nplt.ylabel('Y, C, I')\nplt.plot(range(Tmin, Tmax), C[0, Tmin:Tmax], label='C', linestyle='--', color='black',)\nplt.plot(range(Tmin, Tmax), I[0, Tmin:Tmax], label='I', linestyle=':', color='black',)\n\n# Add a legend to the top-left corner\nplt.legend(loc='upper left', fontsize=8, frameon=False)\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#directed-graph",
    "href": "a_Hicks_model.html#directed-graph",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 5 variables: \n  # endogenous: (1) Y, (2) C, (3) I\n  # exogenous: (4) I0-D, (5) Yc\n\n              #Y C I I0-D Yc\nM_mat=matrix(c(0,1,1, 0,  1, # Y\n               1,0,0, 0,  0, # C\n               1,0,0, 1,  0, # I\n               0,0,0, 0,  0, # I0-D\n               0,0,0, 0,  0),# Yc\n               5, 5, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"C\", \"I\", expression(I[0]-D), expression(Y^C))\n\n# Plot directed graph matrix\nplot(dg, main=\"Directed graph of Hicks model\", vertex.size=40, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Directed graph\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 5 variables: \n# endogenous: (1) Y, (2) C, (3) I\n# exogenous: (4) I0-D, (5) Yc\n\n# Create the matrix M_mat\nM_mat = np.array([[0, 1, 1, 0, 1],  # Y\n                  [1, 0, 0, 0, 0],  # C\n                  [1, 0, 0, 1, 0],  # I\n                  [0, 0, 0, 0, 0],  # I0-D\n                  [0, 0, 0, 0, 0]]) # Yc\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat = M_mat.T\n\n# Create directed graph from adjacency matrix using networkx\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"Y\", 1: \"C\", 2: \"I\", 3: \"$I_0 - D$\", 4: \"$Y^C$\"}\n\n# Plot directed graph\npos = nx.spring_layout(G, k=0.08)\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\nplt.axis(\"off\")\nplt.title(\"Directed Graph of Lewis Model\")\nplt.show()\n\n\n\n\nIt can thus be seen that the key exogenous variables in the Hicks (1950) model are the output ceiling \\(Y^C\\) and the investment floor \\(I_0 - D\\), which constrain the endogenous cycle generated by the interaction between the endogenous variables income \\(Y\\), investment \\(I\\), and consumption \\(C\\).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#analytical-discussion",
    "href": "a_Hicks_model.html#analytical-discussion",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nThe dynamic properties of the Hicks (1950) model when the floor and ceiling are not binding are similar, but not entirely equivalent to the Samuelson (1939) model analysed in Chapter 9.\nFirst, define \\(X_t = Y_{t-1}\\) to re-write the system as:\n\\[\n  X_{t}=\\min[C_{t-1} + I_{t-1}, Y^C]\n\\tag{17.4}\\]\n\\[\nC_{t} = c_0 + c_1 X_{t}\n\\tag{17.5}\\]\n\\[\nI_{t} = I_0 + \\max[\\beta(X_{t} - X_{t-1}), -D].\n\\tag{17.6}\\]\nThen shift Equation 17.5 one period back and substite into Equation 17.4 to obtain:\n\\[\n  X_{t}=\\min [c_0 + c_1 X_{t-1} + I_{t-1}, Y^C].\n\\tag{17.7}\\]\nNext, substitute Equation 17.7 into Equation 17.6:\n\\[\nI_{t} = I_0 + \\max[\\beta( c_0 + (c_1 -1) X_{t-1} + I_{t-1}), -D].\n\\tag{17.8}\\]\nEquation 17.7 and Equation 17.8 are a two-dimensional dynamic system in \\(X_t\\) and \\(It\\).\nFor \\(Y_t &lt; Y^C\\) and \\(I_t &gt; I_0 - D\\), the system’s Jacobian matrix is given by:\n\\[\nJ=\\begin{bmatrix} c_1 & 1 \\\\ \\beta(c_1-1) & \\beta  \\end{bmatrix}.\n\\]\nThe characteristic polynomial yielding the eigenvalues of the Jacobian is:\n\\[\\lambda^2-\\lambda(c_1+\\beta)+\\beta=0,\\]\nwhere \\(c_1+\\beta =tr(J)\\) and \\(\\beta = det(J)\\).\nThus, we have:\n\\[\n\\lambda_{1,2} = \\frac{(c_1+\\beta) \\pm \\sqrt{(c_1+\\beta)^2-4\\beta}}{2},\n\\]\nand two eigenvalues will be a pair of complex conjugates if \\((c_1+\\beta)^2-4\\beta &lt;0\\) or \\(\\left( \\frac{c_1+\\beta}{2} \\right)^2 &lt; \\beta\\).\nTo assess stability, we need to check whether the modulus of the complex eigenvalue \\(R\\) is inside the unit circle, i.e. \\(R \\in (-1,1)\\). For a two-dimensional system with complex eigenvalues, we have \\(R=\\sqrt{det(J)}\\). Thus, the stability condition for the Hicks model is \\(\\beta &lt;1\\).\nThe following code generates a plot that displays the condition for cycles, \\(\\left( \\frac{c_1+\\beta}{2} \\right)^2 &lt; \\beta\\), and the stability condition, \\(\\beta &lt;1\\), in the \\((\\beta, c_1)\\)-space:4\n\n# Create function for cycle condition using beta as argument\ncyc= function (beta) {\n  2*sqrt(beta)-beta\n}\n\n# Plot the two conditions in (beta, c1)-space\ncurve(cyc, from = 0, to = 4.5, col = 1, xlab=expression(beta), ylab=expression(c[1]) , main=\"\",\n      lwd=1.5, n=10000, ylim=range(0,1.5))\nabline(v=1, col=2)\nlegend(\"topright\", legend = c(\"cycle condition\", \"stability condition\"), \n       col = c(1, 2), lwd = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Create function for cycle condition using beta as an argument\ndef cyc(beta):\n    return 2 * np.sqrt(beta) - beta\n\n# Define the range for beta \nbeta_values = np.linspace(0, 4.5, 10000)\n\n# Compute the corresponding c1 values using the cyc function\nc1_values = cyc(beta_values)\n\n# Plot the cycle condition in (beta, c1)-space\nplt.plot(beta_values, c1_values, color='black', linewidth=1.5, label='cycle condition')\n\n# Plot the stability condition as a vertical line at beta = 1\nplt.axvline(x=1, color='red', linewidth=2, label='stability condition')\n\n# Set labels and title\nplt.xlabel(r'$\\beta$', fontsize=12)\nplt.ylabel(r'$c_1$', fontsize=12)\nplt.title('')\n\n# Set y-axis limit \nplt.ylim(0, 1.5)\n\n# Add legend\nplt.legend(loc='upper right')\n\n# Show the plot\nplt.show()\n\n\n\n\nThe Hicks model requires combinations of \\(c_1\\) and \\(\\beta\\) below the cycle condition and to the right of the stability condition to yield cycles that would be explosive without the floor.\nWe can also compute the eigenvalues and check the general stability conditions numerically.\n\n### Stability analysis\n## Baseline\n\n# Construct Jacobian matrix \nJ_base=matrix(c(c1, 1,\n           beta[1,1]*(c1-1), beta[1,1]),\n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_base=eigen(J_base)\n(evals_base = ev_base$values)\n\n[1] 1+0.5i 1-0.5i\n\n# Obtain determinant and trace\n(det=det(J_base))      # determinant\n\n[1] 1.25\n\ntr=sum(diag(J_base)) # trace\n\n# Calculate modulus\n(mod_base=Mod(evals_base[1]))\n\n[1] 1.118034\n\n#Check general stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] FALSE\n\n# Check analytical stability condition\nbeta[1,1] &lt; 1\n\n[1] FALSE\n\n## Compare with scenario 4\nJ_scen4=matrix(c(c1, 1,\n           beta[4,s]*(c1-1), beta[4,s]),\n          2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_scen4=eigen(J_scen4)\n(evals_scen4 = ev_scen4$values)\n\n[1] 0.775+0.4465143i 0.775-0.4465143i\n\n# Obtain determinant and trace\n(det=det(J_scen4))      # determinant\n\n[1] 0.8\n\ntr=sum(diag(J_scen4)) # trace\n\n# Calculate modulus\n(mod_scen4=Mod(evals_scen4[1]))\n\n[1] 0.8944272\n\n#Check general stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] TRUE\n\n# Check analytical stability condition\nbeta[4,s] &lt; 1\n\n[1] TRUE\n\n\nFor the baseline, the modulus of the complex eigenvalue is indeed larger than unity and the system thus unstable. This is due to the accelerator coefficient \\(\\beta\\) being larger than unity. By contrast, in scenario 4, we have \\(\\beta &lt; 1\\) and the system is thus stable.\n\n### Check cycle condition and compute cycle length (baseline)\n\n# Check analytical cycle condition\n(c1+beta[1,1])^2 - 4*beta[1,1] &lt; 0\n\n[1] TRUE\n\n# Save real and imaginary part of complex eigenvalue\nre=Re(evals_base[1])\nim=Im(evals_base[1])\n\n# Calculate cycle length\nL=(2*pi)/(acos(re/mod_base))\nL\n\n[1] 13.55164\n\n\nThe analytical cycle condition confirms that the eigenvalues of the system will be complex and thus generate cycles. The implied cycle length is around 13.5 periods.\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Stability Analysis - Baseline\n# Construct the Jacobian matrix for the baseline scenario\nJ_base = np.array([[c1, 1],\n                   [beta[0, 0] * (c1 - 1), beta[0, 0]]])\n\n# Obtain eigenvalues\nevals_base, _ = np.linalg.eig(J_base)\nprint(\"Eigenvalues (Baseline):\", evals_base)\n\n# Obtain determinant and trace\ndet_base = np.linalg.det(J_base)  # determinant\ntr_base = np.trace(J_base)  # trace\n\n# Calculate modulus of the first eigenvalue\nmod_base = np.abs(evals_base[0])\nprint(\"Modulus (Baseline):\", mod_base)\n\n# Check general stability conditions\nprint(\"Stability conditions (Baseline):\")\nprint(1 + tr_base + det_base &gt; 0)\nprint(1 - tr_base + det_base &gt; 0)\nprint(1 - det_base &gt; 0)\n\n# Check analytical stability condition\nprint(\"Analytical stability condition (Baseline):\", beta[0, 0] &lt; 1)\n\n\n### Compare with Scenario 4\n# Construct the Jacobian matrix for scenario 4\nJ_scen4 = np.array([[c1, 1],\n                    [beta[3, s] * (c1 - 1), beta[3, s]]])\n\n# Obtain eigenvalues\nevals_scen4, _ = np.linalg.eig(J_scen4)\n\n# Print eigenvalues\nprint(\"Eigenvalues (Scenario 4):\", evals_scen4)\n\n# Obtain determinant and trace\ndet_scen4 = np.linalg.det(J_scen4)  # determinant\ntr_scen4 = np.trace(J_scen4)  # trace\n\n# Calculate modulus of the first eigenvalue\nmod_scen4 = np.abs(evals_scen4[0])\nprint(\"Modulus (Scenario 4):\", mod_scen4)\n\n# Check general stability conditions\nprint(\"Stability conditions (Scenario 4):\")\nprint(1 + tr_scen4 + det_scen4 &gt; 0)\nprint(1 - tr_scen4 + det_scen4 &gt; 0)\nprint(1 - det_scen4 &gt; 0)\n\n# Check analytical stability condition\nprint(\"Analytical stability condition (Scenario 4):\", beta[3, s] &lt; 1)\n\n### Check cycle condition (baseline)\ncycle_condition = (c1 + beta[0, 0])**2 - 4 * beta[0, 0] &lt; 0\nprint(\"Cycle condition (Baseline):\", cycle_condition)\n\n# Save real and imaginary parts of the complex eigenvalue\nre = np.real(evals_base[0])\nim = np.imag(evals_base[0])\n\n# Calculate cycle length (L)\nL = (2 * np.pi) / np.arccos(re / mod_base)\nprint(\"Cycle length (Baseline):\", L)",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#references",
    "href": "a_Hicks_model.html#references",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "References",
    "text": "References\n\n\n\n\nGabisch, Günter, and Hans-Walter Lorenz. 1989. Business Cycle Theory. A Survey of Methods and Concepts, 2nd Edition. Springer-Verlag.\n\n\nHicks, John R. 1950. A Contribution to the Theory of the Trade Cycle. Clarendon Press.\n\n\nHommes, Cars H. 1995. “A reconsideration of Hicks’ non-linear trade cycle model.” Structural Change and Economic Dynamics 6 (4): 435–95. https://doi.org/10.1016/0954-349X(95)00032-I.\n\n\nPuu, Tönu, Laura Gardini, and Irina Sushko. 2005. “A Hicksian Multiplier-Accelerator Model with Floor Determined by Capital Stock.” Journal of Economic Behavior & Organization 56 (3): 331–48. https://doi.org/10.1016/j.jebo.2003.10.008.\n\n\nSamuelson, Paul A. 1939. “Interactions between the Multiplier Analysis and the Principle of Acceleration.” The Review of Economics and Statistics 21 (2): 75–78. https://doi.org/10.2307/1927758.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Hicks_model.html#footnotes",
    "href": "a_Hicks_model.html#footnotes",
    "title": "17  A Hicksian Business Cycle Model with Floors and Ceilings",
    "section": "",
    "text": "More precisely, Samuelson (1939)’s model generates shock-independent cycles only for a very specific parameter combination, whereas Hicks (1950)’s model generates endogenous cycles for a much broader set of parameters.↩︎\nFollowing Hommes (1995), we consider a stationary version of the model that abstracts from the growth path assumed in Hicks (1950).↩︎\n This differs from Samuelson (1939), who assumed that investment reacts to changes in consumption, see Chapter 2.↩︎\nTo create the function for the cycle condition, we set \\(\\left( \\frac{c_1+\\beta}{2} \\right)^2 = \\beta\\) and solve for \\(c_1\\), where we only consider positive values for \\(c_1\\) and \\(\\beta\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Hicksian Business Cycle Model with Floors and Ceilings</span>"
    ]
  },
  {
    "objectID": "a_Kaldor_model.html",
    "href": "a_Kaldor_model.html",
    "title": "18  A Kaldorian Endogenous Business Cycle Model",
    "section": "",
    "text": "Overview\nThis model captures some key features of Nicholas Kaldor (1940)’s nonlinear model of endogenous business cycle fluctuations. Unlike Samuelson (1939)’s linear multiplier-accelerator model (see Chapter 2 and Chapter 9), which usually requires repeated external shocks to produce sustained cycles, Kaldor (1940) outlined a model that would produces endogenous, i.e. shock-independent, fluctuations.1 Kaldor (1940) assumed that investment and saving were very sensitive to income for normal levels of income, but relatively insensitive for extreme values of income. Graphically, these assumptions give rise to sigmoid-shaped investment and saving functions. As a result, the goods market equilibrium becomes locally unstable due to strong positive feedback effects, but then becomes stable once the economy has sufficiently moved away from equilibrium during booms or busts. Similar to Hicks (1950) (see Chapter 17), Kaldor (1940) also assumed a locally unstable goods market, but unlike Hicks who postulated discrete bounds that would prevent fluctuations from exploding, Kaldor (1940) considered smooth bounds that stemmed from the investment and saving behaviour of firms and households. For instance, at high levels of output, investment may become insensitive to output due to rising costs of construction or surging financing cost. Similarly, for low levels of output profit opportunities may be missing, thereby rending investment insensitive to changes in output. It is then the interaction between output and the capital stock that turns these bounded output dynamics into a cycle: Kaldor (1940) assumed that the capital stock exerts a negative effect on investment as an increasing capital stock lowers the marginal efficiency of capital, whereas output pushes up the dynamics of the capital stock due to the accelerator effect.\nKaldor (1940)’s initial paper mostly relied on graphical analysis. A continuous-time version formalisation of his graphical was subsequently presented in Chang and Smyth (1971). Textbook treatments can be found in Gabisch and Lorenz (1989), chapter 4. We present a discrete time version of the Kaldor model due to Bischi et al. (2001).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>A Kaldorian Endogenous Business Cycle Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor_model.html#the-model",
    "href": "a_Kaldor_model.html#the-model",
    "title": "18  A Kaldorian Endogenous Business Cycle Model",
    "section": "The Model",
    "text": "The Model\n\\[\n  Y_{t}=Y_{t-1} + \\alpha(I_{t} - S_{t}),  \\quad \\alpha &gt; 0\n\\tag{18.1}\\]\n\\[\nK_{t} = (1-\\delta)K_{t-1} + I_{t-1},  \\quad \\delta \\in (0,1)\n\\tag{18.2}\\]\n\\[\nS_{t} = \\sigma Y_t,  \\quad \\sigma \\in (0,1)\n\\tag{18.3}\\]\n\\[\nI_{t} = \\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_t \\right) + \\arctan(Y_{t}- Y^E),  \\quad \\gamma, Y^E &gt; 0\n\\tag{18.4}\\]\nwhere \\(Y_t\\), \\(K_t\\), \\(S_t\\), and \\(I_t\\) represent aggregate output, the capital stock, saving, and investment, respectively.\nEquation 18.1 specifies that output reacts slugglishly to excess demand \\((I_t &gt; S_t)\\) and excess supply \\((I_t &lt; S_t)\\), with the speed of adjustment given by \\(\\alpha\\). A high value of \\(\\alpha\\) means that firms respond strongly to disequilibria in the goods market. Equation 18.2 is the law of motion of the capital stock, with \\(\\delta\\) representing the rate of depreciation. Equation 18.3 is th saving function. While Kaldor (1940) assumed a non-linear (sigmoid-shaped) Keynesian saving function, Bischi et al. (2001) (for simplicity) use a linear saving function with a constant marginal propensity to save out of income \\((\\sigma)\\). The key nonlinearity in this version of the Kaldor model lies in the investment function Equation 18.4. The first term in the investment function, \\(\\sigma Y^E\\), is a normal level of saving that prevails for a normal or expected level of output, \\(Y^E\\). The second term, \\(\\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_t \\right)\\), incorporates a negative feedback effect of the level of the capital stock on investment, where \\(\\frac{\\sigma Y^E}{\\delta}\\) is the normal level of the capital stock. The third term, \\(\\arctan(Y_{t}- Y^E)\\), introduces the sigmoid relationship between investment and output, modelled by means of the arctangent function. Investment is increasing in aggregate output; and this effect is stronger for smaller deviations of actual investment from normal output. Figure 18.1 plots an example of this sigmoid-shaped investment function for a normal level of output of \\(Y^E=10\\).\n\n#### Plot investment function \n# Set  parameter values\nalpha=1.2 # adjustment speed of output\ndelta=0.2 # depreciation rate\nsigma=0.4 # propensity to save\nY_E=10    # normal level of output\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\nK=sigma*Y_E/delta # set capital stock to normal level\n\n# Create investment function using Y as argument\ninv= function(Y){\n  sigma*Y_E + gamma*(sigma*Y_E/delta - K) + atan(Y - Y_E)\n}\n\n# Plot the function in (I,Y) space\ncurve(inv, from = 5, to = 15, col = 1, xlab=\"Y\", ylab=\"I\" , main=\"\",\n      lwd=1.5, n=10000, ylim=range(2,6))\nabline(v=Y_E, col=2)\nlegend(\"bottomright\", legend = c(\"I\", expression(Y^E)), \n       col = c(1, 2), lwd = 2, bty = \"n\")\n\n\n\n\n\n\nFigure 18.1: Kaldor’s sigmoid investment function\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#### Plot investment function \n\n# Import necessary libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set parameter values\nalpha = 1.2  # adjustment speed of output\ndelta = 0.2  # depreciation rate\nsigma = 0.4  # propensity to save\nY_E = 10     # normal level of output\ngamma = 0.6  # sensitivity of investment to deviations of actual from normal cap stock\nK = sigma * Y_E / delta  # set capital stock to normal level\n\n# Define the investment function using Y as argument\ndef inv(Y):\n    return sigma * Y_E + gamma * (sigma * Y_E / delta - K) + np.arctan(Y - Y_E)\n\n# Plot the function in (I,Y) space\nY_values = np.linspace(5, 15, 10000)\nI_values = inv(Y_values)\n\nplt.figure(figsize=(8,6))\nplt.plot(Y_values, I_values, color='black', linewidth=1.5, label='I')\nplt.axvline(x=Y_E, color='red', linestyle='--', label='$Y^E$')\n\n# Customize the plot\nplt.xlabel(\"Y\")\nplt.ylabel(\"I\")\nplt.title(\"Investment Function\")\nplt.ylim(2, 6)\nplt.legend(loc=\"lower right\", frameon=False)\nplt.grid(True, linestyle='--', alpha=0.6)\n\nplt.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>A Kaldorian Endogenous Business Cycle Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor_model.html#simulation",
    "href": "a_Kaldor_model.html#simulation",
    "title": "18  A Kaldorian Endogenous Business Cycle Model",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 1 reports the parameterisation used in the simulation. We will analyse below how the model’s dynamic properties change as \\(\\alpha\\) and \\(\\sigma\\) vary.\nTable 1: Parameterisation\n\n\n\\(\\alpha\\)\n\\(\\delta\\)\n\\(\\sigma\\)\n\\(Y^E\\)\n\\(\\gamma\\)\n\n\n1.2\n0.2\n0.4\n10\n0.6\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=200\n\n# Set number of scenarios \nScen=1\n\n# Create (Scen x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=Scen,ncol=Q) # Income/output\nK=matrix(data=1,nrow=Scen,ncol=Q) # capital stock\nS=matrix(data=1,nrow=Scen,ncol=Q) # saving\nI=matrix(data=1,nrow=Scen,ncol=Q) # Investment\n\n# Set fixed parameter values\nalpha=1.2 # adjustment speed of output\ndelta=0.2 # depreciation rate\nsigma=0.4 # propensity to save\nY_E=10    # normal level of output\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\n\n# Simulate the model by looping over Q time periods for Scen different scenarios\nfor (i in 1:Scen){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:500){ # run the model 500-times in each period\n      \n    #Model equations\n    \n    #(1) Output\n    Y[i,t] = Y[i,t-1] + alpha*(I[i,t-1] - S[i,t-1])\n    \n    #(2) Capital stock\n    K[i,t] = (1-delta)*K[i,t-1] + I[i,t-1]\n    \n    #(3) Saving\n    S[i,t] = sigma*Y[i,t] \n    \n    #(4) Investment\n    I[i,t] = sigma*Y_E + gamma*(sigma*Y_E/delta - K[i,t]) + atan(Y[i,t] - Y_E)\n    \n    } # close iterations loop\n  }   # close time loop\n}     # close scenario loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Import necessary libraries\nimport numpy as np\n\n# Set number of periods\nQ = 200\n\n# Set number of scenarios\nScen = 1\n\n# Create (Scen x Q)-matrices to contain the simulated data\nY = np.ones((Scen, Q))  # Income/output\nK = np.ones((Scen, Q))  # Capital stock\nS = np.ones((Scen, Q))  # Saving\nI = np.ones((Scen, Q))  # Investment\n\n# Set fixed parameter values\nalpha = 1.2  # Adjustment speed of output\ndelta = 0.2  # Depreciation rate\nsigma = 0.4  # Propensity to save\nY_E = 10     # Normal level of output\ngamma = 0.6  # Sensitivity of investment to deviations of actual from normal capital stock\n\n# Simulate the model by looping over Q time periods for Scen different scenarios\nfor i in range(Scen):\n    for t in range(1, Q):\n        for iterations in range(500):  # Run the model 500 times in each period\n            \n            # Model equations\n            \n            # (1) Output\n            Y[i, t] = Y[i, t-1] + alpha * (I[i, t-1] - S[i, t-1])\n            \n            # (2) Capital stock\n            K[i, t] = (1 - delta) * K[i, t-1] + I[i, t-1]\n            \n            # (3) Saving\n            S[i, t] = sigma * Y[i, t]\n            \n            # (4) Investment\n            I[i, t] = sigma * Y_E + gamma * (sigma * Y_E / delta - K[i, t]) + np.arctan(Y[i, t] - Y_E)\n\n\n\n\nPlots\nFigure 18.2 displays the dynamics of aggregate output. The model generates endogenous cycles in output that are permanent, i.e. they don’t require any external shocks, and they are (roughly) periodic with a cycle length from peak (trough) to peak (trough) of around 17 periods. What generates the turning points? Suppose income is close to its normal level of \\(Y^E = 10\\), but on an increasing trajectory. The accelerator effect on investment will amplify this process as firms will increase their investment, which raises aggregate demand and increases income further. As aggregate output increases, this positive feedback effect gradually becomes weaker, possibly because firms face tighter supply constraints. The rise in the capital stock exerts a negative feedback effect on investment and will eventually dominate the accelerator effect. Firms then start reducing investment and the boom turns into a bust. The accelerator effect again amplifies this downward trajectory until the capital stock has sufficiently fallen to make investment attractive again. This allows the cycle to repeat itself.\n\n# Set start and end periods for plots\nTmax=100\nTmin =10\n\n# Plot aggregate output and capital stock\nplot(Y[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Y\") \ntitle(main=\"Aggregate output and capital stock\", cex=0.8)\npar(mar = c(5, 4, 4, 4) + 0.3)\npar(new = TRUE)\nplot(K[1, Tmin:Tmax], type=\"l\", col=1, lwd=2, lty=2, font.main=1, cex.main=1,ylab = '', axes=FALSE,\n     xlab = '', ylim = range(K[1, Tmin:Tmax]), cex=0.8)\naxis(side = 4, at=pretty(K[1, Tmin:Tmax]))  \nmtext(\"K\", side = 4, line = 3)\nlegend(\"topright\", legend=c(\"Y\", \"K\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 18.2: Output and capital stock\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n# Set start and end periods for plots\nTmax = 100\nTmin = 10\n\n# Plot aggregate output and capital stock\nfig, ax1 = plt.subplots(figsize=(8, 6))\n\n# Plot Y (aggregate output)\nax1.plot(range(Tmin, Tmax), Y[0, Tmin:Tmax], color='black', linewidth=2, linestyle='-', label='Y')\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(\"Y\", color='black')\nax1.tick_params(axis='y', labelcolor='black')\nax1.set_title(\"Aggregate Output and Capital Stock\", fontsize=10)\n\n# Create a twin axis for the capital stock\nax2 = ax1.twinx()\n\n# Plot K (capital stock)\nax2.plot(range(Tmin, Tmax), K[0, Tmin:Tmax], color='black', linewidth=2, linestyle='--', label='K')\nax2.set_ylabel(\"K\", color='black')\nax2.tick_params(axis='y', labelcolor='black')\n\n\n\n\nFigure 18.3 displays the endogenous fluctuations in saving and investment. The horizontal lines represent the average level of saving and investment computed from the simulated data.2 It can be seen that these are virtually identical, reflecting the fact that that the model generates cycles around the goods market equilibrium but never reaches it.\n\n## Calculate average saving and investment ignoring the first 10 periods\nS_avr=rowMeans(S[,10:Q, drop=FALSE])\nI_avr=rowMeans(I[,10:Q, drop=FALSE])\n\n#Plot saving and investment along with their long-run average values\nplot(S[1, Tmin:(Tmax)],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylab=\"S, I\", \n     ylim=range(I[1, Tmin:Tmax],S[1, Tmin:(Tmax)]))\ntitle(main=\"Saving and investment\", xlab = 'Time',cex=0.8,line=2)\nlines(I[1, Tmin:Tmax],lty=2)\nabline(h=S_avr, col=2)\nabline(h=I_avr, col=3)\nlegend(\"topleft\", legend=c(\"S\", \"I\"),\n       lty=1:2, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 18.3: Saving and investment\n\n\n\n\nCreating a bifurcation diagram\nNext, we explore numerically under which conditions the model generates endogenous cycles. To do so, we need to introduce some terminology. First, a limit cycle is defined as a closed orbit of the state variables of a dynamic system around a locally unstable equilibrium (see Gandolfo (2009), chap. 23). In the neighbourhood of the equilibrium, the system is unstable and gets pushed away from it. However, rather than exhibiting explosive behaviour, the system eventually reaches a periodic cycle as it is bounded by nonlinearities. The fluctuations in Figure 18.2 indeed constitute a limit cycle. Second, a bifurcation is defined as a qualitative change of the behaviour of a dynamic system that occurs as a parameter of the system crosses a critical value (see Gandolfo (2009), chap. 24). Third, a Hopf bifurcation is a bifurcation that gives rise to a limit cycle.3\nWe can analyse the emergence of Hopf bifurcations in this model by means of so-called bifurcation diagrams that plot the dynamics of a representative endogenous variable variable from the model against different values of a parameter of interest. This is accomplished by fixing a parameterisation, simulating the model for a specific value of the parameter of interest, saving the last \\(T_0\\) values of the chosen endogenous variable, and repeating the process for a marginally different value of the parameter of interest. The \\(T_0\\) data points from each run are then placed on the bifurcation diagram.\nThe following code first creates a function called kaldor that simulates the Kaldor model,4 taking values of \\(\\alpha\\) and \\(\\sigma\\) as arguments, and returns the last \\(T_0=50\\) values of output.\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Define a function called \"kaldor\" that simulates a reduced-form version of the model\n# and returns the last 50 values of Y; use alpha and sigma as arguments that \n# need to be supplied when the function is called\nkaldor &lt;- function(alpha, sigma) {\n  \n  # Set how many last values of output you want to save\n  T_0 = 50\n  \n  # Set number of periods\n  Q = 200\n  \n  # Create matrices for simulated data\n  Y = matrix(data = 1, nrow = 1, ncol = Q)  # Income/output\n  K = matrix(data = 1, nrow = 1, ncol = Q)  # Capital stock\n  \n  # Set fixed parameter values\n  gamma = 0.6  # Sensitivity of investment to deviations of actual from normal cap stock\n  delta = 0.2  # Depreciation rate\n  Y_E = 10     # Normal level of output\n\n  # Simulate the model by looping over time periods\n    for (t in 2:Q) {\n\n        ## Model equations\n        # Output\n        Y[1, t] = Y[1, t-1] + \n          alpha * (sigma * Y_E + gamma * (sigma * Y_E / delta - K[1, t-1]) + \n                   atan(Y[1, t-1] - Y_E) - sigma * Y[1, t-1])\n        \n        #  Capital stock\n        K[1, t] = (1 - delta) * K[1, t-1] + \n          sigma * Y_E + gamma * (sigma * Y_E / delta - K[1, t-1]) + \n          atan(Y[1, t-1] - Y_E)\n        \n    } # Close time loop\n\n  return(Y[1, (Q-T_0):Q])  # Return last 50 periods of output\n}\n\nNext, we prepare an initially empty bifurcation diagram and then loop over the kaldor function, increasing the parameter \\(\\alpha\\) from 0.5 to 2 in successive steps of 0.01 (while keeping \\(\\sigma\\) fixed at 0.4), and place the resulting data points on the bifurcation diagram. From Figure 18.4, it can be seen that there indeed appears to be a critical value \\(\\alpha_0 \\approx 1.15\\) below which the model does not generate a limit cycle because the equilibrium is stable. By contrast, for values of \\(\\alpha\\) above that critical value, the model generates a limit cycle whose amplitude appears to be increasing in \\(\\alpha\\).\n\n# Prepare the bifurcation diagram in alpha\nplot(NULL, xlim = c(0.5, 2.0), ylim = c(7.5, 12.5), \n     xlab = expression(alpha), ylab = expression(Y[t]), \n     pch = \".\", cex = 0.6, col = \"blue\", main = \n       expression(\"Bifurcation diagram in \" * alpha))\n\n# Run kaldor function for different values of alpha (keeping sigma at 0.4) \n# and place data points on bifurcation diagram \nalpha = 0.5  # initialise alpha\nwhile (alpha &lt;= 2) { # run kaldor model until alpha assumes value of 2\n  output = kaldor(alpha=alpha, sigma=0.4) # obtain values of Y for given value of alpha\n  points(rep(alpha, length(output)), output, pch = \".\", col = \"blue\", cex = 2)  # add data points to diagram\n  alpha = alpha + 0.01  # increase alpha stepwise\n}\n\n\n\n\n\n\nFigure 18.4: Bifurcation diagram for different sensitivities of output to saving-investment gap\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Generate kaldor function\n\n# Define a function called \"kaldor\" that simulates a reduced-form version of the model\n# and returns the last 50 values of Y\n\ndef kaldor(alpha, sigma):\n    # Set how many last values of output you want to save\n    T_0 = 50\n    \n    # Set number of periods\n    Q = 200\n    \n    # Create matrices for simulated data\n    Y = np.ones((1, Q))  # Income/output\n    K = np.ones((1, Q))  # Capital stock\n    \n    # Set fixed parameter values\n    gamma = 0.6  # Sensitivity of investment to deviations of actual from normal capital stock\n    delta = 0.2  # Depreciation rate\n    Y_E = 10     # Normal level of output\n    \n    # Simulate the model by looping over time periods\n    for t in range(1, Q):\n        \n        # Model equations\n        \n        # (1) Output\n        Y[0, t] = Y[0, t-1] + alpha * (\n            sigma * Y_E + gamma * (sigma * Y_E / delta - K[0, t-1]) + \n            np.arctan(Y[0, t-1] - Y_E) - sigma * Y[0, t-1])\n        \n        # (2) Capital stock\n        K[0, t] = (1 - delta) * K[0, t-1] + (\n            sigma * Y_E + gamma * (sigma * Y_E / delta - K[0, t-1]) + \n            np.arctan(Y[0, t-1] - Y_E))\n    \n    # Return last 50 periods of output\n    return Y[0, (Q-T_0):Q]\n\n\n#### Generate bifurcation diagram\n\n# Prepare the bifurcation diagram in alpha\nplt.figure(figsize=(10, 6))\nplt.title(r'Bifurcation Diagram in $\\alpha$', fontsize=14)\nplt.xlabel(r'$\\alpha$', fontsize=12)\nplt.ylabel(r'$Y_t$', fontsize=12)\nplt.xlim(0.5, 2.0)\nplt.ylim(7.5, 12.5)\n\n# Run kaldor function for different values of alpha (keeping sigma at 0.4)\n# and place data points on bifurcation diagram\n\nalpha = 0.5  # Initialize alpha\nwhile alpha &lt;= 2.0:\n    # Obtain values of Y for the given value of alpha\n    output = kaldor(alpha=alpha, sigma=0.4)\n    \n    # Add data points to the diagram\n    plt.scatter([alpha] * len(output), output, color='blue', s=4, marker='.')\n    \n    # Increase alpha stepwise\n    alpha += 0.01\n\n# Show the bifurcation diagram\nplt.show()\n\n\n\n\nFigure 18.5 does the same for the parameter \\(\\sigma\\), starting from \\(\\sigma=0.1\\) and raising it to 0.5 in steps of 0.001 (while keeping a fixed \\(\\alpha\\) of 1.2). The parameter \\(\\sigma\\) appears to exhibit a critical value \\(\\sigma_0 \\approx 0.25\\) above which a limit cycle occurs.\n\n# Prepare the bifurcation diagram in sigma\nplot(NULL, xlim = c(0.1, 0.5), ylim = c(7, 11.5), \n     xlab = expression(sigma), ylab = expression(Y[t]), \n     pch = \".\", cex = 0.6, col = \"blue\",\n     main = expression(\"Bifurcation diagram in \" * sigma))\n\n# Run kaldor function for different values of sigma (keeping alpha at 1.2)\n# and place data points on bifurcation diagram \nsigma = 0.1 # initialise alpha\nwhile (sigma &lt;= 0.5) { # run kaldor model until sigma assumes value of 0.5\n  output = kaldor(alpha=1.2, sigma=sigma) # obtain the values of Y for given value of sigma\n  points(rep(sigma, length(output)), output, pch = \".\", col = \"blue\", cex = 1)  # add data points to diagram\n  sigma = sigma + 0.001  # increase sigma stepwise\n}\n\n\n\n\n\n\nFigure 18.5: Bifurcation diagram for different saving propensities",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>A Kaldorian Endogenous Business Cycle Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor_model.html#directed-graph",
    "href": "a_Kaldor_model.html#directed-graph",
    "title": "18  A Kaldorian Endogenous Business Cycle Model",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 5 variables: \n  # endogenous: (1) Y, (2) K, (3) S, (4) I\n  # exogenous: (5) YE\n\n              #Y K S I YE\nM_mat=matrix(c(0,0,1, 1, 1, # Y\n               0,0,0, 1, 0, # K\n               1,0,0, 0, 0, # S\n               1,1,0, 0, 1, # I\n               0,0,0, 0, 0),# YE\n               5, 5, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"Y\", \"K\", \"S\", \"I\", expression(Y^E))\n\n# Plot directed graph\nplot(dg, main=\"Directed graph of Kaldor model\", vertex.size=40, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1.1, edge.size=1.2,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1.2, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\nFigure 18.6: Directed graph of Kaldor model\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n##### Generate directed graph\n# Import necessary libraries\nimport networkx as nx\n\n# Construct auxiliary Jacobian matrix for 5 variables:\n# Endogenous: (1) Y, (2) K, (3) S, (4) I\n# Exogenous: (5) YE\n\nM_mat = np.array([[0, 0, 1, 1, 1],  # Y\n                  [0, 0, 0, 1, 0],  # K\n                  [1, 0, 0, 0, 0],  # S\n                  [1, 1, 0, 0, 1],  # I\n                  [0, 0, 0, 0, 0]]) # YE\n\n# Create adjacency matrix from transpose of auxiliary Jacobian\nA_mat = M_mat.T\n\n# Create directed graph from adjacency matrix\nG = nx.DiGraph(A_mat)\n\n# Define node labels\nnodelabs = {0: \"Y\", 1: \"K\", 2: \"S\", 3: \"I\", 4: r\"$Y^E$\"}\n\n# Plot the graph using the specified approach\npos = nx.spring_layout(G, k=0.5)\nplt.figure(figsize=(8, 4))\nnx.draw_networkx(G, pos, node_size=200, node_color=\"lightblue\", \n                 edge_color=\"black\", width=1.2, arrowsize=10, \n                 arrowstyle='-&gt;', font_size=8, font_color=\"black\",\n                 with_labels=True, labels=nodelabs)\n\nplt.title(\"Directed Graph of Kaldor Model\", fontsize=14)\nplt.show()\n\n\n\n\nFigure 18.6 illustrates the endogenous cycle generated by the interaction between income \\(Y\\), investment \\(I\\), saving \\(S\\), and the capital stock. An important exogenous variable depicted here is the normal income level \\(Y^E\\), which sets the equilibrium around which output fluctuates.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>A Kaldorian Endogenous Business Cycle Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor_model.html#analytical-discussion",
    "href": "a_Kaldor_model.html#analytical-discussion",
    "title": "18  A Kaldorian Endogenous Business Cycle Model",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nTo analyse the dynamic properties of this discrete-time version of the Kaldor (1940) model, we first reduce it to a two-dimensional system in \\(Y_t\\) and \\(K_t\\). Substitution of Equation 18.3 and Equation 18.3 into Equation 18.1 and Equation 18.2 yields:\n\\[\nY_{t}=Y_{t-1} + \\alpha \\left[\\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_{t-1} \\right) + \\arctan(Y_{t-1}- Y^E)  -  \\sigma Y_{t-1} \\right]\n\\tag{18.5}\\]\n\\[\nK_{t} = (1-\\delta)K_{t-1} + \\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K_t \\right) + \\arctan(Y_{t-1}- Y^E).\n\\tag{18.6}\\]\nUsing the fact that \\(\\frac{\\partial \\arctan(a+bx)}{\\partial x}=\\frac{1}{1+(a+bx)^2}\\), we can write the system’s Jacobian matrix as:\n\\[\nJ=\\begin{bmatrix} 1 + \\frac{\\alpha}{1+(Y-Y^E)^2} - \\alpha\\sigma & -\\alpha \\gamma \\\\ \\frac{1}{1+(Y-Y^E)^2} & 1-\\delta - \\gamma\\  \\end{bmatrix}.\n\\]\nNext, we determine the steady states of the model by setting \\(Y_t = Y_{t-1}\\) and \\(K_t = K_{t-1}\\), which yields:\n\\[\n0=\\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K \\right) + \\arctan(Y- Y^E)  -  \\sigma Y\n\\tag{18.7}\\]\n\\[\n0 = -\\delta K + \\sigma Y^E + \\gamma \\left(\\frac{\\sigma Y^E}{\\delta} - K \\right) + \\arctan(Y- Y^E).\n\\tag{18.8}\\]\nFrom this, we can readily obtain:\n\\[\nK=\\frac{\\sigma}{\\delta}Y,\n\\] and using this equation to eliminate \\(K\\) in Equation 18.8, we get:\n\\[\n\\sigma \\left(1+\\frac{\\gamma}{\\delta}\\right)(Y- Y^E)=\\arctan(Y-Y^E).\n\\tag{18.9}\\]\nLet \\(\\sigma \\left(1+\\frac{\\gamma}{\\delta}\\right)=\\theta\\). Figure 18.7 plots the left-hand side and right-hand side of Equation 18.9, for two different parameterisations of \\(\\theta\\). It can be seen that for \\(\\theta_1 &gt;1\\), there is a unique equilibrium at \\(Y^*=Y^E\\), which implies \\(K^*=\\frac{\\sigma}{\\delta}Y^E\\). However, for \\(\\theta_2 &lt; 1\\), two further equilibria emerge, which are located symmetrically around the \\(Y^*=Y^E\\) equilibrium.\n\n#### Plot equilibria \n# Set  parameter values\nparm_1=1.2\nparm_2=0.8\nY_E=10\n\n# Create functions using Y as argument\nf1a= function(Y){\n  parm_1*(Y - Y_E)\n}\n\nf1b= function(Y){\n  parm_2*(Y - Y_E)\n}\n\nf2= function(Y){\n atan(Y - Y_E)\n}\n\n# Plot the functions\ncurve(f1a, from = 5, to = 15, col = 1, xlab=\"Y\", ylab=\"\" , main=\"\",\n      lwd=1.5, n=10000, ylim=range(-2,2))\ncurve(f1b, from = 5, to = 15, col = 2, add=TRUE,\n      lwd=1.5,)\ncurve(f2, from = 5, to = 15, col = 3, add=TRUE,\n      lwd=1.5)\nlegend(\"bottomright\", legend = c(expression(theta[1](Y-Y^E)), \n      expression(theta[2](Y-Y^E)), expression(arctan(Y-Y^E))), \n       col = 1:3, lwd = 2, bty = \"n\")\n\n\n\n\n\n\nFigure 18.7: Equilibria\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n#### Plot equilibria\n\n# Set parameter values\nparm_1 = 1.2\nparm_2 = 0.8\nY_E = 10\n\n# Define functions\ndef f1a(Y):\n    return parm_1 * (Y - Y_E)\n\ndef f1b(Y):\n    return parm_2 * (Y - Y_E)\n\ndef f2(Y):\n    return np.arctan(Y - Y_E)\n\n# Create Y values for plotting\nY_vals1 = np.linspace(5, 15, 1000)\nY_vals2 = np.linspace(5, 15, 1000)\n\n# Plot the functions\nplt.figure(figsize=(8, 6))\nplt.plot(Y_vals1, f1a(Y_vals1), color='black', linewidth=1.5, label=r'$\\theta_1(Y - Y^E)$')\nplt.plot(Y_vals1, f1b(Y_vals1), color='red', linewidth=1.5, label=r'$\\theta_2(Y - Y^E)$')\nplt.plot(Y_vals2, f2(Y_vals2), color='green', linewidth=1.5, label=r'$\\arctan(Y - Y^E)$')\n\n# Customize the plot\nplt.xlabel(\"Y\", fontsize=12)\nplt.ylabel(\"\", fontsize=12)\nplt.ylim(-2, 2)\nplt.legend(loc=\"lower right\", frameon=False)\n\n# Show the plot\nplt.show()\n\n\n\n\nLet us focus on the \\(\\theta &gt;1\\) case yielding the unique \\(Y^*= Y^E\\) equilibrium, which is the one corresponding to the parameterisation used in the simulations above.5 The Jacobian matrix evaluated at this equilibrium is given by:\n\\[\nJ^*=\\begin{bmatrix} 1 + \\alpha(1-\\sigma) & -\\alpha \\gamma \\\\ 1 & 1-\\delta - \\gamma\\  \\end{bmatrix}.\n\\] The characteristic polynomial yielding the eigenvalues of the Jacobian is:\n\\[\\lambda^2-\\lambda[2+\\alpha(1-\\sigma)-\\delta-\\gamma]+(1-\\delta -\\gamma)(1-\\alpha\\sigma) +\\alpha(1-\\delta)=0,\\]\nwhere \\(2+\\alpha(1-\\sigma)-\\delta-\\gamma =tr(J)\\) and \\((1-\\delta -\\gamma)(1-\\alpha\\sigma) +\\alpha(1-\\delta) = det(J)\\).\nFirst, let us derive the condition under which the model produces cycles thanks to the eigenvalues being a pair of complex conjugates. The roots of the polynomial are:\n\\[\n\\lambda_{1,2} = \\frac{tr(J) \\pm \\sqrt{tr(J)^2-4det(J)}}{2},\n\\]\nso that the eigenvalues will be complex if \\(tr(J)^2-4 det(J)&lt;0\\), which can also be written as \\((J_{11}-J_{22})^2 + J_{12}J_{21}&lt;0\\), where \\(J_{ii}\\) are the elements of the Jacobian matrix.6 Thus, the condition for cycles becomes:\n\\[\n[\\alpha(1-\\sigma) + \\delta + \\gamma]^2 - 4\\alpha \\gamma &lt; 0.  \n\\] Next, the stability conditions for two-dimensional systems in discrete time are:\n\\[\n1+tr(J)+det(J)&gt;0,\n\\] \\[\n1-tr(J)+det(J)&gt;0,\n\\] \\[\n1-det(J)&gt;0,\n\\]\nwhere \\(tr(J)\\) is the trace and \\(det(J)\\) is the determinant of the Jacobian.\nLet us focus on the last condition, which gives:\n\\[\n(1-\\delta -\\gamma)(1-\\alpha \\sigma) +\\alpha(1-\\delta)&lt; 1.\n\\]\nWe now generate a plot that displays the cycle and the stability condition in the \\((\\alpha, \\sigma)\\)-space. We further add a horizontal line at \\(\\sigma \\left(1+\\frac{\\gamma}{\\delta}\\right)=\\theta=1\\), demarcating values of \\(\\sigma\\) for which there is a unique equilibrium (above the line) and for which there are three equilibria (below the line).7\n\n#### Plot cycle and stability condition \n\n# Set fixed parameter values\ndelta=0.2 # depreciation rate\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\n\n# Create function for cycle condition\ncyc= function(alpha, sigma){\n (alpha*(1-sigma) + delta + gamma)^2 - 4*alpha*gamma \n}\n\n# Create function for stability condition\nstab= function(alpha, sigma){\n (1-delta -gamma)*(1-alpha*sigma) +alpha*(1-delta) - 1\n}\n\n# Create a grid of alpha and sigma values\nalpha_vals = seq(0.5, 2, length.out = 100)\nsigma_vals = seq(0, 1, length.out = 100)\ngrid=expand.grid(alpha = alpha_vals, sigma = sigma_vals)\n\n# Evaluate the functions on the grid\ncyc_vals = matrix(cyc(grid$alpha, grid$sigma), nrow = 100)\nstab_vals = matrix(stab(grid$alpha, grid$sigma), nrow = 100)\n\n# Plot the curves\ncontour(alpha_vals, sigma_vals, cyc_vals, levels = 0, col = 1, lwd = 2, \n        xlab = expression(alpha), ylab = expression(sigma), main = \"\")\ncontour(alpha_vals, sigma_vals, stab_vals, levels = 0, col = 2, lwd = 2, add = TRUE)\nabline(h=1/(1+gamma/delta), col=3)\nlegend(\"topleft\", legend = c(\"cycle condition\",\n       \"stability condition\", \"unique equilibrium condition\"), \n       col = 1:3, lty = 1, cex=0.8, bty = \"n\")\n\n\n\n\n\n\nFigure 18.8: Cycle and stability conditions\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n\n### Plot cycle and stability condition\nfrom matplotlib.lines import Line2D\n# Set fixed parameter values\ndelta = 0.2  # Depreciation rate\ngamma = 0.6  # Sensitivity of investment to deviations from normal capital stock\n\n# Define functions for cycle and stability conditions\ndef cyc(alpha, sigma):\n    return (alpha * (1 - sigma) + delta + gamma)**2 - 4 * alpha * gamma\n\ndef stab(alpha, sigma):\n    return (1 - delta - gamma) * (1 - alpha * sigma) + alpha * (1 - delta) - 1\n\n# Create a grid of alpha and sigma values\nalpha_vals = np.linspace(0.5, 2, 100)\nsigma_vals = np.linspace(0, 1, 100)\nalpha_grid, sigma_grid = np.meshgrid(alpha_vals, sigma_vals)\n\n# Evaluate the functions on the grid\ncyc_vals = cyc(alpha_grid, sigma_grid)\nstab_vals = stab(alpha_grid, sigma_grid)\n\n# Plot the curves\nplt.figure(figsize=(8, 6))\n\n# Plot cycle condition contour\ncyc_contour = plt.contour(alpha_vals, sigma_vals, cyc_vals, levels=[0], colors='black', linewidths=2)\n\n# Plot stability condition contour\nstab_contour = plt.contour(alpha_vals, sigma_vals, stab_vals, levels=[0], colors='red', linewidths=2)\n\n# Plot unique equilibrium condition\nunique_eq_line = plt.axhline(y=1 / (1 + gamma / delta), color='green', linestyle='-', linewidth=2)\n\n# Customize the plot\nplt.xlabel(r'$\\alpha$', fontsize=12)\nplt.ylabel(r'$\\sigma$', fontsize=12)\n\n# Create custom legend symbols\nlegend_elements = [\n    Line2D([0], [0], color='black', lw=2, label=\"Cycle condition\"),\n    Line2D([0], [0], color='red', lw=2, label=\"Stability condition\"),\n    Line2D([0], [0], color='green', lw=2, label=\"Unique equilibrium condition\")\n]\n\n# Add legend with symbols\nplt.legend(handles=legend_elements, loc=\"upper left\", frameon=False, fontsize=9)\n\nplt.grid(False)\nplt.show()\n\n\n\n\nAccording to Figure 18.8, combinations of \\(\\alpha\\) and \\(\\sigma\\) above the cycle and to the right of the stability condition yield eigenvalues of the model that are a pair of complex conjugates with a modulus greater than one. The model will then generate a limit cycle. For combinations of \\(\\alpha\\) and \\(\\sigma\\) to the left of the stability and above the cycle condition, the model yields damped oscillations that will converge to a stable equilibrium. For combinations of \\(\\alpha\\) and \\(\\sigma\\) to the left of the stability and below the cycle condition, the model yields monotonic converges to a stable equilibrium.\nThese analytically derived conditions correspond to and illuminate further the numerical results in the bifurcation diagrams above. In Figure 18.4, it could be seen that for a fixed \\(\\sigma=0.4\\), limit cycles appear to occur for \\(\\alpha \\gtrapprox 1.15\\). With the analytical results plotted in Figure 18.8 we can confirm that this indeed constitutes a Hopf bifurcation, where the equilibrium loses its stability while the eigenvalues are complex. Similarly, in Figure 18.5, it could be seen that for a fixed \\(\\alpha=1.2\\), a limit cycle appears to occur for \\(\\sigma \\gtrapprox 0.25\\). Figure 18.8 suggests that for values of \\(\\sigma\\) below that critical value, the \\(Y^*=Y^E\\) equilibrium ceases to be unique, and the system is apparently attracted to one of the other two equilibria, which appear to be stable.\nFinally, we can also compute the eigenvalues and check the analytical stability and cycle conditions numerically.\n\n### Stability analysis\n\n# Set parameter values\nalpha=1.2 # adjustment speed of output\ndelta=0.2 # depreciation rate\nsigma=0.4 # propensity to save\ngamma=0.6 # sensitivity of investment to deviations of actual from normal cap stock\n\n# Construct Jacobian matrix evaluated at the Y*=Y_E steady state\nJ_base=matrix(c(1+alpha*(1-sigma), -alpha*gamma,\n                1, 1-delta-gamma),\n                 2, 2, byrow=TRUE)\n\n# Obtain eigenvalues\nev_base=eigen(J_base)\n(evals_base = ev_base$values)\n\n[1] 0.96+0.3773592i 0.96-0.3773592i\n\n# Obtain determinant and trace\ntr=sum(diag(J_base)) # trace\n(det=det(J_base))      # determinant\n\n[1] 1.064\n\n# Calculate modulus\n(mod_base=Mod(evals_base[1]))\n\n[1] 1.031504\n\n#Check general stability conditions\nprint(1+tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-tr+det&gt;0)\n\n[1] TRUE\n\nprint(1-det&gt;0)\n\n[1] FALSE\n\n# Check analytical stability condition\n((1-delta -gamma)*(1-alpha*sigma) +alpha*(1-delta)) &lt; 1\n\n[1] FALSE\n\n\nThese results confirm that the modulus of the complex eigenvalue is indeed larger than unity and the system thus unstable.\n\n### Check cycle condition and compute cycle length \n\n# Check analytical cycle condition\n((alpha*(1-sigma) + delta + gamma)^2 - 4*alpha*gamma) &lt; 0\n\n[1] TRUE\n\n# Save real and imaginary part of complex eigenvalue\nre=Re(evals_base[1])\nim=Im(evals_base[1])\n\n# Calculate cycle length\nL=(2*pi)/(acos(re/mod_base))\nL\n\n[1] 16.77624\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n###### Stability analysis\n\n# Set parameter values\nalpha = 1.2  # Adjustment speed of output\ndelta = 0.2  # Depreciation rate\nsigma = 0.4  # Propensity to save\ngamma = 0.6  # Sensitivity of investment to deviations from normal capital stock\n\n# Construct Jacobian matrix evaluated at the Y* = Y_E steady state\nJ_base = np.array([\n    [1 + alpha * (1 - sigma), -alpha * gamma],\n    [1, 1 - delta - gamma]\n])\n\n# Obtain eigenvalues\nevals_base, _ = np.linalg.eig(J_base)\n\n# Print eigenvalues\nprint(\"Eigenvalues:\", evals_base)\n\n# Obtain determinant and trace\ntr = np.trace(J_base)   # Trace\ndet = np.linalg.det(J_base)  # Determinant\n\n# Print determinant\nprint(f\"Determinant: {det}\")\n\n# Calculate and print modulus of the first eigenvalue\nmod_base = abs(evals_base[0])\nprint(f\"Modulus of first eigenvalue: {mod_base}\")\n\n# Check general stability conditions\nprint(f\"1 + tr + det &gt; 0: {1 + tr + det &gt; 0}\")\nprint(f\"1 - tr + det &gt; 0: {1 - tr + det &gt; 0}\")\nprint(f\"1 - det &gt; 0: {1 - det &gt; 0}\")\n\n# Check analytical stability condition\nprint(((1 - delta - gamma) * (1 - alpha * sigma) + alpha * (1 - delta)) &lt; 1)\n\n### Check cycle condition and compute cycle length \n\n# Check analytical cycle condition\nprint(((alpha * (1 - sigma) + delta + gamma)**2 - 4 * alpha * gamma) &lt; 0)\n\n# Save real and imaginary parts of complex eigenvalue\nre = np.real(evals_base[0])\nim = np.imag(evals_base[0])\n\n# Calculate cycle length\nL = (2 * np.pi) / np.arccos(re / mod_base)\nprint(f\"Cycle length: {L}\")\n\n\n\n\nThe analytical cycle condition confirms that the eigenvalues of the system will be complex and thus generate cycles. The implied cycle length is around 17 periods.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>A Kaldorian Endogenous Business Cycle Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor_model.html#references",
    "href": "a_Kaldor_model.html#references",
    "title": "18  A Kaldorian Endogenous Business Cycle Model",
    "section": "References",
    "text": "References\n\n\n\n\nBischi, Gian Italo, Roberto Dieci, Giorgio Rodano, and Enrico Saltari. 2001. “Multiple Attractors and Global Bifurcations in a Kaldor-Type Business Cycle Model.” Journal of Evolutionary Economics 11 (5): 527–54. https://doi.org/10.1007/s191-001-8320-9.\n\n\nChang, W. W., and D. J. Smyth. 1971. “The Existence and Persistence of Cycles in a Non-Linear Model: Kaldor’s 1940 Model Re-Examined.” The Review of Economic Studies 38 (1): 37. https://doi.org/10.2307/2296620.\n\n\nGabisch, Günter, and Hans-Walter Lorenz. 1989. Business Cycle Theory. A Survey of Methods and Concepts, 2nd Edition. Springer-Verlag.\n\n\nGandolfo, Giancarlo. 2009. Economic Dynamics. Study Edition. 4th Edition. Springer.\n\n\nHicks, John R. 1950. A Contribution to the Theory of the Trade Cycle. Clarendon Press.\n\n\nKaldor, Nicholas. 1940. “A Model of the Trade Cycle.” The Economic Journal 50 (197): 78–92.\n\n\nSamuelson, Paul A. 1939. “Interactions between the Multiplier Analysis and the Principle of Acceleration.” The Review of Economics and Statistics 21 (2): 75–78. https://doi.org/10.2307/1927758.\n\n\nStockhammer, Engelbert, Robert Calvert Jump, Karsten Kohler, and Julian Cavallero. 2019. “Short and Medium Term Financial-Real Cycles: An Empirical Assessment.” Journal of International Money and Finance 94 (June): 81–96. https://doi.org/10.1016/j.jimonfin.2019.02.006.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>A Kaldorian Endogenous Business Cycle Model</span>"
    ]
  },
  {
    "objectID": "a_Kaldor_model.html#footnotes",
    "href": "a_Kaldor_model.html#footnotes",
    "title": "18  A Kaldorian Endogenous Business Cycle Model",
    "section": "",
    "text": "More precisely, Samuelson (1939)’s model generates shock-independent cycles only for a very specific parameter combination, whereas Kaldor (1940)’s model generates endogenous cycles for a much broader set of parameters.↩︎\nThe first 10 periods were excluded from the computation as these are driven by the adjustment from the arbitrary initialisation.↩︎\nIn discrete-time dynamic systems, the Hopf bifurcation is also called Neimark-Sacker bifurcation.↩︎\nTo increase computational efficiency, we simulate a reduced-form version of the model in \\(Y_t\\) and \\(K_t\\) only that is derived in the analytical discussion below.↩︎\nSee Bischi et al. (2001) for a comprehensive mathematical analysis of all possible equilibria of the model.↩︎\nSee also Stockhammer et al. (2019) on this condition for cycles.↩︎\nTo plot the conditions, we replace the inequalities by equality signs and solve for 0.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>A Kaldorian Endogenous Business Cycle Model</span>"
    ]
  },
  {
    "objectID": "an_evolutionary_game_theoretic_model.html",
    "href": "an_evolutionary_game_theoretic_model.html",
    "title": "19  An Evolutionary Game Theoretic Model of the Emergence of Property Rights",
    "section": "",
    "text": "Overview\nEvolutionary game theory (EGT) has its origins in evolutionary biology, where it was developed to study how behavioural strategies evolve within populations. It combines concepts from game theory, such as strategic interactions and their resulting payoffs, with Darwinian evolutionary biology, in particular the idea of differential replication (selection). Populations are assumed to consist of repeatedly interacting agents that follow different strategies with different payoffs. More successful strategies will reproduce faster, thereby increasing their frequencies in the population. EGT studies different strategies, their performance, and the possible equilibria that may emerge over time, which can involve the extinction, dominance, or co-existence of various strategies.1 Unlike classical game theory which typically assumes agents to be fully rational, EGT assumes agents to follow simple rules whose relative success is not known to the agents in advance.\nIn this section, we present a continuous-time model from Bowles (2004), chapter 11, which seeks to illuminate the logic behind the emergence of property rights.2 It asks how social norms that ensure the enforcement of property rights could evolve through the repeated interaction of agents. The model features three types of strategies: sharing, grabbing, and punishing. For property rights to be respected, the grabbing strategy needs to be contained through sufficiently pervasive punishing. A particularly interesting feature of the model, both from an economic and a technical perspective, is that its outcomes depend on initial conditions. The model thus captures a form of path dependence, where a historically given distribution of behavioural rules impacts not only the subsequent trajectory, but also the long-run equilibrium that will emerge.3",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>An Evolutionary Game Theoretic Model of the Emergence of Property Rights</span>"
    ]
  },
  {
    "objectID": "an_evolutionary_game_theoretic_model.html#the-strategies-and-their-payoffs",
    "href": "an_evolutionary_game_theoretic_model.html#the-strategies-and-their-payoffs",
    "title": "19  An Evolutionary Game Theoretic Model of the Emergence of Property Rights",
    "section": "The strategies and their payoffs",
    "text": "The strategies and their payoffs\nThere are \\(n\\) members of a population that are paired randomly to divide a good whose value is \\(v\\). They can adopt one of three strategies: sharing, grabbing, or punishing. When Sharers meet, they divide the good equally. When Grabbers meet Sharers, they grab the good from the Sharers. When Grabbers meet other Grabbers, they fight and win or bear the costs of defeat \\(c &gt; v\\) with equal probability. Punishers meeting Sharers or other Punishers divide the good equally. When Punishers meets Grabbers, they attempt to punish the Grabbers collectively. If successful, an individual Punisher will distribute the good equally among all Punishers, otherwise it bears the cost of defeat \\(c\\). Because punishing is a collective strategy, its probability of success depends on the population frequency of Punishers. For simplicity, it is assumed that the probability of success is equal to the population frequency of Punishers, \\(\\beta\\). With these assumptions, the payoffs of the different interactions are given in Table 1.\nTable 1: Payoffs (for individual row players)\n\n\n\n\n\n\n\n\n\nShare\nGrab\nPunish\n\n\n\nShare\nv/2\n0\nv/2\n\n\nGrab\nv\n(v - c)/2\n(1 - \\(\\beta\\))v - \\(\\beta\\)c\n\n\nPunish\nv/2\nv/n - (1 - \\(\\beta\\))c\nv/2",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>An Evolutionary Game Theoretic Model of the Emergence of Property Rights</span>"
    ]
  },
  {
    "objectID": "an_evolutionary_game_theoretic_model.html#the-model",
    "href": "an_evolutionary_game_theoretic_model.html#the-model",
    "title": "19  An Evolutionary Game Theoretic Model of the Emergence of Property Rights",
    "section": "The model",
    "text": "The model\nThe model equations are: \\[\n\\pi^S_{t}=0.5v(\\alpha_t + \\beta_t)\n\\tag{19.1}\\]\n\\[\n\\pi^P_{t} = 0.5v(\\alpha_t + \\beta_t) + (1-\\alpha_t -\\beta_t)[\\beta_t v - (1-\\beta_t)c)]\n\\tag{19.2}\\]\n\\[\n\\pi^G_{t} = \\alpha_t v + \\beta_t[(1-\\beta_t)v-\\beta_t c] + 0.5(1-\\alpha_t -\\beta_t)(v-c)\n\\tag{19.3}\\]\n\\[\n\\dot{\\alpha}=\\alpha_t( \\pi^S_{t} - \\bar{\\pi})\n\\tag{19.4}\\]\n\\[\n\\dot{\\beta}=\\beta_t( \\pi^G_{t} - \\bar{\\pi})\n\\tag{19.5}\\]\n\\[\n\\bar{\\pi}_t=\\alpha_t \\pi^S_{t} + \\beta_t \\pi^P_{t} +\\gamma_t \\pi^G_{t}\n\\tag{19.6}\\]\n\\[\n\\gamma_t=1-\\alpha_t -\\beta_t\n\\tag{19.7}\\]\nwhere \\(\\pi^S_{t}\\), \\(\\pi^P_{t}\\), and \\(\\pi^G_{t}\\) represent the expected payoffs of Sharers, Punishers, and Grabbers, and \\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\) are their respective population frequencies. \\(\\bar{\\pi}\\) is the (weighted) average payoff. \\(v\\) and \\(c\\) are the value of the good to be divided and the cost of losing a fight, respectively. A dot over a variable represents the derivative with respect to time (\\(\\dot{x}=\\frac{d x}{d t}\\)).\nEquation 19.1 - Equation 19.3 specify the expected payoffs associated with the three strategies. These follow from the payoffs from the different possible pairings reported in Table 1 together with the population frequencies, which constitute the probabilities of being randomly paired with a player of the respective strategy. To find the expected payoff for Punishers, consider what happens in interactions with Grabbers. The value in Table 1, v/n - (1 - \\(\\beta\\))c, represents the payoff for an individual Punisher in an interaction with a Grabber. However, in every period, there are \\(\\beta n - 1\\) other Punishers, of which \\((\\beta n - 1)(1-\\alpha-\\beta)\\) will also be paired with Grabbers. Each Punisher will receive \\(v/\\beta n\\) from each of these, yielding an expected amount \\((\\beta n - 1)(1-\\alpha-\\beta)(v/n)\\) from redistribution. Adding this expected redistributed payoff to the expected direct payoffs in Table 1 yields the total payoff for Punishers in Equation 19.2.\nEquation 19.4 - Equation 19.5 specify the change in population frequencies of Sharers and Punishers. These so-called replicator equations are a key feature of EGT. They encapsulate the idea of selection based on relative fitness: strategies that yield above-average payoffs (as defined in Equation 19.6) increase their presence in the population. While in biological applications, strategies are typically conceived as genetically inherited and replication as sexual reproduction, in social applications, replication may occur through a cultural transmission process and/or adaptive learning.\nWith the population dynamics of Sharers and Punishers determined, the frequency of Grabbers follows residually (Equation 19.7).",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>An Evolutionary Game Theoretic Model of the Emergence of Property Rights</span>"
    ]
  },
  {
    "objectID": "an_evolutionary_game_theoretic_model.html#simulation",
    "href": "an_evolutionary_game_theoretic_model.html#simulation",
    "title": "19  An Evolutionary Game Theoretic Model of the Emergence of Property Rights",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTable 2 reports the initialisations used in the simulations. We will keep the parameters \\(v\\) and \\(c\\) fixed and study how different initialisations of the population shares give rise to different equilibria, whose interpretation (‘Hobbesian’ vs ‘Rousseauian’) will be discussed below.\nTable 2: Initialisations\n\n\n\n\n\n\n\n\n\n\nInitialisations\n\\(v\\)\n\\(c\\)\n\\(\\alpha_0\\)\n\\(\\beta_0\\)\n\\(\\gamma_0\\)\n\n\n\n1: Hobbesian equilibrium\n2\n3\n1/3\n1/3\n1/3\n\n\n2: Rousseauian equilibrium #1\n2\n3\n0.2\n0.6\n0.2\n\n\n2: Rousseauian equilibrium #2\n2\n3\n0.1\n0.6\n0.3\n\n\nSimulation code\n\n#Clear the environment\nrm(list=ls(all=TRUE))\n\n#Set number of periods\nQ = 1000\n\n# time increment\nd=0.1   \n\n# Set number of initialisations\nS=3\n\n# Set constant parameter values\nv=2   # value of good to be divided\nc=3   # cost of defeat\n\n#Create (S x Q) matrices in which equilibrium solutions from different initialisations will be stored\npi_S=matrix(data=0.5, nrow=S, ncol=Q)   # payoffs for Sharers\npi_P=matrix(data=0.5, nrow=S, ncol=Q)   # payoffs for Punishers \npi_G=matrix(data=0.5, nrow=S, ncol=Q)   # payoffs for Grabber \npi_bar=matrix(data=0.5, nrow=S, ncol=Q) # average payoffs\nalpha=matrix(data=0, nrow=S, ncol=Q)    # population frequency of Sharers\nbeta=matrix(data=0, nrow=S, ncol=Q)     # population frequency of Punishers\ngamma=matrix(data=0, nrow=S, ncol=Q)    # population frequency of Grabbers\n\n### Initialise population shares\n# Hobbesian equilibrium \nalpha[1, 1]=1/3\nbeta[1, 1]=1/3\ngamma[1, 1]=1- alpha[1, 1] - beta[1, 1]\n\n# Rousseauian equilibrium #1\nalpha[2, 1]=0.2\nbeta[2, 1]=0.6 \ngamma[2, 1]=1- alpha[2, 1] - beta[2, 1]\n\n# Rousseauian equilibrium #2\nalpha[3, 1]=0.1\nbeta[3, 1]=0.6\ngamma[3, 1]=1- alpha[3, 1] - beta[3, 1]\n\n# Simulate the model by looping over Q time periods for S different initialisations\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    # Population share of Sharers\n    alpha[i,t] = alpha[i,t-1] + alpha[i,t-1]*(pi_S[i,t-1] - pi_bar[i,t-1])*d\n    \n    # Population share of Punishers\n    beta[i,t] = beta[i,t-1] + beta[i,t-1]*(pi_P[i,t-1] - pi_bar[i,t-1])*d\n    \n    # Population share of Grabbers\n    gamma[i,t]=1- alpha[i, t] - beta[i, t]\n    \n    # Payoffs of Sharers  \n    pi_S[i,t] = 0.5*v*(alpha[i,t] + beta[i,t])\n    \n    # Payoffs of Punishers  \n    pi_P[i,t] = 0.5*v*(alpha[i,t] + beta[i,t]) + (1-alpha[i,t]-beta[i,t])*(beta[i,t]*v-(1-beta[i,t])*c)\n    \n    # Payoffs of Grabbers\n    pi_G[i,t] = alpha[i,t]*v + beta[i,t]*((1-beta[i,t])*v-beta[i,t]*c) + (1-alpha[i,t]-beta[i,t])*0.5*(v-c)\n    \n    # Average payoffs\n    pi_bar[i,t] = alpha[i,t]*pi_S[i,t] + beta[i,t]*pi_P[i,t] + (1-alpha[i,t]-beta[i,t])*pi_G[i,t]\n    \n  }  # close time loop\n}   # close scenarios loop\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n# Set number of periods\nQ = 1000\n\n# Time increment\nd = 0.1   \n\n# Set number of initialisations\nS = 3\n\n# Set constant parameter values\nv = 2   # value of good to be divided\nc = 3   # cost of defeat\n\n# Create (S x Q) matrices in which equilibrium solutions from different initialisations will be stored\npi_S = np.full((S, Q), 0.5)   # payoffs for Sharers\npi_P = np.full((S, Q), 0.5)   # payoffs for Punishers \npi_G = np.full((S, Q), 0.5)   # payoffs for Grabbers \npi_bar = np.full((S, Q), 0.5) # average payoffs\nalpha = np.zeros((S, Q))      # population frequency of Sharers\nbeta = np.zeros((S, Q))       # population frequency of Punishers\ngamma = np.zeros((S, Q))      # population frequency of Grabbers\n\n### Initialise population shares\n# Hobbesian equilibrium \nalpha[0, 0] = 1/3\nbeta[0, 0] = 1/3\ngamma[0, 0] = 1 - alpha[0, 0] - beta[0, 0]\n\n# Rousseauian equilibrium #1\nalpha[1, 0] = 0.2\nbeta[1, 0] = 0.6 \ngamma[1, 0] = 1 - alpha[1, 0] - beta[1, 0]\n\n# Rousseauian equilibrium #2\nalpha[2, 0] = 0.1\nbeta[2, 0] = 0.6\ngamma[2, 0] = 1 - alpha[2, 0] - beta[2, 0]  \n\n# Simulate the model by looping over Q time periods for S different initializations\nfor i in range(S):\n    \n    for t in range(1, Q):\n        \n        # Population share of Sharers\n        alpha[i, t] = alpha[i, t-1] + alpha[i, t-1] * (pi_S[i, t-1] - pi_bar[i, t-1]) * d\n        \n        # Population share of Punishers\n        beta[i, t] = beta[i, t-1] + beta[i, t-1] * (pi_P[i, t-1] - pi_bar[i, t-1]) * d\n        \n        # Population share of Grabbers\n        gamma[i, t] = 1 - alpha[i, t] - beta[i, t]\n        \n        # Payoffs of Sharers  \n        pi_S[i, t] = 0.5 * v * (alpha[i, t] + beta[i, t])\n        \n        # Payoffs of Punishers  \n        pi_P[i, t] = (0.5 * v * (alpha[i, t] + beta[i, t]) + \n                      (1 - alpha[i, t] - beta[i, t]) * (beta[i, t] * v - (1 - beta[i, t]) * c))\n        \n        # Payoffs of Grabbers\n        pi_G[i, t] = (alpha[i, t] * v + \n                      beta[i, t] * ((1 - beta[i, t]) * v - beta[i, t] * c) + \n                      (1 - alpha[i, t] - beta[i, t]) * 0.5 * (v - c))\n        \n        # Average payoffs\n        pi_bar[i, t] = (alpha[i, t] * pi_S[i, t] + \n                        beta[i, t] * pi_P[i, t] + \n                        (1 - alpha[i, t] - beta[i, t]) * pi_G[i, t])\n        \n\n\n\n\nPlots\nFigure 19.1 displays the population shares for the first initialisation, giving rise to what Bowles (2004) calls the ‘Hobbesian equilibrium’. In this equilibrium, the Punishers have died out and the population is split into Sharers and Grabbers. Due to the strong presence of Grabbers, this equilibrium is characterised by frequent fighting that goes unpunished. The red horizontal line displays the average equilibrium payoff.\n\n# Set start and end periods for plots\nTmin =3\nTmax=100\n\n# Hobbesian equilibrium\nplot(alpha[1, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Population shares\", ylim=range(0,1), xlim=c(Tmin,Tmax))\ntitle(main=\"\", cex=0.8)\nlines(beta[1, 1:Q],lty=2)\nlines(gamma[1, 1:Q],lty=3)\nabline(h=pi_bar[1,Q], col=2)\nlegend(\"topright\", legend=c(\"Sharers\", \"Punishers\", \"Grabbers\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 19.1: Hobbesian equilibrium\n\n\n\n\nFigure 19.2 and Figure 19.3 display the population shares for the other two initialisations that yield ‘Rousseauian’ equilibria. In these equilibria, the Grabbers have died out and the population is split into Sharers and Punishers. As a result, property rights are respected and social norms of peaceful sharing are upheld. The average equilibrium payoff are higher compared to the Hobbesian equilibrium due to the absence of costly losses from fighting Thus, social welfare in the cooperative Rousseauian equilibrium is higher compared to the conflictive Hobbesian equilibrium.\n\n# Rousseauian equilibrium 1\nplot(alpha[2, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Population shares\", \n     ylim=range(0,1),xlim=c(Tmin,Tmax))\ntitle(main=\"\", cex=0.8)\nlines(beta[2, 1:Q],lty=2)\nlines(gamma[2, 1:Q],lty=3)\nabline(h=pi_bar[2,Q], col=2)\nlegend(\"right\", legend=c(\"Sharers\", \"Punishers\", \"Grabbers\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 19.2: Rousseauian equilibrium, no. 1\n\n\n\n\nFigure 19.3 represents another incidence of the Rousseauian equilibrium resulting from a different initialisation. Grabber again have died out, but the composition of Sharers and Grabbers is different from the one in Figure 19.2, with a higher share of Punishers. This result suggests that the Rousseauian equilibrium is stable but not unique.\n\n# Rousseauian equilibrium 2\nplot(alpha[3, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"Time\", ylab=\"Population shares\", \n     ylim=range(0,1),xlim=c(Tmin,Tmax))\ntitle(main=\"\", cex=0.8)\nlines(beta[3, 1:Q],lty=2)\nlines(gamma[3, 1:Q],lty=3)\nabline(h=pi_bar[3,Q], col=2)\nlegend(\"right\", legend=c(\"Sharers\", \"Punishers\", \"Grabbers\"),\n       lty=1:3, cex=0.8, bty = \"n\", y.intersp=0.8)\n\n\n\n\n\n\nFigure 19.3: Rousseauian equilibrium, no. 2\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Plot results (here only for the Hobbesian equilibrium)\n\nimport matplotlib.pyplot as plt\n\n# Set start and end periods for plots\nTmin = 3\nTmax = 100\n\n# Hobbesian equilibrium\nplt.figure(figsize=(8, 5))\nplt.plot(range(Q), alpha[0, :], label=\"Sharers\", color='black', linewidth=2, linestyle='-')\nplt.title(\"\")  \nplt.xlabel(\"Time\")\nplt.ylabel(\"Population shares\")\nplt.ylim(0, 1)\nplt.xlim(Tmin, Tmax)\nplt.plot(range(Q), beta[0, :], linestyle='--', color='black', label=\"Punishers\")\nplt.plot(range(Q), gamma[0, :], linestyle=':', color='black', label=\"Grabbers\")\nplt.axhline(y=pi_bar[0, Q-1], color='red')  \nplt.legend(loc='upper right', fontsize=8, frameon=False)  \nplt.tight_layout()\nplt.show()\n\n\n\n\nCreating an interactive 3D diagram of the basins of attraction\nThe finding that different Rousseauian equilibria emerge from different initialisations warrants a more detailed examination of the dependence of the equilibria on initial values. In this section, we show how to create a diagram of the ‘basins of attraction’ of the different equilibria, which map a set of initial conditions to the corresponding equilibria. To this end, we need to simulate the model for different values of the initial conditions and store the results.\nThe following code first creates a function called bowles that will be used to simulate Bowles (2004)’s EGT model for different initial values and store the results in a data frame. We then create a grid of initial values \\(\\alpha_0 \\in [0,1]\\) and \\(\\beta_0 \\in [0,1]\\) considering increments of \\(0.05\\).4 Inadmissible combinations of \\(\\alpha_0\\) and \\(\\beta_0\\) whose sum exceeds unity are removed from the grid. The function is then executed for all combinations on the grid, and the resulting data are appended as rows to a matrix.\n\n# Define a function called \"bowles\" that simulates the model for different initialisations\nbowles =function(alpha_0, beta_0) {\n  \n  # Initialise data matrices \n  pi_S = rep(0.5, Q)\n  pi_P = rep(0.5, Q)\n  pi_G = rep(0.5, Q)\n  pi_bar = rep(0.5, Q)\n  \n  alpha = rep(NA, Q)\n  beta = rep(NA, Q)\n  gamma = rep(NA, Q)\n  \n  # Initialise population shares\n  alpha[1] = alpha_0\n  beta[1] = beta_0\n  gamma[1] = round(1 - alpha[1] - beta[1], digits=2)\n  \n  # Simulate model\n  for (t in 2:Q) {\n    alpha[t] = alpha[t-1] + alpha[t-1] * (pi_S[t-1] - pi_bar[t-1]) * d\n    beta[t]  = beta[t-1] + beta[t-1] * (pi_P[t-1] - pi_bar[t-1]) * d\n    gamma[t] = 1 - alpha[t] - beta[t]\n    \n    pi_S[t] = 0.5 * v * (alpha[t] + beta[t])\n    pi_P[t] = 0.5 * v * (alpha[t] + beta[t]) + (1 - alpha[t] - beta[t]) * (beta[t]*v - (1 - beta[t]) * c)\n    pi_G[t] = alpha[t] * v + beta[t] * ((1 - beta[t]) * v - beta[t] * c) + (1 - alpha[t] - beta[t]) * 0.5 * (v - c)\n    pi_bar[t] = alpha[t] * pi_S[t] + beta[t] * pi_P[t] + (1 - alpha[t] - beta[t]) * pi_G[t]\n  } # close time loop\n  \n  # Return final values in a dataframe\n  data.frame(\n    alpha_0 = alpha_0,\n    beta_0 = beta_0,\n    gamma_0= gamma[1],\n    alpha_T = round(alpha[Q], digits=3),\n    beta_T = round(beta[Q], digits=3),\n    gamma_T = round(gamma[Q], digits=3),\n    pi_S_T = round(pi_S[Q], digits=3),\n    pi_P_T = round(pi_P[Q], digits=3),\n    pi_G_T = round(pi_G[Q], digits=3),\n    pi_bar =round(pi_bar[Q], digits=3)\n    )\n} # close function\n\n# Create grid of initial values for alpha and beta\ngrid=expand.grid(\n  alpha_0 = seq(0, 1, by = 0.05),\n  beta_0 = seq(0, 1, by = 0.05)\n)\n\n# Exclude invalid combinations where alpha + beta &gt; 1\ngrid=subset(grid, alpha_0 + beta_0 &lt;= 1)\n\n# Execute the function over the grid and append data from each run as rows to a matrix named \"results\"\nresults=do.call(rbind, lapply(1:nrow(grid), function(i) {\n  bowles(grid$alpha_0[i], grid$beta_0[i])\n}))\n\nHaving simulated the data for different initialisations, Figure 19.4 plots the equilibrium values for the population shares from the different runs. It can be seen that three types of equilibria are possible. First, the unique Hobbesian equilibrium where \\(\\beta^*=0\\). Second, a continuum of Rousseauian equilibria, where \\(\\gamma^*=0\\) and \\(\\alpha^*+\\beta^*=1\\). Third, a unique equilibrium where \\(\\gamma^*=1\\) and \\(\\alpha^*=\\beta^*=0\\).\n\n# Install plotly package to create 3D plots\n#install.packages(\"plotly\")\n\n# Load plotly package to create 3D plots\nlibrary(plotly)\n\n# Create a 3D scatter plot of the final values of the population shares using the data from different initialisations\nfig_endog =plot_ly(\n  data = results, \n  x = ~alpha_T, \n  y = ~beta_T, \n  z = ~gamma_T,\n  type = \"scatter3d\",\n  mode = \"markers\",\n  marker = list(size = 3, showscale = FALSE)\n)\n\nfig_endog = fig_endog %&gt;% layout(\n  scene = list(\n    xaxis = list(title = \"alpha_T\"),\n    yaxis = list(title = \"beta_T\"),\n    zaxis = list(title = \"gamma_T\")\n  ),\n  title = \"\"\n)\n\n# Show plot\nfig_endog\n\n\n\n\n\n\nFigure 19.4: Population shares – possible equilibria\n\n\n\nFigure 19.5 plots the basin of attraction of \\(\\gamma^*\\) for different initialisations \\((\\alpha_0, \\beta_0)\\). This shows the dependence of the three types of equilibria on the initialisation. The Hobbesian equilibrium yielding \\(\\gamma^* \\in [0,1]\\) can occur for a relatively wide range of \\(\\alpha_0 \\in [0,1]\\) values, but a narrower range of \\(\\beta_0 \\in (0,\\beta^H]\\) with an upper bound \\(\\beta^H \\approx 0.45\\). Intuitively, if there are too many Punishers, they cannot be pushed away by the Grabbers. In contrast, the Rousseauian equilibria where \\(\\gamma^* =0\\) require either a relatively high initial share of Punishers or Sharers (or both). Finally, the third equilibrium where \\(\\gamma^* =1\\) can only occur for initialisations without Sharers (\\(\\alpha_0=0\\)) and a low share of Punishers (roughly below 0.35).\n\n# Create a 3D scatter plot of the final values of the population share of Grabbers (gamma) for different initialisations\nfig_gamma =plot_ly(\n  data = results, \n  x = ~alpha_0, \n  y = ~beta_0, \n  z = ~gamma_T,\n  type = \"scatter3d\",\n  mode = \"markers\",\n  marker = list(size = 3, color = ~gamma_T, colorscale = \"Viridis\", showscale = TRUE)\n)\n\nfig_gamma = fig_gamma %&gt;% layout(\n  scene = list(\n    xaxis = list(title = \"alpha_0\"),\n    yaxis = list(title = \"beta_0\"),\n    zaxis = list(title = \"gamma_T\")\n  ),\n  title = \"\"\n)\n\n# Show plot\nfig_gamma\n\n\n\n\n\n\nFigure 19.5: Basin of attraction for the equilibrium population share of Grabbers\n\n\n\nHow could a transition from the Hobbesian equilibrium to a Rousseauian equilibrium occur? The Rousseauian equilibrium requires a sufficiently high number of Punishers, so an exogenous intervention that pushes the share of Punishers beyond the critical value \\(\\beta^H\\) would accomplish such a transition. However, as the Rousseauian equilibrium is a continuum, too small an intervention that pushes the population of Punishers just above the critical threshold, where the system will stay without further interventions, may run the risk of falling back into the basin of attraction of the Hobbesian equilibrium.5\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Run model for different initialisations\nimport numpy as np\nimport pandas as pd\n\n# Define a function called \"bowles\" that simulates the model for different initializations\ndef bowles(alpha_0, beta_0):\n    \n    # Initialise data arrays\n    pi_S = np.full(Q, 0.5)\n    pi_P = np.full(Q, 0.5)\n    pi_G = np.full(Q, 0.5)\n    pi_bar = np.full(Q, 0.5)\n    \n    alpha = np.empty(Q)\n    beta = np.empty(Q)\n    gamma = np.empty(Q)\n    \n    # Initialise population shares\n    alpha[0] = alpha_0\n    beta[0] = beta_0\n    gamma[0] = round(1 - alpha[0] - beta[0], 2)\n    \n    # Simulate model\n    for t in range(1, Q):\n        alpha[t] = alpha[t-1] + alpha[t-1] * (pi_S[t-1] - pi_bar[t-1]) * d\n        beta[t]  = beta[t-1] + beta[t-1] * (pi_P[t-1] - pi_bar[t-1]) * d\n        gamma[t] = 1 - alpha[t] - beta[t]\n        \n        pi_S[t] = 0.5 * v * (alpha[t] + beta[t])\n        pi_P[t] = (0.5 * v * (alpha[t] + beta[t]) + \n                   (1 - alpha[t] - beta[t]) * (beta[t] * v - (1 - beta[t]) * c))\n        pi_G[t] = (alpha[t] * v + \n                   beta[t] * ((1 - beta[t]) * v - beta[t] * c) + \n                   (1 - alpha[t] - beta[t]) * 0.5 * (v - c))\n        pi_bar[t] = (alpha[t] * pi_S[t] + \n                     beta[t] * pi_P[t] + \n                     (1 - alpha[t] - beta[t]) * pi_G[t])\n    \n    # Return final values in a dataframe\n    return pd.DataFrame({\n        'alpha_0': [alpha_0],\n        'beta_0': [beta_0],\n        'gamma_0': [gamma[0]],\n        'alpha_T': [round(alpha[Q-1], 3)],\n        'beta_T': [round(beta[Q-1], 3)],\n        'gamma_T': [round(gamma[Q-1], 3)],\n        'pi_S_T': [round(pi_S[Q-1], 3)],\n        'pi_P_T': [round(pi_P[Q-1], 3)],\n        'pi_G_T': [round(pi_G[Q-1], 3)],\n        'pi_bar': [round(pi_bar[Q-1], 3)]\n    })\n\n# Create grid of initial values for alpha and beta\nalpha_vals = np.arange(0, 1.05, 0.05)\nbeta_vals = np.arange(0, 1.05, 0.05)\n\ngrid = pd.DataFrame([(a, b) for a in alpha_vals for b in beta_vals],\n                     columns=['alpha_0', 'beta_0'])\n\n# Exclude invalid combinations where alpha + beta &gt; 1\ngrid = grid[grid['alpha_0'] + grid['beta_0'] &lt;= 1].reset_index(drop=True)\n\n# Execute the function over the grid and append data from each run as rows to a dataframe named \"results\"\nresults = pd.concat([bowles(row.alpha_0, row.beta_0) for _, row in grid.iterrows()],\n                    ignore_index=True)\n\n### Create 3D plot (here for endogeneous variables only)\n\n# Load plotly package to create 3D plots — done via import\n\nimport plotly.graph_objects as go\nimport plotly.express as px\nimport plotly.io as pio\n\n# Create a 3D scatter plot of the final values of the population shares \n# using the data from different initializations\nfig_endog = go.Figure(\n    data=[\n        go.Scatter3d(\n            x=results['alpha_T'],\n            y=results['beta_T'],\n            z=results['gamma_T'],\n            mode='markers',\n            marker=dict(size=3, showscale=False)\n        )\n    ]\n)\n\nfig_endog.update_layout(\n    scene=dict(\n        xaxis_title='alpha_T',\n        yaxis_title='beta_T',\n        zaxis_title='gamma_T'\n    ),\n    title=''\n)\n\n# Show plot (this will open the plot in a browser)\npio.renderers.default = 'browser'\n#fig_endog.show()",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>An Evolutionary Game Theoretic Model of the Emergence of Property Rights</span>"
    ]
  },
  {
    "objectID": "an_evolutionary_game_theoretic_model.html#analytical-discussion",
    "href": "an_evolutionary_game_theoretic_model.html#analytical-discussion",
    "title": "19  An Evolutionary Game Theoretic Model of the Emergence of Property Rights",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nHere we will formally analyse the equilibria and then their stability.6\nThe Hobbesian equilibrium occurs for \\(\\beta^*=0\\) and positive values of \\(\\alpha^*\\) and \\(\\gamma^*\\), so that \\(\\alpha^* + \\gamma^* = 1\\). In equilibrium we have \\(\\dot{\\alpha}=0\\), which requires \\(\\pi^S=\\bar{\\pi}\\). With \\(\\beta^*=0\\), we have \\(\\bar{\\pi}=\\alpha \\pi^S + (1-\\alpha) \\pi^G\\). From \\(\\pi^S = \\alpha \\pi^S + (1-\\alpha) \\pi^G\\) and the condition that \\((1-\\alpha^*) =\\gamma^*&gt;0\\), we get \\(\\pi^S=\\pi^G\\). Using Equation 19.1 and Equation 19.3, the condition \\(\\pi^S=\\pi^G\\) becomes \\(0.5v\\alpha=\\alpha v + (1-\\alpha)0.5(v-c)\\), which implies: \\[\n(\\alpha^*,\\gamma^*)=\\left(1-\\frac{v}{c}, \\frac{v}{c}\\right).\n\\]\nWe can check these analytical solutions numerically:\n\n### Compare numerical equilibrium solutions to analytical solutions\nalpha[1,Q]  # numerical\n\n[1] 0.3333333\n\n1-v/c       # analytical\n\n[1] 0.3333333\n\ngamma[1,Q]  # numerical\n\n[1] 0.6666667\n\nv/c         # analytical\n\n[1] 0.6666667\n\n# Confirm that the payoffs of Sharers and Grabbers are equal in equilibrium\npi_S[1,Q]\n\n[1] 0.3333333\n\npi_G[1,Q]\n\n[1] 0.3333333\n\npi_bar[1,Q]\n\n[1] 0.3333333\n\n\nThe Rousseauian equilibria occur for \\(\\gamma^*=0\\) and \\(\\alpha\\) + \\(\\beta\\) =1 $. For \\(\\dot{\\alpha}=\\dot{\\beta}=0\\), we require \\(\\pi^S=\\pi^P=\\bar{\\pi}\\), and with \\(\\gamma^*=0\\), we have \\(\\bar{\\pi}=\\alpha \\pi^S + \\beta \\pi^P\\). From \\(\\pi^S = \\alpha \\pi^S + \\beta \\pi^P\\) and \\(\\beta=(1-\\alpha)\\), we get \\(\\pi^S=\\pi^P\\). Using Equation 19.1 and Equation 19.2, confirms that this equilibrium does require \\(\\gamma^*=(1-\\alpha^* - \\beta^*)=0\\), but it does not allow to pin down unique equilibrium values.\n\n### Confirm that alpha+gamma=1 in the Rousseauian equilibria\nalpha[2,Q]+beta[2,Q]  \n\n[1] 1\n\nalpha[3,Q]+beta[3,Q]  \n\n[1] 1\n\n# Confirm that the payoffs of Sharers and Punishers are equal in equilibrium\npi_S[2,Q]\n\n[1] 1\n\npi_P[2,Q]\n\n[1] 1\n\npi_bar[2,Q]\n\n[1] 1\n\n\nNext, we analyse the stability properties of the Hobbesian and Roussauian equilibrium, respectively. The Jacobian matrix for the dynamic system in Equation 19.4 and Equation 19.5 is given by: \\[\nJ(\\alpha, \\beta) =\n\\begin{bmatrix}\n\\pi_t^S - \\bar{\\pi}_t + \\alpha_t \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha} & \\alpha_t \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\beta} \\\\\n\\beta_t \\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\alpha} & \\pi_t^P - \\bar{\\pi}_t + \\beta_t \\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\beta}.\n\\end{bmatrix}\n\\]\nThe stability conditions for two-dimensional dynamic systems in continuous time are: \\[\ntr(J) &lt; 0,\n\\]\nand \\[\ndet(J) &gt; 0,\n\\]\nwhere \\(tr(J)\\) is the trace and \\(det(J)\\) the determinant of the Jacobian matrix.\nIn the Hobbesian equilibrium, where \\(\\beta^*=0\\) and \\(\\pi_t^S=  \\bar{\\pi}_t\\), the Jacobian becomes:\n\\[\nJ^*_H =\n\\begin{bmatrix}\n\\alpha^* \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha} & \\alpha^* \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\beta} \\\\\n0 & \\beta^* \\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\beta}\n\\end{bmatrix},\n\\]\ngiving\n\\[\ntr(J^*_H) = \\alpha^* \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha} + \\pi^P - \\bar{\\pi}\n\\]\nand\n\\[\n\\det(J^*_H)= \\left[ \\alpha^* \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha} \\right] \\left( \\pi^P - \\bar{\\pi} \\right).\n\\]\nUsing Equation 19.2 and Equation 19.6 and imposing \\(\\beta^*=0\\), we have\n\\[\n\\pi^P - \\bar{\\pi} = -0.5(1-\\alpha^*)[c(1+\\alpha)+v] &lt; 0.\n\\]\nThus, for \\(\\det(J^*_H) &gt;0\\), we need \\(\\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha}&lt; 0\\).\nUsing Equation 19.1 and and Equation 19.6, we can derive: \\[\n\\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha} = \\frac{\\partial \\pi^P}{\\partial \\alpha} (1 - \\beta_t)\n- \\pi^S_t\n- \\alpha_t \\frac{\\partial \\pi^S}{\\partial \\alpha}\n- \\frac{\\partial \\beta}{\\partial \\alpha} \\pi^P_t\n- (1 - \\alpha_t - \\beta_t) \\frac{\\partial \\pi^G}{\\partial \\alpha}\n+ \\left(1 + \\frac{\\partial \\beta}{\\partial \\alpha}\\right) \\pi^G_t.\n\\]\nUsing Equation 19.1 and Equation 19.3, and imposing \\(\\beta^*=0\\), \\(\\pi^P = \\pi^S = \\bar{\\pi}\\), as well as \\(\\frac{\\partial \\beta}{\\partial \\alpha} = 0\\) gives:7 \\[\n\\frac{\\partial (\\pi_t^S - \\bar{\\pi})}{\\partial \\alpha} = -0.5v &lt; 0,\n\\]\nso that \\(\\det(J^*_H) &gt;0\\) and \\(tr(J^*_H) &lt; 0\\), proving that the Hobbesian equilibrium is stable.\nNext, consider the Rousseauian equilibrium where \\(\\gamma^*=0\\) and \\(\\alpha^*+\\beta^*=1\\), so that the Jacobian becomes: \\[\nJ^*_R =\n\\begin{bmatrix}\n(1 - \\beta^*) \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha} & (1 - \\beta^*) \\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\beta} \\\\\n\\beta^* \\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\alpha} & \\beta^* \\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\beta}\n\\end{bmatrix}.\n\\]\nObserve that if \\(\\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha}=\\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\alpha}\\) and \\(\\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\beta}=\\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\beta}\\), we’d get \\(det(J^*_R) = 0\\), i.e. the dynamic system would have a zero root yielding a continuum of equilibria that are stable but not self-correcting (also called Lyapunov stable). From the simulations, we know that this is indeed the case. We will confine the formal proof to showing that under the Rousseauian equilibrium, we do have \\(\\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha}=\\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\alpha}\\).\nFirst, using Equation 19.2 and and Equation 19.6, we can derive: \\[\n\\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\alpha} = \\frac{\\partial \\pi^P}{\\partial \\alpha} (1 - \\beta_t)\n- \\pi^S_t\n- \\alpha_t \\frac{\\partial \\pi^S}{\\partial \\alpha}\n- \\frac{\\partial \\beta}{\\partial \\alpha} \\pi^P_t\n- (1 - \\alpha_t - \\beta_t) \\frac{\\partial \\pi^G}{\\partial \\alpha}\n+ \\left(1 + \\frac{\\partial \\beta}{\\partial \\alpha}\\right) \\pi^G_t.\n\\]\nObserve that \\(\\frac{\\partial (\\pi^S - \\bar{\\pi})}{\\partial \\alpha}\\) and \\(\\frac{\\partial (\\pi^P - \\bar{\\pi})}{\\partial \\alpha}\\) will be equal if \\(\\frac{\\partial \\pi^S}{\\partial \\alpha} = \\frac{\\partial \\pi^P}{\\partial \\alpha}\\).\nWe have: \\[\n\\frac{\\partial \\pi^S}{\\partial \\alpha} = 0.5v \\left(1 + \\frac{\\partial \\beta}{\\partial \\alpha}\\right)\n\\] and \\[\n\\frac{\\partial \\pi^P}{\\partial \\alpha} = 0.5v \\left(1 + \\frac{\\partial \\beta}{\\partial \\alpha}\\right) - \\left[\\beta v - \\alpha c\\right] - \\frac{\\partial \\beta}{\\partial \\alpha} \\left[\\beta v - \\alpha c\\right].\n\\]\nImposing \\(\\alpha^* + \\beta^* = 1\\), which implies \\(\\frac{\\partial \\beta}{\\partial \\alpha} = -1\\), we get: \\[\n\\frac{\\partial \\pi^S}{\\partial \\alpha} =\\frac{\\partial \\pi^P}{\\partial \\alpha} = 0,\n\\]\nconfirming that the derivatives are indeed equal, so that \\(det(J^*_R) = 0\\).\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n### Compare numerical equilibrium solutions for alpha and gamma to analytical solutions\n\nalpha[0, Q-1]  # numerical\n1 - v / c      # analytical\n\ngamma[0, Q-1]  # numerical\nv / c          # analytical\n\n# Confirm that the payoffs of Sharers and Grabbers are equal in equilibrium\npi_S[0, Q-1]\npi_G[0, Q-1]\npi_bar[0, Q-1]\n\n### Confirm that alpha + beta = 1 in the Rousseauian equilibria\nalpha[1, Q-1] + beta[1, Q-1]   \nalpha[2, Q-1] + beta[2, Q-1]   \n\n# Confirm that the payoffs of Sharers and Punishers are equal in equilibrium\npi_S[1, Q-1]\npi_P[1, Q-1]\npi_bar[1, Q-1]",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>An Evolutionary Game Theoretic Model of the Emergence of Property Rights</span>"
    ]
  },
  {
    "objectID": "an_evolutionary_game_theoretic_model.html#references",
    "href": "an_evolutionary_game_theoretic_model.html#references",
    "title": "19  An Evolutionary Game Theoretic Model of the Emergence of Property Rights",
    "section": "References",
    "text": "References\n\n\n\n\nBowles, Samuel. 2004. Microeconomics: Behavior, Institutions, and Evolution. Princeton University Press.\n\n\nBowles, Samuel, and Jung-Kyoo Choi. 2013. “Coevolution of Farming and Private Property During the Early Holocene.” Proceedings of the National Academy of Sciences 110 (22): 8830–35. https://doi.org/10.1073/pnas.1212149110.\n\n\n———. 2019. “The Neolithic Agricultural Revolution and the Origins of Private Property.” Journal of Political Economy 127 (5): 2186–2228. https://doi.org/10.1086/701789.\n\n\nDieci, Roberto, and Xue-Zhong He. 2018. “Heterogeneous Agent Models in Finance.” In Handbook of Computational Economics, edited by Cars Hommes and Blake LeBaron, 4:257–328. Elsevier. https://doi.org/10.1016/bs.hescom.2018.03.002.\n\n\nDosi, Giovanni, Giorgio Fagiolo, and Andrea Roventini. 2010. “Schumpeter Meeting Keynes: A Policy-Friendly Model of Endogenous Growth and Business Cycles.” Journal of Economic Dynamics and Control 34 (9): 1748–67. https://doi.org/10.1016/j.jedc.2010.06.018.\n\n\nFranke, Reiner, and Frank Westerhoff. 2017. “TAKING STOCK: A RIGOROUS MODELLING OF ANIMAL SPIRITS IN MACROECONOMICS.” Journal of Economic Surveys 31 (5): 1152–82. https://doi.org/10.1111/joes.12219.\n\n\nMetcalfe, J. S. 1994. “Competition, Fisher’s Principle and Increasing Returns in the Selection Process.” Journal of Evolutionary Economics 4 (4): 327–46. https://doi.org/10.1007/bf01236409.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>An Evolutionary Game Theoretic Model of the Emergence of Property Rights</span>"
    ]
  },
  {
    "objectID": "an_evolutionary_game_theoretic_model.html#footnotes",
    "href": "an_evolutionary_game_theoretic_model.html#footnotes",
    "title": "19  An Evolutionary Game Theoretic Model of the Emergence of Property Rights",
    "section": "",
    "text": "EGT has been popularised by Richard Dawkin’s 1976 book The Selfish Gene and Robert Axelrod’s 1984 book The Evolution of Cooperation. The latter contributed to the application of EGT to the social sciences and is also regarded as a milestone in the development of agent-based modelling. While EGT has predominantly been applied to microeconomic issues, there have been influences on macroeconomics as well. A first path through which EGT has impacted macroeconomics has been via heterogeneous agent models in finance that study speculative dynamics in asset markets driven by competing trading strategies (see Dieci and He (2018) for a review). Franke and Westerhoff (2017) review approaches that introduce these behavioural dynamics into macroeconomics. A second path has been via models of dynamic competition in evolutionary economics (e.g. Metcalfe (1994)), elements of which have fed into macroeconomic agent-based models (Dosi, Fagiolo, and Roventini (2010)).↩︎\nSection 2.6 explains how continuous time models can be solved numerically.↩︎\nThe model from Bowles (2004), chapter 11, has subsequently been developed further and supplemented with empirical evidence in Bowles and Choi (2013) and Bowles and Choi (2019).↩︎\nFiner grids are possible but will increase computation time.↩︎\n Bowles (2004), pp. 386-390, discusses the issue of equilibrium selection in more detail and considers some mechanisms that would make the Rousseauian equilibrium more robust.↩︎\nWe focus on the Hobbesian and Rousseauian equilibria and disregard the less interesting equilibria \\(\\alpha^*=1\\) and \\(\\gamma^*=1\\).↩︎\nSince we have \\(\\alpha+\\gamma=1\\), \\(\\alpha\\) is independent of \\(\\beta\\), so that \\(\\frac{\\partial \\beta}{\\partial \\alpha} = 0\\).↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>An Evolutionary Game Theoretic Model of the Emergence of Property Rights</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html",
    "href": "an_sfc_model.html",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "",
    "text": "Overview\nThe stock-flow consistent (SFC) approach to macroeconomic modelling has become increasingly prominent since the 2006 publication of the foundational book Monetary Economics by Wynne Godley and Marc Lavoie.1 The SFC approach integrates the real and financial side of the economy, i.e. the physical production and consumption of goods and services, and the financial flows that arise in the course of production, consumption, and investment. As the name suggests, an SFC model covers both flows (over a certain period of time) and stocks (at a particular point in time), which are embedded in a consistent and fully coherent accounting framework. SFC models typically comprise multiple aggregate sectors, such as a household sector, a firm sector, a banking sector, a central bank, and a government. Each of these sectors makes spending and financing decisions subject to budget constraints, giving rise to physical and financial flows across sectors, which lead to changes in physical and financial stocks over time. To ensure consistent accounting, four key principles are applied:\nThese principles are usually applied by means of two matrices that summarise the accounting structure of an SFC model: a balance sheet matrix (for stocks) and a transactions flow matrix (for flows and changes in stocks). These matrices provide a first set of equations that enter an SFC model to ensure accounting consistency. Accounting equations are then complemented by behavioural equations and equilibrium conditions that add causal assumptions to the accounting structure. Most SFC models draw on (post-)Keynesian macroeconomic theory when it comes to the behavioural assumptions. Correspondingly, most SFC models assume that economic activity is demand-determined, that households follow simple behavioural rules when making consumption decision (such as a constant marginal propensity to consume out of income), that firms operate in oligopolistic markets where they set prices based on a markup on unit cost, and that actors in financial markets make financial investment decisions based on relative rates of return. Another key feature is money endogeneity: money is created when commercial banks make loans to accommodate the demand for credit by (creditworthy) borrowers (see also Chapter 6). Like aggregate output, the stock of money is thus an endogenous variable that responds to the spending decisions of economic actors (both private and public).\nThe SFC approach shares a strong affinity with monetary circuit theory, which featured prominently in the work of the Italian economist Augusto Graziani (2003) and has inspired a ‘circuitist’ school within monetary economics. The key idea of the theory of the monetary circuit, following chapter 1 of Graziani (2003), is that money is credit money, which is created whenever an agent spends money granted by a bank and is destroyed when bank credit is repaid. The stock of money is thus an endogenous variable. The monetary circuit starts by the creation of new credit money to finance production (called ‘initial finance’). Credit money is then used to hire workers and pay wages. Production and sale take place, firms make revenues. Firms may additionally raise funds from households by selling securities (called ‘final finance’). Lastly, firms repay their debts whereby credit money is destroyed. Thus, according to the theory of the monetary circuit, a key role of credit money is to bridge the gap between production (which involves expenses for firms) and sales (which generate income for firms). Money must be a flexible, endogenous variable to fulfil this role. While the SFC approach and the theory of the monetary circuit were largely developed independently, Godley and Lavoie (2006), chapter 2.6, note a strong overlap between the two approaches.\nIn this section, we present a modified version of the model in Godley (2012), which aims to provide a formalisation of the monetary circuit.2 The Godley (2012) model features a household, firm, and banking sector (central bank and government are omitted for simplicity). Firms can take out loans from banks to finance production. Households receive income from labour and distributed profits, which they can spend on consumption or save in the form of bank deposits. For simplicity, there is no investment in physical capital, but firms maintain a stock of inventories to be able to accommodate demand. The model in this section exhibits a number of differences to the model in Godley (2012): first, for simplicity, prices are assumed to be fixed (firms charge a fixed markup on fixed nominal unit labour cost); second, to capture the Keynesian idea of fundamental uncertainty, we assume that firms do not know future sales and instead form expectations based on an adaptive heuristic;3 third, we introduce a corporate bond market with endogenous prices to capture the idea of ‘final finance’ providing a source of funds for firms beyond revenues from sales for the repayment of credit. Taken together, the model highlights the process by which production is financed, the idea of endogenous expenditure-driven money creation, and price determination in financial markets.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#overview",
    "href": "an_sfc_model.html#overview",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "",
    "text": "Flow consistency: every transaction comes from somewhere and goes somewhere,\nStock consistency: every financial asset is also a financial liability,\nStock-flow consistency: flows accumulate into stocks,\nQuadruple entry book-keeping: every transaction involves a quadruple entry in accounting – two for each party of the transaction.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#the-balance-sheet-and-transaction-flows-matrices",
    "href": "an_sfc_model.html#the-balance-sheet-and-transaction-flows-matrices",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "The balance sheet and transaction flows matrices",
    "text": "The balance sheet and transaction flows matrices\nThe balance sheet matrix (BSM) records the distribution of physical and financial stocks across sectors. Assets carry a positive and liabilities a negative sign. The present model has three financial stocks: deposits, loans, and (corporate) bonds. The only physical asset are firms’ inventories. Stock consistency requires each row containing financial stocks to sum to zero. The columns of the BSM constitute the wealth constraints of the sectors, with the last row of each column representing the sector’s net wealth (assets minus liabilities). Since net financial wealth cancels out in the aggregate, the total net wealth is equal to the value of physical assets (inventories in this case).\nIn this model, households can save either in the form of deposits or corporate bonds. Firms can borrow either in the form of loans or bonds. Banks make loans to firms and issue deposits. From the BSM, it follows that \\(M=L\\), i.e. the stock of loans is equal to the stock of money. This illustrates at an elementary level, before having made any behavioural assumptions, the tight relationship between money and credit emphasised in both the SFC and monetary circuit approaches.\nTable 1: Balance Sheet Matrix\n\n\n\n\n\n\n\n\n\n\nHouseholds\nFirms\nBanks\n∑\n\n\n\nInventories\n\n\\(+IN\\)\n\n\\(+IN\\)\n\n\nDeposits\n\\(+M\\)\n\n\\(–M\\)\n0\n\n\nLoans\n\n\\(–L\\)\n\\(+L\\)\n0\n\n\nBonds\n\\(+p^B B\\)\n\\(–p^B B\\)\n\n0\n\n\n∑ (Net wealth)\n\\(V_H\\)\n\\(V_F = IN – L – p^B B\\)\n0\n\\(+IN\\)\n\n\n\nThe transactions flow matrix (TFM) records flows across sectors. Sources of funds are denoted with a plus sign, and uses of funds with a minus sign. The TFM’s rows can be categorised into three groups. The first set of rows captures expenditures flows that make up total production (GDP): consumption and inventory investment. The second set of rows captures the corresponding income flows: wages and net profits plus financial income streams (interest payments/income on the three financial stocks in our case). The third set of rows reports changes in financial stocks that result from the difference between income and expenditure for each sector. Flow consistency across sectors requires each row to sum to zero. In addition, each sector needs to respect its budget constraint given by its column, which must also sum to zero. In our model, prices of corporate bonds may change endogenously; thus, there is a separate row at the bottom of the TFM reporting capital gains. The account of the corporate sector is split into a current and a capital account. This division makes explicit transactions taking place within the corporate sector. For example, inventory accumulation is an income for the firm sector (reported in the current account), but also an expenditure (reported in the capital account).\nTable 2: Transactions Flow Matrix\n\n\n\n\n\n\n\n\n\n\n\nHouseholds\nFirms (Current)\nFirms (Capital)\nBanks\n∑\n\n\n\nConsumption\n\\(–C\\)\n\\(+C\\)\n\n\n0\n\n\nInventory investment\n\n\\(+\\Delta IN\\)\n\\(– \\Delta IN\\)\n\n0\n\n\nWages\n\\(+W\\)\n\\(–W\\)\n\n\n0\n\n\nNet profits\n\\(+\\Pi\\)\n\\(–\\Pi\\)\n\n\n0\n\n\nInterest on deposits\n\\(+i_M M\\)\n\n\n\\(–i_M M\\)\n0\n\n\nInterest on loans\n\n\\(–i_L L\\)\n\n\\(+i_L L\\)\n0\n\n\nInterest on bonds\n\\(+i_B B\\)\n\\(–i_B B\\)\n\n\n0\n\n\nChange in deposits\n\\(–\\Delta M\\)\n\n\n\\(+ \\Delta M\\)\n0\n\n\nChange in loans\n\n\\(+\\Delta L\\)\n\n\\(– \\Delta L\\)\n0\n\n\nChange in bonds\n\\(–\\Delta B p^B\\)\n\n\\(+ \\Delta B p^B\\)\n\n0\n\n\n∑\n0\n0\n0\n0\n0\n\n\nCapital gains\n\\(–\\Delta p^B B\\)\n\n\\(+ \\Delta p^B B\\)\n\n\n\n\n\nIn this model, total output/income \\(Y\\) is composed of expenditures on consumption and inventories, which is equal to wages plus gross profits:\n\\[\n  Y=C +\\Delta IN = W + \\Pi + i_LL + i_bB.\n\\] The sectoral budget constraints are key to understand the financing decisions of each sectors. Starting with households, we know from the BSM that their net wealth consists of deposits and bonds: \\(V_H=M+p^BB\\). Thus, the change in their net wealth is given by \\(\\Delta V_H=\\Delta M +\\Delta Bp + \\Delta pB\\), where \\(\\Delta p^B B\\) represents capital gains on bonds. Using the output equation and the first column of the BSM, we have:\n\\[\n\\Delta V_H = Y - C + \\Delta pB,\n\\]\nwhere \\(Y-C=\\Delta M + \\Delta B\\), meaning that households can save either in the form of money or bonds, and that their total change in wealth is given by saving in those assets plus capital gains. Note that we assume that all net profits are distributed to the household sector.\nFrom the capital account column of the TFM, we obtain the budget constraint of the firm sector:\n\\[\n\\Delta L + p^B \\Delta B = \\Delta IN,\n\\] which tells us that expenditures on inventories can be covered either by taking out loans or by issuing corporate bonds.\nWe will use these fundamental accounting relationships in the model equations below to ensure stock-flow consistency.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#the-model",
    "href": "an_sfc_model.html#the-model",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "The model",
    "text": "The model\nHouseholds \\[\nC_t = \\alpha_0 + \\alpha_1 Y_t + \\alpha_2 V_{Ht-1}\n\\tag{20.1}\\]\n\\[\nW_t = \\frac{wY_t}{\\delta}\n\\tag{20.2}\\]\n\\[\n\\Pi_t=C_t - W_t - i_L L_{t-1} - i_B B_{t-1} + IN_t - IN_{t-1}\n\\tag{20.3}\\]\n\\[\nV_{Ht} = V_{Ht-1} + Y_t - C_t + (p^B_t - p^B_{t-1})B_t\n\\tag{20.4}\\] \\[\nM_t= V_{Ht} - p^BB_t\n\\tag{20.5}\\]\nFirms \\[\nY_t = C_t^e + IN^T_t - IN_{t-1}\n\\tag{20.6}\\]\n\\[\nIN^T_t = \\sigma C_t^e\n\\tag{20.7}\\]\n\\[\nC^e_t = C^e_{t-1} + \\gamma(IN^T_{t-1} - IN_{t-1})\n\\tag{20.8}\\]\n\\[\nIN_t = IN_{t-1} + Y_t - C_t\n\\tag{20.9}\\]\n\\[\nB_t = \\frac{\\beta IN_{t-1}}{p^B_t}\n\\tag{20.10}\\]\n\\[\ni_B = \\rho + i_L\n\\tag{20.11}\\]\n\\[\nL_t = L_{t-1} + IN_t - IN_{t-1} - p^B_t(B_t - B_{t-1})\n\\tag{20.12}\\]\nBanks \\[\ni_L = i_M\n\\tag{20.13}\\]\nBond market \\[\np^B_t = \\frac{i_B \\lambda_2}{\\beta \\frac{IN_{t-1}}{V_{Ht-1}} - \\lambda_0 + \\lambda_1 i_M + \\lambda_3 \\frac{Y_{t-1}}{V_{Ht-1}}}\n\\tag{20.14}\\]\nwhere stocks, flows, interest rates, and bond prices are defined as in Tables 1 and 2 above, and \\(C^e_t\\) and \\(IN^T_t\\) represent expected consumption (= expected sales) and the target stock of inventories, respectively.\nEquation 20.1 is the consumption function – one of the model’s key behavioural equations. It assumes that consumption is a function of current income \\(Y_t\\), previous period’s household wealth \\(V_{Ht-1}\\), and an autonomous component \\(\\alpha_0\\), with fixed marginal propensities, \\(\\alpha_1\\) and \\(\\alpha_2\\), to consume out of income and wealth. Equation 20.2 specifies the determination of the aggregate wage bill, a component of household income. The nominal wage rate \\(w\\) is assumed to be fixed, while total employment \\(N\\) is determined in a Keynesian fashion by total output in conjunction with a given level of labour productivity \\(\\delta=\\frac{Y}{N}\\), i.e. \\(N=\\frac{Y}{\\delta}\\).4 Equation 20.3 defines profits (derived from the firms’ current account column of the TFM), which are fully distributed to the household sector. Note that in the definition of profits, inventory investment is recorded as a source of income for firms, i.e. they are treated as if they had been sold. Equation 20.4 specifies wealth dynamics of households as derived in the previous section from the first column of the TFM. Equation 20.5 represents the wealth constraint of households (the first column of the BSM), where it is assumed that deposits \\(M\\) act as the residual: households allocate their wealth they don’t want to hold in the form of bonds into deposits.\nMoving on to firms, Equation 20.6 specifies their production decisions. Firms produce output to meet expected sales (= expected consumption \\(C_t^e\\)) and to hit their target stock of inventories \\(IN^T_t\\). By Equation 20.7, they aim to maintain a fixed ratio \\(\\sigma\\) of inventories to expected sales – a simple heuristic to deal with the intrinsic uncertainty over realised sales. In the same vein, Equation 20.8 constitutes a simple adaptive rule to update sales expectations based on past deviations of actual inventories from target. If, for example, actual inventories exceeded target inventories due to a slump in sales, the term in brackets in Equation 20.8 will be negative. Firms take this as a sign of weak demand, which they extrapolate into the future and thus reduce their sales expectations. Equation 20.9 is an accounting identity derived from TFM in the previous section and states that inventories accumulate whenever production exceeds sales. Observe that Equation 20.6 and Equation 20.9 can be combined to give \\(IN_t - IN_t^T = C_t^E - C_t\\), showing that expectational errors on the side of firms give rise to deviations of the actual stock of inventories from target.\nThe next three equations specify the financial decisions of firms. By Equation 20.10, firms finance a fixed share \\(\\beta\\) of their inventories through bond issuance (where bonds are measured at market value). The parameter \\(\\beta\\) thus captures the liability management of firms. Firms also set a fixed interest rate (or ‘coupon rate’) on bonds \\(i_B\\) (Equation 20.11), using a fixed markup or premium \\(\\rho\\) on the lending rate \\(i_L\\). Equation 20.12 represents firms’ budget constraint as derived from the TFM. With bond issuance pinned down behaviourally by Equation 20.10, loan issuance becomes the residual item of the firm sector’s budget constraint, ensuring that any expenditures on inventories that are not financed by bond issuance are covered by loans.\nThe banking sector in this model is kept very simple. Banks make loans and issue deposits. They charge the same rate on loans \\(i_L\\) as they pay on deposits \\(i_M\\) (Equation 20.13), implying that they don’t make any profits.\nFinally, equation Equation 20.14 represents the determination of corporate bond prices on financial markets. This equation is derived from the portfolio choice decisions of households, where it is assumed that households’ desired share of bonds (at market value) in their total wealth is a function of rates of return as well as household income. Specifically, the underlying portfolio equation is:\n\\[\n\\frac{p^B_tB^D_t}{V_{Ht-1}} = \\lambda_0 - \\lambda_1 i_M + \\lambda_2 \\frac{i_B}{p^B_t} - \\lambda_3 \\frac{Y_t}{V_{Ht-1}}.\n\\] The term \\(\\lambda_0\\) represents autonomous demand for bonds (which is inversely related to liquidity preference, i.e. the autonomous demand for deposits) and the negative term \\(\\lambda_1 i_M\\) captures the foregone returns from holding deposits instead of bonds. The term \\(\\lambda_2 \\frac{i_B}{p^B_t}\\) captures the positive effect of bond yields on bond demand. Note that we assume a fixed face value (or ‘par value’) of bonds of unity, so that the coupon rate coincides with the interest payments on the bond. Thus, \\(\\frac{i_B}{p^B_t}\\) is the yield on corporate bonds, which is inversely related to bond prices. The last term in the bond demand equation represents the negative effect of income (relative to wealth) on bond demand, which stems from the transactions demand for deposit money. Using this equation for the bond demand of households with the bond supply of firms given by Equation 20.10, imposing equilibrium, and solving for \\(p^B_t\\) gives Equation 20.14.\nWith 14 equations, this comparatively simple model illustrates a common feature of SFC models: the number of equations is typically large. Two points are worth noting in this regard. First, our representation of the model is already relatively parsimonious in that it focuses on the equations that are used in the simulation. For example, Equation 20.14 has been derived from underlying equations about portfolio choice and an equilibrium condition that we did not list above. Similarly, we did not add to the list of equations some relatively trivial facts, e.g. that sales are equal to consumption expenditures, or chose not to track certain variables such as total employment, prices, and the wage share. One could add these equations if one wanted to make some of these assumptions or implied results more explicit. Second, and more importantly, several of the model’s accounting equations are actually irrelevant for its results. Specifically, out of the five accounting equations (Equation 20.3, Equation 20.4, Equation 20.5, Equation 20.9, Equation 20.12) only two, the equations for household wealth and inventory accumulation (Equation 20.4 and Equation 20.9) feed into the model’s dynamics via their impact on consumption and production, respectively. By contrast, the equations for profits (Equation 20.3), household deposits (Equation 20.5), and loans (Equation 20.12) are residuals that ensure accounting consistency, but do not impact the other variables of the model, and can therefore be dropped. Thus, while SFC models often appear very large, this is partly a presentational feature stemming from the ambition to make all assumptions (both structural and accounting) explicit. It is useful to bear in mind that the actual core of a model generating its results might be much smaller.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#simulation",
    "href": "an_sfc_model.html#simulation",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "Simulation",
    "text": "Simulation\nParameterisation\nTables 3a and 3b report the parameterisation used in the simulation. In each scenario, we initialise the model in the steady state and assess the effect of (permanent) shifts in a parameter from a certain period onwards. The first scenario is an increase in autonomous consumption demand (\\(\\alpha_0\\)). The second scenario is a rise in the share of inventories \\(\\beta\\) that is financed by bonds. Scenario 3 is a rise in the autonomous demand for bonds by households (\\(\\lambda_0\\)). Finally, scenario 4 considers a rise in the corporate bond premium \\(\\rho\\) offered by firms.\nTable 3a: Parameterisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScenario\n\\(\\alpha_0\\)\n\\(\\alpha_1\\)\n\\(\\alpha_2\\)\n\\(w\\)\n\\(\\delta\\)\n\\(\\sigma\\)\n\\(\\gamma\\)\n\\(\\beta\\)\n\\(\\rho\\)\n\\(i_M\\)\n\n\n\n1: aggregate demand boost (\\(\\alpha_0\\))\n1.1\n0.8\n0.2\n1\n2\n0.3\n1\n0.05\n0.03\n0.01\n\n\n2: rise in share bond-financed inventories (\\(\\beta\\))\n1\n0.8\n0.2\n1\n2\n0.3\n1\n0.1\n0.03\n0.01\n\n\n3: rise in autonomous demand for bonds (\\(\\lambda_0\\))\n1\n0.8\n0.2\n1\n2\n0.3\n1\n0.05\n0.03\n0.01\n\n\n4: rise in corporate bond premium (\\(\\rho\\))\n1\n0.8\n0.2\n1\n2\n0.3\n1\n0.05\n0.04\n0.01\n\n\n\nTable 3b: Parameterisation (continued)\n\n\n\n\n\n\n\n\n\nScenario\n\\(\\lambda_0\\)\n\\(\\lambda_1\\)\n\\(\\lambda_2\\)\n\\(\\lambda_3\\)\n\n\n\n1: aggregate demand boost (\\(\\alpha_0\\))\n0.2\n0.9\n0.3\n0.1\n\n\n2: rise in share bond-financed inventories (\\(\\beta\\))\n0.2\n0.9\n0.3\n0.1\n\n\n3: rise in autonomous demand for bonds (\\(\\lambda_0\\))\n0.3\n0.9\n0.3\n0.1\n\n\n4: rise in corporate bond premium (\\(\\rho\\))\n0.2\n0.9\n0.3\n0.1\n\n\nSimulation code\n\n# Clear the environment\nrm(list=ls(all=TRUE))\n\n# Set number of periods\nQ=300\n\n# Set number of scenarios\nS=4\n\n# Set period in which shock/shift will occur\ns=10\n\n# Create (S x Q)-matrices that will contain the simulated data\nY=matrix(data=1,nrow=S,ncol=Q)    # income/output\nIN=matrix(data=1,nrow=S,ncol=Q)   # inventories \nIN_T=matrix(data=1,nrow=S,ncol=Q) # target inventories \nC=matrix(data=1,nrow=S,ncol=Q)    # consumption (= sales)\nW=matrix(data=1,nrow=S,ncol=Q)   # wage bill \nC_E=matrix(data=1,nrow=S,ncol=Q)  # expected consumption (= expected sales)\nPi=matrix(data=1,nrow=S,ncol=Q)   # net profits\nB=matrix(data=1,nrow=S,ncol=Q)    # bonds\nM=matrix(data=1,nrow=S,ncol=Q)    # deposits\nL=matrix(data=1,nrow=S,ncol=Q)    # loans\nYD=matrix(data=1,nrow=S,ncol=Q)   # disposable income\nV_H=matrix(data=1,nrow=S,ncol=Q)  # household wealth         \np_B=matrix(data=1,nrow=S,ncol=Q)  # prices of bonds                    \ni_B=matrix(data=0.1,nrow=S,ncol=Q)# interest rate on bonds\n\n# Set constant parameter values\nsigma=0.3   # inventories to sales ratio\ngamma=1     # adjustment speed of sales expectations\ni_L=i_M=0.01# loan rate = deposit rate\nalpha_1=0.8 # propensity to consume out of income\nalpha_2=0.2 # propensity to consume out of wealth\nlambda_1=0.9# sensitivity of bond demand to deposit rate\nlambda_2=0.3# sensitivity of bond demand to return on bonds\nlambda_3=0.1# sensitivity of bond demand to disposable income \nw=1         # nominal wage rate\ndelta=2     # productivity\n\n# Create matrices for parameters that will change in scenarios\nalpha_0=matrix(data=1,nrow=S,ncol=Q)    # autonomous consumption\nlambda_0=matrix(data=0.2,nrow=S,ncol=Q) # autonomous demand for bonds\nrho=matrix(data=0.03,nrow=S,ncol=Q)     # premium on corporate bond rate \nbeta=matrix(data=0.05,nrow=S,ncol=Q)    # share of inventories financed by bonds\n\n# Create scenarios\nalpha_0[1, s:Q]=1.1    # scenario 1: aggregate demand boost\nbeta[2, s:Q]=0.1       # scenario 2: rise in share of inventories financed by bonds\nlambda_0[3, s:Q]=0.3   # scenario 3: rise in autonomous demand for bonds\nrho[4, s:Q]=0.04       # scenario 4: rise in corporate bond premium\n\n# Initialise variables in equilibrium\nfor (iteration in 1:200){\ni_B[,1]=rho[,1]+i_M\nW[,1]=w*Y[,1]/delta\nM[,1]=L[,1]=1 \nV_H[,1]=M[,1]+p_B[,1]*B[,1]\nYD[,1]=Y[,1]=(alpha_0[,1] + alpha_2*V_H[,1])/(1-alpha_1)\nIN[,1]=IN_T[,1]=sigma*Y[,1]\nC[,1]=C_E[,1]=Y[,1]\np_B[,1]=(i_B[,1]*lambda_2)/((beta[,1]*sigma+lambda_3)*(alpha_0[,1]+alpha_2*V_H[,1])/(V_H[,1]*(1-alpha_1))-(lambda_0[,1]-lambda_1*i_M))\nPi[,1]=C[,1] - W[,1] - i_L*L[,1] - i_B[,1]*B[,1]\nB[,1]=beta[,1]*IN[,1]/p_B[,1]\n}\n\n# Simulate the model by looping over Q time periods for S different scenarios\nfor (i in 1:S){\n  \n  for (t in 2:Q){\n    \n    for (iterations in 1:200){\n    \n    # (1) Consumption\n    C[i,t] = alpha_0[i,t] + alpha_1*Y[i,t] + alpha_2*V_H[i,t-1]\n    \n    # (2) Wage bill\n    W[i,t] = w*Y[i,t]/delta\n    \n    # (3) Profits\n    Pi[i,t] = C[i,t] - W[i,t] - i_L*L[i,t-1] - i_B[i,t-1]*B[i,t-1] + IN[i,t] - IN[i,t-1]\n    \n    # (4) Household wealth\n    V_H[i,t] = V_H[i,t-1] + Y[i,t] - C[i,t] + (p_B[i,t]-p_B[i,t-1])*B[i,t-1]\n    \n    # (5) Household deposits\n    M[i,t] = V_H[i,t] - p_B[i,t]*B[i,t]\n    \n    # (6) Production\n    Y[i,t] = C_E[i,t] + IN_T[i,t] - IN[i,t-1]\n    \n    # (7) Target inventories\n    IN_T[i,t] = sigma*C_E[i,t]\n    \n    # (8) Expected consumption (= expected sales)\n    C_E[i,t] = C_E[i,t-1] + gamma*(IN_T[i,t-1] - IN[i,t-1])\n    \n    # (9) Inventories\n    IN[i,t] = IN[i,t-1] + Y[i,t]- C[i,t]\n    \n    # (10) Bond supply \n    B[i,t] =  beta[i,t]*IN[i,t-1]/p_B[i,t]\n    \n    # (11) Rate on corporate bonds\n    i_B[i,t]=rho[i,t] + i_L\n    \n    # (12) Loans\n    L[i,t] = L[i,t-1] + IN[i,t] - IN[i,t-1] - p_B[i,t]*(B[i,t] - B[i,t-1])\n\n    # (13) i_L = i_M (omitted from simulation because fixed)\n    \n    # (14) Bond prices\n    p_B[i,t] = (i_B[i,t]*lambda_2)/(beta[i,t]*(IN[i,t-1]/V_H[i,t-1])-lambda_0[i,t]+lambda_1*i_M+lambda_3*(Y[i,t-1]/V_H[i,t-1]))\n    \n    } # close iterations loop\n  } # close time loop\n}   # close scenarios loop\n\n# Compute business wealth\nV_F = IN - L - p_B*B\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\nimport numpy as np\n\n\n\n\nChecking stock-flow consistency\nBefore plotting the simulation results for the different scenarios, we perform a stock-flow consistency check by computing the BSM and TFM from the simulated data. To this end, we construct two functions that compute the corresponding matrices for any chosen period and scenario. Let’s start with the BSM and print the results for the first and last period of the first scenario.\n\n#### Define function to create balance sheet matrices (BSM)\nbsm = function(t, scen) {\n  \n    # Pull data from selected period and scenario\n    data = list(\n     M    = M[scen, t],\n     B    = B[scen, t],\n     L    = L[scen, t],\n     IN   = IN[scen, t],\n     p_B  = p_B[scen, t],\n     V_H  = V_H[scen, t],\n     V_F  = V_F[scen, t]\n   )\n  \n  # Households column\n  households=c(\n    \"\",                                # inventories \n    sprintf(\"+%.2f\",data$M),           # deposits\n    \"\",                                # loans\n    sprintf(\"+%.2f\",data$p_B*data$B),  # bonds\n    sprintf(\"+%.2f\",data$V_H)          # net worth\n  )\n  \n  # Firms column\n  firms=c(\n    sprintf(\"+%.2f\", data$IN),         # inventories \n    \"\",                                # deposits\n    sprintf(\"-%.2f\", data$L),          # loans\n    sprintf(\"-%.2f\", data$p_B*data$B), # bonds\n    sprintf(\"%.2f\", data$V_F)          # net worth \n  )\n  \n  # Banks column\n  banks=c(\n    \"\",                                # inventories \n    sprintf(\"-%.2f\", data$M),          # deposits\n    sprintf(\"+%.2f\", data$L),          # loans\n    \"\",                                # loans\n    sprintf(\"%.2f\", data$M - data$L)   # net worth\n  )\n  \n  # Summation column\n  sum_col = c(\n    sprintf(\"+%.2f\", data$IN),\n    \"0\", \"0\", \"0\",\n    sprintf(\"+%.2f\", data$V_H+data$V_F)\n  )\n  \n  # Combine columns to a matrix\n  bsm=cbind(\n    Households = households,\n    Firms = firms,\n    Banks = banks,\n    `∑` = sum_col\n  )\n  \n  # Assign rownames\n  rownames(bsm) = c(\"Inventories\", \"Deposits\", \"Loans\", \"Bonds\", \"∑\") \n  \n  return(bsm)\n}\n\n\n# Print BSM of first scenario for first period \nprint(bsm(t=1, scen=1), quote = FALSE, right = TRUE)\n\n            Households Firms Banks     ∑\nInventories            +1.83       +1.83\nDeposits         +1.00       -1.00     0\nLoans                  -1.00 +1.00     0\nBonds            +0.09 -0.09           0\n∑                +1.09  0.74  0.00 +1.83\n\n# Print BSM of first scenario for last period\nprint(bsm(t=Q, scen=1), quote = FALSE, right = TRUE)\n\n            Households Firms Banks     ∑\nInventories            +2.05       +2.05\nDeposits         +1.23       -1.23     0\nLoans                  -1.23 +1.23     0\nBonds            +0.10 -0.10           0\n∑                +1.33  0.72 -0.00 +2.05\n\n\nIt can be seen that the last row and last column sum to the same value, reflecting stock consistency.\nNow we do the same thing for the TFM (note that we need to use the second period instead of the first, as the TFM contains flows).\n\n#### Define function to create transactions flow matrices (TFM)\ntfm=function(t, scen){\n\n  # Pull data from selected period and scenario\n  data = list(\n   C = C[scen,t],\n   W = W[scen,t],\n   Pi = Pi[scen,t],\n   M = M[scen,t-1],\n   L = L[scen,t-1],\n   B = B[scen,t-1],\n   i_B = i_B[scen,t-1],\n   dM = M[scen,t]-M[scen,(t-1)],\n   dL = L[scen,t]-L[scen,(t-1)],\n   dB = p_B[scen,t]*(B[scen,t]-B[scen,(t-1)]),\n   dIN = IN[scen,t]-IN[scen,(t-1)],\n   dp_B = B[scen,(t-1)]*(p_B[scen,t]-p_B[scen,(t-1)])\n )\n\n  # Households column\n households=c(\n   sprintf(\"-%.2f\", data$C),         # consumption\n   \"\",                               # change in inventories\n   sprintf(\"+%.2f\", data$W),         # wages\n   sprintf(\"+%.2f\", data$Pi),        # net profits\n   sprintf(\"+%.2f\", i_M*data$M),     # interest on deposits\n   \"\",                               # interest on loans\n   sprintf(\"+%.2f\", data$i_B*data$B),# interest on bonds\n   sprintf(\"-%.2f\", data$dM),        # change in deposits\n   \"\",                               # change in loans\n   sprintf(\"-%.2f\", data$dB),        # change in bonds\n   sprintf(\"%.2f\",-data$C+data$W+data$Pi+i_M*data$M+data$i_B*data$B-data$dM-data$dB), # sum \n   sprintf(\"-%.2f\", data$dp_B)       # capital gains\n )\n \n # Firms current account column\n firms_current=c(\n   sprintf(\"+%.2f\", data$C),         # consumption\n   sprintf(\"+%.2f\", data$dIN),       # change in inventories\n   sprintf(\"-%.2f\", data$W),         # wages\n   sprintf(\"-%.2f\", data$Pi),        # net profits\n   \"\",                               # interest on deposits\n   sprintf(\"-%.2f\", i_L*data$L),     # interest on loans\n   sprintf(\"-%.2f\", data$i_B*data$B),# interest on bonds\n   \"\", \"\", \"\",                       # change in deposits/loans/bonds\n   sprintf(\"%.2f\", data$C+data$dIN-data$W-data$Pi-i_L*data$L-data$i_B*data$B), # sum\n   \"\"                                # capital gains\n )\n \n # Firms capital account column\n firms_capital=c(\n   \"\",                            # consumption\n   sprintf(\"-%.2f\", data$dIN),    # change in inventories\n   \"\", \"\", \"\", \"\", \"\", \"\",        # wages/profits/interest payments/change in deposits\n   sprintf(\"+%.2f\", data$dL),     # change in loans\n   sprintf(\"+%.2f\", data$dB),     # change in bonds\n   sprintf(\"%.2f\", -data$dIN+data$dL+data$dB),# sum\n   sprintf(\"+%.2f\", data$dp_B)    # capital gains\n ) \n \n # Banks column\n banks=c( \n   \"\", \"\", \"\", \"\",                   # consumption/inventories/wages/profits\n   sprintf(\"-%.2f\", i_M*data$M),     # interest on deposits\n   sprintf(\"+%.2f\", i_L*data$L),     # interest on loans\n   \"\",                               # interest on bonds\n   sprintf(\"+%.2f\", data$dM),        # change in deposits\n   sprintf(\"-%.2f\", data$dL),        # change in loans\n   \"\",                               # change in bonds \n   sprintf(\"%.2f\", -i_M*data$M+i_L*data$L+data$dM-data$dL), # sum\n   \"\"                                # capital gains\n )\n \n # Summation column\n sum_col=c(rep(\"0\", 12))\n \n # Combine columns to a matrix\n tfm=cbind(\n   Households     = households,\n   `Firms (Cur)` = firms_current,\n   `Firms (Cap)` = firms_capital,\n   Banks          = banks,\n   `∑`            = sum_col\n )\n \n # Assign rownames\n rownames(tfm)=c(\n   \"Consumption\", \"Change in inventories\", \"Wages\", \"Net profits\",\n   \"Interest on deposits\", \"Interest on loans\", \"Interest on bonds\",\n   \"Change in deposits\", \"Change in loans\", \"Change in bonds\",\n   \"∑\", \"Capital gains\"\n )\n \n return(tfm)\n}\n\n\n# Print TFM of first scenario for second period\nprint(tfm(t=2, scen=1), quote = FALSE, right = TRUE)\n\n                      Households Firms (Cur) Firms (Cap) Banks ∑\nConsumption                -6.09       +6.09                   0\nChange in inventories                  +0.00       -0.00       0\nWages                      +3.05       -3.05                   0\nNet profits                +2.90       -2.90                   0\nInterest on deposits       +0.01                         -0.01 0\nInterest on loans                      -0.01             +0.01 0\nInterest on bonds          +0.14       -0.14                   0\nChange in deposits         -0.00                         +0.00 0\nChange in loans                                    +0.00 -0.00 0\nChange in bonds            -0.00                   +0.00       0\n∑                          -0.00       -0.00        0.00  0.00 0\nCapital gains             --0.00                  +-0.00       0\n\n# Print TFM of first scenario for last period\nprint(tfm(t=Q, scen=1), quote = FALSE, right = TRUE)\n\n                      Households Firms (Cur) Firms (Cap) Banks ∑\nConsumption                -6.83       +6.83                   0\nChange in inventories                  +0.00       -0.00       0\nWages                      +3.41       -3.41                   0\nNet profits                +3.27       -3.27                   0\nInterest on deposits       +0.01                         -0.01 0\nInterest on loans                      -0.01             +0.01 0\nInterest on bonds          +0.14       -0.14                   0\nChange in deposits         -0.00                         +0.00 0\nChange in loans                                    +0.00 -0.00 0\nChange in bonds            -0.00                   +0.00       0\n∑                           0.00       -0.00        0.00  0.00 0\nCapital gains              -0.00                   +0.00       0\n\n\nThe fact that all column sum to zero affirms flow consistency.\nPlots\nFigure 20.1 to Figure 20.5 display the behaviour of several of the model’s key variables during the four scenarios listed in Table 3. The first scenario represents a boost to aggregate demand stemming from an increase in autonomous consumption demand (\\(\\alpha_0\\)). Due to the Keynesian nature of the model, the increase in aggregate demand translates into an increase in aggregate output. The adjustment to the new equilibrium is cyclical: with uncertainty over future sales, firms use the information embodied in past deviations of actual investments from target to form expectations about future sales (see Equation 20.8). This (imperfect) approach leads to a (temporary) over- and then undershooting of production along the adjustment path. The increase in production leads to a greater demand for loans (to finance inventories), which directly translates into an increase in the money stock – reflecting the principle of endogenous money. The effects of the aggregate-demand boost on the corporate bond market are slightly less intuitive. The price of bonds increases, which through further inspection can be attributed to a fall in the household income-to-wealth ratio, which reduces the transactions demand for deposit money and increases the demand for bonds.\n\n# Set maximum period for plots\nTmin=1\nTmax=100\n\n# Output under different scenarios\nplot(Y[1, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylim=(range(Y[,Tmin:Tmax])), xlim=c(Tmin,Tmax), ylab=\"Y\") \ntitle(main=\"\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(Y[2, 1:Q],lty=2, lwd=2)\nlines(Y[3, 1:Q],lty=3, lwd=2)\nlines(Y[4, 1:Q],lty=4, lwd=2)\nlegend(\"right\", legend=c(\"1: AD boost\", \"2: rise in bond finance\", \"3: rise bond demand\", \"4: rise bond premium\"), \n       lty=1:4, cex=0.8, bty = \"n\", y.intersp=1)\n\n\n\n\n\n\nFigure 20.1: Output\n\n\n\n\n\n#Money (=loans) under different scenarios\nplot(M[1, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylim=(range(M[,Tmin:Tmax])), xlim=c(Tmin,Tmax), ylab=\"M=L\") \ntitle(main=\"\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(M[2, 1:Q],lty=2, lwd=2)\nlines(M[3, 1:Q],lty=3, lwd=2)\nlines(M[4, 1:Q],lty=4, lwd=2)\nlegend(\"right\", legend=c(\"1: AD boost\", \"2: rise in bond finance\", \"3: rise bond demand\", \"4: rise bond premium\"), \n       lty=1:4, cex=0.8, bty = \"n\", y.intersp=1)\n\n\n\n\n\n\nFigure 20.2: Deposits (= Loans)\n\n\n\n\n\n# Household wealth under different scenarios\nplot(V_H[1, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylim=(range(V_H[,Tmin:Tmax])), xlim=c(Tmin,Tmax), ylab=expression(V[H])) \ntitle(main=\"\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(V_H[2, 1:Q],lty=2, lwd=2)\nlines(V_H[3, 1:Q],lty=3, lwd=2)\nlines(V_H[4, 1:Q],lty=4, lwd=2)\nlegend(\"right\", legend=c(\"1: AD boost\", \"2: rise in bond finance\", \"3: rise bond demand\", \"4: rise bond premium\"), \n       lty=1:4, cex=0.8, bty = \"n\", y.intersp=1)\n\n\n\n\n\n\nFigure 20.3: Household wealth\n\n\n\n\n\n# Share of bonds in firms' liabilities\nbshare=p_B*B/(p_B*B+L)\nplot(bshare[1, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylim=(range(bshare[,Tmin:Tmax])), xlim=c(Tmin,Tmax), ylab=\"\") \ntitle(main=\"\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(bshare[2, 1:Q],lty=2, lwd=2)\nlines(bshare[3, 1:Q],lty=3, lwd=2)\nlines(bshare[4, 1:Q],lty=4, lwd=2)\nlegend(\"right\", legend=c(\"1: AD boost\", \"2: rise in bond finance\", \"3: rise bond demand\", \"4: rise bond premium\"), \n       lty=1:4, cex=0.8, bty = \"n\", y.intersp=1)\n\n\n\n\n\n\nFigure 20.4: Share of bonds in firms’ liabilities\n\n\n\n\n\n#Bond prices under different scenarios\nplot(p_B[1, 1:Q],type=\"l\", col=1, lwd=2, lty=1, xlab=\"\", ylim=(range(p_B[,Tmin:Tmax])), xlim=c(Tmin,Tmax), ylab=expression(p[B])) \ntitle(main=\"\", xlab = \"Time\",cex=0.8 ,line=2)\nlines(p_B[2, 1:Q],lty=2, lwd=2)\nlines(p_B[3, 1:Q],lty=3, lwd=2)\nlines(p_B[4, 1:Q],lty=4, lwd=2)\nlegend(\"right\", legend=c(\"1: AD boost\", \"2: rise in bond finance\", \"3: rise bond demand\", \"4: rise bond premium\"), \n       lty=1:4, cex=0.8, bty = \"n\", y.intersp=1)\n\n\n\n\n\n\nFigure 20.5: Bond price\n\n\n\n\nThe second scenario, a rise in the share of inventories financed by bonds (\\(\\beta\\)), as expected leads to a higher share of bonds in firms’ liabilities. This affirms \\(\\beta\\)’s role as a liability management parameter reflecting firms preferences for bonds as opposed to loans as a source of external funds. The corresponding increase in the supply of bonds leads to a fall in bond prices and a rise in yields. The money stock falls as loans are partially replaced by bonds. The effect on output is contractionary, which is likely due to the fall in nominal household wealth.\nThe last two scenarios, a rise in autonomous demand for bonds by households (\\(\\lambda_0\\))) and a rise in the premium on corporate bonds offered by firms (\\(\\rho\\)), produce quite similar effects. In both cases, bond demand increases, driving up bond prices. The resulting wealth effect on consumption has a (small) positive effect on output. This illustrates that both households as buyers of bonds and firms as suppliers of bonds can impact bond prices. Shifts in households’ demand for demand, e.g. due to changes in liquidity preference, can alter bond prices. Similarly, firms can manipulate the bond premium to impact demand for bonds and thereby change bond prices. For a given supply of bonds, a rise in the corporate bond premium will drive up bond prices.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#directed-graph",
    "href": "an_sfc_model.html#directed-graph",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "Directed graph",
    "text": "Directed graph\nAnother perspective on the model’s properties is provided by its directed graph. A directed graph consists of a set of nodes that represent the variables of the model. Nodes are connected by directed edges. An edge directed from a node \\(x_1\\) to node \\(x_2\\) indicates a causal impact of \\(x_1\\) on \\(x_2\\).\n\n## Create directed graph\n# Construct auxiliary Jacobian matrix for 16 variables: \n  # endogenous: (1) C, (2) dVH, (3) M, (4) Y, (5) INT, (6) dCE, (7) IN, (8) B, (9) iB, (10) dL, (11) pB\n  # exogenous: (12) alpha0, (13) beta, (14) lambda0, (15) rho, (16) iL=iM\n\n            # C W VH M Y INT CE IN  B iB L pB a0 b l0 rho iM\nM_mat=matrix(c(0,1, 0,1, 0, 0, 0, 0, 0,0,0, 1, 0, 0, 0, 0, # C\n               1,0, 0,1, 0, 0, 0, 1, 0,0,1, 0, 0, 0, 0, 0, # VH\n               0,1, 0,0, 0, 0, 0, 1, 0,0,1, 0, 0, 0, 0, 0, # M\n               0,0, 0,0, 1, 1, 1, 0, 0,0,0, 0, 0, 0, 0, 0, # Y\n               0,0, 0,0, 0, 1, 0, 0, 0,0,0, 0, 0, 0, 0, 0, # INT\n               0,0, 0,0, 1, 0, 1, 0, 0,0,0, 0, 0, 0, 0, 0, # CE\n               1,0, 0,1, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0, # IN\n               0,0, 0,0, 0, 0, 1, 0, 0,0,1, 0, 0, 0, 0, 0, # B\n               0,0, 0,0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 1, 1, # iB\n               0,0, 0,0, 0, 0, 1, 1, 0,0,1, 0, 0, 0, 0, 0, # dL\n               0,1, 0,1, 0, 0, 1, 0, 1,0,0, 0, 1, 1, 0, 1, # pB\n               0,0, 0,0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0, # alpha0\n               0,0, 0,0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0, # beta\n               0,0, 0,0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0, # lambda0\n               0,0, 0,0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0, # rho\n               0,0, 0,0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0), # il=iM\n               16, 16, byrow=TRUE)\n\n# Create adjacency matrix from transpose of auxiliary Jacobian and add column names\nA_mat=t(M_mat)\n\n# Create directed graph from adjacency matrix\nlibrary(igraph)\ndg=graph_from_adjacency_matrix(A_mat, mode=\"directed\", weighted= NULL)\n\n# Define node labels\nV(dg)$name=c(\"C\",expression(V[H]), \"M\", \"Y\", expression(IN^T), expression(Delta*C^E), \"IN\", \"B\",\n             expression(i[B]), expression(Delta*L), expression(p^B), expression(alpha[0]), expression(beta), \n             expression(lambda[0]), expression(rho), expression(i[M]))\n\n# Plot directed graph matrix, use tree-like layout \nplot(dg, layout = layout_as_tree(dg), main=\"\", vertex.size=24, vertex.color=\"lightblue\", \n     vertex.label.color=\"black\", edge.arrow.size=0.3, edge.width=1, edge.size=1,\n     edge.arrow.width=1.2, edge.color=\"black\", vertex.label.cex=1, \n     vertex.frame.color=\"NA\", margin=-0.08)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython code\n\n\n\n\n\n\n## Directed graph\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n\n\n\nGiven the comparatively large number of variables, the directed graph is somewhat busy. We used the tree-like layout to impose some structure. The four exogenous variables considered in the scenarios are grouped at the top. Only autonomous consumption \\((\\alpha_0)\\) has a direct impact on the real part of the model. The other exogenous variables \\((\\beta, \\lambda_0, \\rho, i_M)\\) directly impact bond prices \\(p_B\\) (or the bond rate \\(i_B\\)), which then feeds into the real part of the model via the effect on household wealth. The real and financial parts of the model are connected through the interplay of demand-determined output, the accumulation of saving into wealth, and the effects of wealth on consumption.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#analytical-discussion",
    "href": "an_sfc_model.html#analytical-discussion",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "Analytical discussion",
    "text": "Analytical discussion\nDespite having 14 equations, the model admits some analytical solutions for its steady state. In a steady state, there are no changes in expectations, which requires inventories to be on target, so that \\(C^{E*} = C^*\\), \\(IN^*=IN^{T*}\\), and \\(C^*=Y^*\\).\nUsing these conditions for the steady state and Equation 20.1, Equation 20.7, Equation 20.14 and Equation 20.11, as well as Equation 20.10 and Equation 20.5, respectively, the following implications can be derived:\n\\[\nY^*=\\frac{\\alpha_0+\\alpha_2 V_H^*}{1-\\alpha_1}\n\\]\n\\[\nIN^*=\\sigma Y^*\n\\] \\[\np_t^{B*} = \\frac{(\\rho + i_M) \\lambda_2}{\\left( \\beta \\sigma + \\lambda_3 \\right) \\left( \\frac{\\alpha_0 + \\alpha_2 V_H^*}{V_H^*(1 - a_1)} \\right) - (\\lambda_0 - \\lambda_1 i_M)}.\n\\]\n\\[\nV_H^* = M^* +\\beta \\sigma Y^*\n\\] Using the solution for \\(Y^*\\), the last result can further be written as:\n\\[\nV_H^* = \\frac{M^*(1-\\alpha_1) +\\beta \\sigma \\alpha_0}{1-\\alpha_1-\\beta \\sigma \\alpha_2}.  \n\\tag{20.15}\\]\nWe can confirm these analytical solutions numerically:\n\n### Check analytical solutions (here for the baseline only)\n\n# Equilibrium output\nY[1,Q]                                         # numerical \n\n[1] 6.828243\n\n(alpha_0[1,Q]+alpha_2*V_H[1,Q])/(1-alpha_1)    # analytical\n\n[1] 6.828243\n\n# Equilibrium inventories\nIN[1,Q]                                        # numerical \n\n[1] 2.048473\n\nsigma*Y[1,Q]                                   # analytical\n\n[1] 2.048473\n\n# Equilibrium wealth\nV_H[1,Q]                                       # numerical \n\n[1] 1.328243\n\nM[1,Q] + beta[1,Q]*sigma*Y[1,Q]                # analytical \n\n[1] 1.328243\n\n(M[1,Q]*(1-alpha_1)+beta[1,Q]*sigma*alpha_0[1,Q])/(1-alpha_1-beta[1,Q]*sigma*alpha_2)  # analytical\n\n[1] 1.328243\n\n# Equilibrium bond price\np_B[1,Q]                                      # numerical \n\n[1] 0.02998552\n\n((rho[1,Q]+i_M)*lambda_2)/((beta[1,Q]*sigma+lambda_3)*(alpha_0[1,Q] + alpha_2*V_H[1,Q])/(V_H[1,Q]*(1-alpha_1)) - (lambda_0[1,Q]-lambda_1*i_M))                 # analytical \n\n[1] 0.02998552\n\n\nBy contrast, a derivation of equilibrium solutions for stocks (e.g. \\(V_H^*\\) and \\(M^*\\)) is difficult as they depend on the initialisation and are thus not unique in this model. Similarly, a formal stability analysis is practically infeasible as inventory and consumption dynamics, expectations adjustment, wealth accumulation, and capital gains constitute a comparatively high dimensional dynamic system that does not permit clear-cut stability conditions.\nHowever, from the denominator of the equilibrium solution for household wealth (Equation 20.15), we can at least derive a necessary (but not sufficient) condition for stability, which is:\n\\[\n1-\\alpha_1-\\beta \\sigma \\alpha_2 &gt; 0,\n\\] ensuring that equilibrium wealth is positive.\nFor the parameterisations we consider, this condition is indeed satisfied:\n\n## Check necessary equilibrium condition (for all scenarios)\n(1-alpha_1-beta[,Q]*sigma*alpha_2 &gt; 0)\n\n[1] TRUE TRUE TRUE TRUE",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#references",
    "href": "an_sfc_model.html#references",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "References",
    "text": "References\n\n\n\n\nCaverzasi, E., and A. Godin. 2014. “Post-Keynesian Stock-Flow-Consistent Modelling: A Survey.” Cambridge Journal of Economics 39 (1): 157–87. https://doi.org/10.1093/cje/beu021.\n\n\nGodley, Wynne. 2012. “Weaving Cloth from Graziani’s Thread: Endogenous Money in a Simple (but Complete) Keynesian Model.” In The Stock–Flow Consistent Approach. Selected Writings of Wynne Godley, edited by Marc Lavoie and Gennaro Zezza. Palgrave Macmillan.\n\n\nGodley, Wynne, and Marc Lavoie. 2006. Monetary Economics. An Integrated Approach to Credit, Money, Income, Production and Wealth. Palgrave Macmillan.\n\n\nGraziani, Augusto. 2003. The Monetary Theory of Production. Cambridge University Press.\n\n\nLavoie, Marc. 2022. Post-Keynesian Economics. New Foundations. 2nd ed. Edward Elgar.\n\n\nNikiforos, Michalis, and Gennaro Zezza. 2017. “STOCK‐FLOW CONSISTENT MACROECONOMIC MODELS: A SURVEY.” Journal of Economic Surveys 31 (5): 1204–39. https://doi.org/10.1111/joes.12221.",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "an_sfc_model.html#footnotes",
    "href": "an_sfc_model.html#footnotes",
    "title": "20  A Stock-Flow Consistent Model of the Monetary Circuit",
    "section": "",
    "text": "See Godley and Lavoie (2006). Lavoie (2022), chapter 4.6 provides an introduction, while Caverzasi and Godin (2014) and Nikiforos and Zezza (2017) survey research in the field. Some online resources can be found in Chapter 21.↩︎\nA more complex version of this model can be found in Godley and Lavoie (2006), chapter 9.↩︎\nThe assumption of perfect foresight made in Godley (2012) was also relaxed in Godley and Lavoie (2006), chapter 9. However, we will use a different (simpler) specification for sales expectations and inventory management.↩︎\nAs a result, the aggregate wage share \\(\\frac{W}{pY}=\\frac{w}{p\\delta}\\) is constant in this model.↩︎",
    "crumbs": [
      "Dynamic Models",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>A Stock-Flow Consistent Model of the Monetary Circuit</span>"
    ]
  },
  {
    "objectID": "additional_resources.html",
    "href": "additional_resources.html",
    "title": "21  Additional Online Resources",
    "section": "",
    "text": "Economic Modelling in General",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Additional Online Resources</span>"
    ]
  },
  {
    "objectID": "additional_resources.html#economic-modelling-in-general",
    "href": "additional_resources.html#economic-modelling-in-general",
    "title": "21  Additional Online Resources",
    "section": "",
    "text": "Sayama (2015) is a free introductory textbook for the modelling and simulation of complex systems in Python\nQuantEcon provides online intermediate and advanced resources for economic modelling and data analysis in Python and Julia",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Additional Online Resources</span>"
    ]
  },
  {
    "objectID": "additional_resources.html#stock-flow-consistent-modelling",
    "href": "additional_resources.html#stock-flow-consistent-modelling",
    "title": "21  Additional Online Resources",
    "section": "Stock-Flow Consistent Modelling",
    "text": "Stock-Flow Consistent Modelling\n\nMarco Veronese Passarella’s website provides R codes for most chapters of Monetary Economics: An Integrated Approach to Credit, Money, Income, Production and Wealth by Wynne Godley and Marc Lavoie, and more\nSFC Models provides resources on stock-flow consistent modelling",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Additional Online Resources</span>"
    ]
  },
  {
    "objectID": "additional_resources.html#agent-based-modelling",
    "href": "additional_resources.html#agent-based-modelling",
    "title": "21  Additional Online Resources",
    "section": "Agent-Based Modelling",
    "text": "Agent-Based Modelling\n\nAlessandro Caiani’s website provides R codes for simple agent-based models, including those in the introductory book Economics with Heterogeneous Interacting Agents: A Practical Guide to Agent-Based Modeling by Alessandro Caiani, Alberto Russo, Antonio Palestrini and Mauro Gallegati",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Additional Online Resources</span>"
    ]
  },
  {
    "objectID": "additional_resources.html#coding",
    "href": "additional_resources.html#coding",
    "title": "21  Additional Online Resources",
    "section": "Coding",
    "text": "Coding\n\nCoding for Economists provides a guide for coding in Python",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Additional Online Resources</span>"
    ]
  }
]